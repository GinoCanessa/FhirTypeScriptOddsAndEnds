// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: VisionPrescription
import * as fhir from '../fhir.js';
import { VisionBaseCodesValueSet, } from '../fhirValueSets/VisionBaseCodesValueSet.js';
import { VisionProductValueSet, } from '../fhirValueSets/VisionProductValueSet.js';
import { VisionEyeCodesValueSet, } from '../fhirValueSets/VisionEyeCodesValueSet.js';
import { FmStatusValueSet, } from '../fhirValueSets/FmStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Allows for adjustment on two axis.
 */
export class VisionPrescriptionLensSpecificationPrism extends fhir.BackboneElement {
    /**
     * Default constructor for VisionPrescriptionLensSpecificationPrism - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'VisionPrescriptionLensSpecificationPrism';
        if (source['amount']) {
            this.amount = new fhir.FhirDecimal({ value: source.amount });
        }
        else {
            this.amount = null;
        }
        if (source['base']) {
            this.base = source.base;
        }
        else {
            this.base = null;
        }
    }
    /**
     * Required-bound Value Set for base
     */
    static baseRequiredValueSet() {
        return VisionBaseCodesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['amount']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property amount:fhir.FhirDecimal fhir: VisionPrescription.lensSpecification.prism.amount:decimal", }));
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        if (!this['base']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property base:VisionBaseCodesValueSetEnum fhir: VisionPrescription.lensSpecification.prism.base:code", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
 */
export class VisionPrescriptionLensSpecification extends fhir.BackboneElement {
    /**
     * Default constructor for VisionPrescriptionLensSpecification - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'VisionPrescriptionLensSpecification';
        /**
         * Allows for adjustment on two axis.
         */
        this.prism = [];
        /**
         * Notes for special requirements such as coatings and lens materials.
         */
        this.note = [];
        if (source['product']) {
            this.product = new fhir.CodeableConcept(source.product);
        }
        else {
            this.product = null;
        }
        if (source['eye']) {
            this.eye = source.eye;
        }
        else {
            this.eye = null;
        }
        if (source['sphere']) {
            this.sphere = new fhir.FhirDecimal({ value: source.sphere });
        }
        if (source['cylinder']) {
            this.cylinder = new fhir.FhirDecimal({ value: source.cylinder });
        }
        if (source['axis']) {
            this.axis = new fhir.FhirInteger({ value: source.axis });
        }
        if (source['prism']) {
            this.prism = source.prism.map((x) => new fhir.VisionPrescriptionLensSpecificationPrism(x));
        }
        if (source['add']) {
            this.add = new fhir.FhirDecimal({ value: source.add });
        }
        if (source['power']) {
            this.power = new fhir.FhirDecimal({ value: source.power });
        }
        if (source['backCurve']) {
            this.backCurve = new fhir.FhirDecimal({ value: source.backCurve });
        }
        if (source['diameter']) {
            this.diameter = new fhir.FhirDecimal({ value: source.diameter });
        }
        if (source['duration']) {
            this.duration = new fhir.Quantity(source.duration);
        }
        if (source['color']) {
            this.color = new fhir.FhirString({ value: source.color });
        }
        if (source['brand']) {
            this.brand = new fhir.FhirString({ value: source.brand });
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Example-bound Value Set for product
     */
    static productExampleValueSet() {
        return VisionProductValueSet;
    }
    /**
     * Required-bound Value Set for eye
     */
    static eyeRequiredValueSet() {
        return VisionEyeCodesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['product']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property product:fhir.CodeableConcept fhir: VisionPrescription.lensSpecification.product:CodeableConcept", }));
        }
        if (this["product"]) {
            outcome.issue.push(...this.product.doModelValidation().issue);
        }
        if (!this['eye']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property eye:VisionEyeCodesValueSetEnum fhir: VisionPrescription.lensSpecification.eye:code", }));
        }
        if (this["sphere"]) {
            outcome.issue.push(...this.sphere.doModelValidation().issue);
        }
        if (this["cylinder"]) {
            outcome.issue.push(...this.cylinder.doModelValidation().issue);
        }
        if (this["axis"]) {
            outcome.issue.push(...this.axis.doModelValidation().issue);
        }
        if (this["prism"]) {
            this.prism.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["add"]) {
            outcome.issue.push(...this.add.doModelValidation().issue);
        }
        if (this["power"]) {
            outcome.issue.push(...this.power.doModelValidation().issue);
        }
        if (this["backCurve"]) {
            outcome.issue.push(...this.backCurve.doModelValidation().issue);
        }
        if (this["diameter"]) {
            outcome.issue.push(...this.diameter.doModelValidation().issue);
        }
        if (this["duration"]) {
            outcome.issue.push(...this.duration.doModelValidation().issue);
        }
        if (this["color"]) {
            outcome.issue.push(...this.color.doModelValidation().issue);
        }
        if (this["brand"]) {
            outcome.issue.push(...this.brand.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An authorization for the provision of glasses and/or contact lenses to a patient.
 */
export class VisionPrescription extends fhir.DomainResource {
    /**
     * Default constructor for VisionPrescription - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'VisionPrescription';
        /**
         * A unique identifier assigned to this vision prescription.
         */
        this.identifier = [];
        /**
         * Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
         */
        this.lensSpecification = [];
        this.resourceType = 'VisionPrescription';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['created']) {
            this.created = new fhir.FhirDateTime({ value: source.created });
        }
        else {
            this.created = null;
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        else {
            this.patient = null;
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['dateWritten']) {
            this.dateWritten = new fhir.FhirDateTime({ value: source.dateWritten });
        }
        else {
            this.dateWritten = null;
        }
        if (source['prescriber']) {
            this.prescriber = new fhir.Reference(source.prescriber);
        }
        else {
            this.prescriber = null;
        }
        if (source['lensSpecification']) {
            this.lensSpecification = source.lensSpecification.map((x) => new fhir.VisionPrescriptionLensSpecification(x));
        }
        else {
            this.lensSpecification = null;
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return FmStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'VisionPrescription' fhir: VisionPrescription.resourceType:'VisionPrescription'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:FmStatusValueSetEnum fhir: VisionPrescription.status:code", }));
        }
        if (!this['created']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property created:fhir.FhirDateTime fhir: VisionPrescription.created:dateTime", }));
        }
        if (this["created"]) {
            outcome.issue.push(...this.created.doModelValidation().issue);
        }
        if (!this['patient']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property patient:fhir.Reference fhir: VisionPrescription.patient:Reference", }));
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["encounter"]) {
            outcome.issue.push(...this.encounter.doModelValidation().issue);
        }
        if (!this['dateWritten']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property dateWritten:fhir.FhirDateTime fhir: VisionPrescription.dateWritten:dateTime", }));
        }
        if (this["dateWritten"]) {
            outcome.issue.push(...this.dateWritten.doModelValidation().issue);
        }
        if (!this['prescriber']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property prescriber:fhir.Reference fhir: VisionPrescription.prescriber:Reference", }));
        }
        if (this["prescriber"]) {
            outcome.issue.push(...this.prescriber.doModelValidation().issue);
        }
        if (!this['lensSpecification']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property lensSpecification:fhir.VisionPrescriptionLensSpecification[] fhir: VisionPrescription.lensSpecification:lensSpecification", }));
        }
        else if (!Array.isArray(this.lensSpecification)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property lensSpecification:fhir.VisionPrescriptionLensSpecification[] fhir: VisionPrescription.lensSpecification:lensSpecification", }));
        }
        else if (this.lensSpecification.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property lensSpecification:fhir.VisionPrescriptionLensSpecification[] fhir: VisionPrescription.lensSpecification:lensSpecification", }));
        }
        if (this["lensSpecification"]) {
            this.lensSpecification.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=VisionPrescription.js.map