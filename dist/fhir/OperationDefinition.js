// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: OperationDefinition
import * as fhir from '../fhir.js';
import { BindingStrengthValueSet } from '../fhirValueSets/BindingStrengthValueSet.js';
import { OperationParameterUseValueSet } from '../fhirValueSets/OperationParameterUseValueSet.js';
import { AllTypesValueSet } from '../fhirValueSets/AllTypesValueSet.js';
import { SearchParamTypeValueSet } from '../fhirValueSets/SearchParamTypeValueSet.js';
import { PublicationStatusValueSet } from '../fhirValueSets/PublicationStatusValueSet.js';
import { OperationKindValueSet } from '../fhirValueSets/OperationKindValueSet.js';
import { ResourceTypesValueSet } from '../fhirValueSets/ResourceTypesValueSet.js';
/**
 * Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
 */
export class OperationDefinitionParameterBinding extends fhir.BackboneElement {
    /**
     * Default constructor for OperationDefinitionParameterBinding - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['strength']) {
            this.strength = source.strength;
        }
        else {
            this.strength = null;
        }
        if (source['_strength']) {
            this._strength = new fhir.FhirElement(source._strength);
        }
        if (source['valueSet']) {
            this.valueSet = source.valueSet;
        }
        else {
            this.valueSet = null;
        }
        if (source['_valueSet']) {
            this._valueSet = new fhir.FhirElement(source._valueSet);
        }
    }
    /**
     * Required-bound Value Set for strength
     */
    strengthRequiredValueSet() {
        return BindingStrengthValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["strength"]) {
            results.push(["strength", 'Missing required element: OperationDefinition.parameter.binding.strength']);
        }
        if (this["_strength"]) {
            results.push(...this._strength.doModelValidation());
        }
        if (!this["valueSet"]) {
            results.push(["valueSet", 'Missing required element: OperationDefinition.parameter.binding.valueSet']);
        }
        if (this["_valueSet"]) {
            results.push(...this._valueSet.doModelValidation());
        }
        return results;
    }
}
/**
 * Resolution applies if the referenced parameter exists.
 */
export class OperationDefinitionParameterReferencedFrom extends fhir.BackboneElement {
    /**
     * Default constructor for OperationDefinitionParameterReferencedFrom - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['source']) {
            this.source = source.source;
        }
        else {
            this.source = null;
        }
        if (source['_source']) {
            this._source = new fhir.FhirElement(source._source);
        }
        if (source['sourceId']) {
            this.sourceId = source.sourceId;
        }
        if (source['_sourceId']) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["source"]) {
            results.push(["source", 'Missing required element: OperationDefinition.parameter.referencedFrom.source']);
        }
        if (this["_source"]) {
            results.push(...this._source.doModelValidation());
        }
        if (this["_sourceId"]) {
            results.push(...this._sourceId.doModelValidation());
        }
        return results;
    }
}
/**
 * Query Definitions only have one output parameter, named "result". This might not be described, but can be to allow a profile to be defined.
 */
export class OperationDefinitionParameter extends fhir.BackboneElement {
    /**
     * Default constructor for OperationDefinitionParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['use']) {
            this.use = source.use;
        }
        else {
            this.use = null;
        }
        if (source['_use']) {
            this._use = new fhir.FhirElement(source._use);
        }
        if (source['min']) {
            this.min = source.min;
        }
        else {
            this.min = null;
        }
        if (source['_min']) {
            this._min = new fhir.FhirElement(source._min);
        }
        if (source['max']) {
            this.max = source.max;
        }
        else {
            this.max = null;
        }
        if (source['_max']) {
            this._max = new fhir.FhirElement(source._max);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source['type']) {
            this.type = source.type;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source['targetProfile']) {
            this.targetProfile = source.targetProfile.map((x) => (x));
        }
        if (source['_targetProfile']) {
            this._targetProfile = source._targetProfile.map((x) => new fhir.FhirElement(x));
        }
        if (source['searchType']) {
            this.searchType = source.searchType;
        }
        if (source['_searchType']) {
            this._searchType = new fhir.FhirElement(source._searchType);
        }
        if (source['binding']) {
            this.binding = new fhir.OperationDefinitionParameterBinding(source.binding);
        }
        if (source['referencedFrom']) {
            this.referencedFrom = source.referencedFrom.map((x) => new fhir.OperationDefinitionParameterReferencedFrom(x));
        }
        if (source['part']) {
            this.part = source.part.map((x) => new fhir.OperationDefinitionParameter(x));
        }
    }
    /**
     * Required-bound Value Set for use
     */
    useRequiredValueSet() {
        return OperationParameterUseValueSet;
    }
    /**
     * Required-bound Value Set for type
     */
    typeRequiredValueSet() {
        return AllTypesValueSet;
    }
    /**
     * Required-bound Value Set for searchType
     */
    searchTypeRequiredValueSet() {
        return SearchParamTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["name"]) {
            results.push(["name", 'Missing required element: OperationDefinition.parameter.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (!this["use"]) {
            results.push(["use", 'Missing required element: OperationDefinition.parameter.use']);
        }
        if (this["_use"]) {
            results.push(...this._use.doModelValidation());
        }
        if (!this["min"]) {
            results.push(["min", 'Missing required element: OperationDefinition.parameter.min']);
        }
        if (this["_min"]) {
            results.push(...this._min.doModelValidation());
        }
        if (!this["max"]) {
            results.push(["max", 'Missing required element: OperationDefinition.parameter.max']);
        }
        if (this["_max"]) {
            results.push(...this._max.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        if (this["_targetProfile"]) {
            this._targetProfile.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_searchType"]) {
            results.push(...this._searchType.doModelValidation());
        }
        if (this["binding"]) {
            results.push(...this.binding.doModelValidation());
        }
        if (this["referencedFrom"]) {
            this.referencedFrom.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["part"]) {
            this.part.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * The combinations are suggestions as to which sets of parameters to use together, but the combinations are not intended to be authoritative.
 */
export class OperationDefinitionOverload extends fhir.BackboneElement {
    /**
     * Default constructor for OperationDefinitionOverload - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['parameterName']) {
            this.parameterName = source.parameterName.map((x) => (x));
        }
        if (source['_parameterName']) {
            this._parameterName = source._parameterName.map((x) => new fhir.FhirElement(x));
        }
        if (source['comment']) {
            this.comment = source.comment;
        }
        if (source['_comment']) {
            this._comment = new fhir.FhirElement(source._comment);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_parameterName"]) {
            this._parameterName.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_comment"]) {
            results.push(...this._comment.doModelValidation());
        }
        return results;
    }
}
/**
 * A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
 */
export class OperationDefinition extends fhir.DomainResource {
    /**
     * Default constructor for OperationDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'OperationDefinition';
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['title']) {
            this.title = source.title;
        }
        if (source['_title']) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['kind']) {
            this.kind = source.kind;
        }
        else {
            this.kind = null;
        }
        if (source['_kind']) {
            this._kind = new fhir.FhirElement(source._kind);
        }
        if (source['experimental']) {
            this.experimental = source.experimental;
        }
        if (source['_experimental']) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source['date']) {
            this.date = source.date;
        }
        if (source['_date']) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source['publisher']) {
            this.publisher = source.publisher;
        }
        if (source['_publisher']) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = source.purpose;
        }
        if (source['_purpose']) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source['affectsState']) {
            this.affectsState = source.affectsState;
        }
        if (source['_affectsState']) {
            this._affectsState = new fhir.FhirElement(source._affectsState);
        }
        if (source['code']) {
            this.code = source.code;
        }
        else {
            this.code = null;
        }
        if (source['_code']) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source['comment']) {
            this.comment = source.comment;
        }
        if (source['_comment']) {
            this._comment = new fhir.FhirElement(source._comment);
        }
        if (source['base']) {
            this.base = source.base;
        }
        if (source['_base']) {
            this._base = new fhir.FhirElement(source._base);
        }
        if (source['resource']) {
            this.resource = source.resource.map((x) => (x));
        }
        if (source['_resource']) {
            this._resource = source._resource.map((x) => new fhir.FhirElement(x));
        }
        if (source['system']) {
            this.system = source.system;
        }
        else {
            this.system = null;
        }
        if (source['_system']) {
            this._system = new fhir.FhirElement(source._system);
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source['instance']) {
            this.instance = source.instance;
        }
        else {
            this.instance = null;
        }
        if (source['_instance']) {
            this._instance = new fhir.FhirElement(source._instance);
        }
        if (source['inputProfile']) {
            this.inputProfile = source.inputProfile;
        }
        if (source['_inputProfile']) {
            this._inputProfile = new fhir.FhirElement(source._inputProfile);
        }
        if (source['outputProfile']) {
            this.outputProfile = source.outputProfile;
        }
        if (source['_outputProfile']) {
            this._outputProfile = new fhir.FhirElement(source._outputProfile);
        }
        if (source['parameter']) {
            this.parameter = source.parameter.map((x) => new fhir.OperationDefinitionParameter(x));
        }
        if (source['overload']) {
            this.overload = source.overload.map((x) => new fhir.OperationDefinitionOverload(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Required-bound Value Set for kind
     */
    kindRequiredValueSet() {
        return OperationKindValueSet;
    }
    /**
     * Required-bound Value Set for resource
     */
    resourceRequiredValueSet() {
        return ResourceTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: OperationDefinition.resourceType']);
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        if (!this["name"]) {
            results.push(["name", 'Missing required element: OperationDefinition.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_title"]) {
            results.push(...this._title.doModelValidation());
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: OperationDefinition.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (!this["kind"]) {
            results.push(["kind", 'Missing required element: OperationDefinition.kind']);
        }
        if (this["_kind"]) {
            results.push(...this._kind.doModelValidation());
        }
        if (this["_experimental"]) {
            results.push(...this._experimental.doModelValidation());
        }
        if (this["_date"]) {
            results.push(...this._date.doModelValidation());
        }
        if (this["_publisher"]) {
            results.push(...this._publisher.doModelValidation());
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_purpose"]) {
            results.push(...this._purpose.doModelValidation());
        }
        if (this["_affectsState"]) {
            results.push(...this._affectsState.doModelValidation());
        }
        if (!this["code"]) {
            results.push(["code", 'Missing required element: OperationDefinition.code']);
        }
        if (this["_code"]) {
            results.push(...this._code.doModelValidation());
        }
        if (this["_comment"]) {
            results.push(...this._comment.doModelValidation());
        }
        if (this["_base"]) {
            results.push(...this._base.doModelValidation());
        }
        if (this["_resource"]) {
            this._resource.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["system"]) {
            results.push(["system", 'Missing required element: OperationDefinition.system']);
        }
        if (this["_system"]) {
            results.push(...this._system.doModelValidation());
        }
        if (!this["type"]) {
            results.push(["type", 'Missing required element: OperationDefinition.type']);
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        if (!this["instance"]) {
            results.push(["instance", 'Missing required element: OperationDefinition.instance']);
        }
        if (this["_instance"]) {
            results.push(...this._instance.doModelValidation());
        }
        if (this["_inputProfile"]) {
            results.push(...this._inputProfile.doModelValidation());
        }
        if (this["_outputProfile"]) {
            results.push(...this._outputProfile.doModelValidation());
        }
        if (this["parameter"]) {
            this.parameter.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["overload"]) {
            this.overload.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=OperationDefinition.js.map