// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
 */
export class ConsentPolicy extends fhir.BackboneElement {
    /**
     * Default constructor for ConsentPolicy - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["authority"]) {
            this.authority = source.authority;
        }
        if (source["_authority"]) {
            this._authority = new fhir.FhirElement(source._authority);
        }
        if (source["uri"]) {
            this.uri = source.uri;
        }
        if (source["_uri"]) {
            this._uri = new fhir.FhirElement(source._uri);
        }
    }
    /**
     * Check if the current ConsentPolicy contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConsentPolicy from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ConsentPolicy(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConsentPolicy is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
 */
export class ConsentVerification extends fhir.BackboneElement {
    /**
     * Default constructor for ConsentVerification - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["verificationDate"]) {
            this.verificationDate = source.verificationDate;
        }
        if (source["_verificationDate"]) {
            this._verificationDate = new fhir.FhirElement(source._verificationDate);
        }
        this.verified = null;
        if (source["verified"]) {
            this.verified = source.verified;
        }
        if (this.verified === undefined) {
            this.verified = null;
        }
        if (source["_verified"]) {
            this._verified = new fhir.FhirElement(source._verified);
        }
        if (source["verifiedWith"]) {
            this.verifiedWith = new fhir.Reference(source.verifiedWith);
        }
    }
    /**
     * Check if the current ConsentVerification contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["verified"] === undefined) {
            missingElements.push("verified");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConsentVerification from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ConsentVerification(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConsentVerification is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
 */
export class ConsentProvisionActor extends fhir.BackboneElement {
    /**
     * Default constructor for ConsentProvisionActor - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.reference = null;
        if (source["reference"]) {
            this.reference = new fhir.Reference(source.reference);
        }
        if (this.reference === undefined) {
            this.reference = null;
        }
        this.role = null;
        if (source["role"]) {
            this.role = new fhir.CodeableConcept(source.role);
        }
        if (this.role === undefined) {
            this.role = null;
        }
    }
    /**
     * Check if the current ConsentProvisionActor contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["reference"] === undefined) {
            missingElements.push("reference");
        }
        if (this["role"] === undefined) {
            missingElements.push("role");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConsentProvisionActor from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ConsentProvisionActor(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConsentProvisionActor is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The resources controlled by this rule if specific resources are referenced.
 */
export class ConsentProvisionData extends fhir.BackboneElement {
    /**
     * Default constructor for ConsentProvisionData - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.meaning = null;
        if (source["meaning"]) {
            this.meaning = source.meaning;
        }
        if (this.meaning === undefined) {
            this.meaning = null;
        }
        if (source["_meaning"]) {
            this._meaning = new fhir.FhirElement(source._meaning);
        }
        this.reference = null;
        if (source["reference"]) {
            this.reference = new fhir.Reference(source.reference);
        }
        if (this.reference === undefined) {
            this.reference = null;
        }
    }
    /**
     * Check if the current ConsentProvisionData contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["meaning"] === undefined) {
            missingElements.push("meaning");
        }
        if (this["reference"] === undefined) {
            missingElements.push("reference");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConsentProvisionData from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ConsentProvisionData(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConsentProvisionData is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
 */
export class ConsentProvision extends fhir.BackboneElement {
    /**
     * Default constructor for ConsentProvision - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["action"]) {
            this.action = source.action.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["actor"]) {
            this.actor = source.actor.map((x) => new fhir.ConsentProvisionActor(x));
        }
        if (source["class"]) {
            this.class = source.class.map((x) => new fhir.Coding(x));
        }
        if (source["code"]) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["data"]) {
            this.data = source.data.map((x) => new fhir.ConsentProvisionData(x));
        }
        if (source["dataPeriod"]) {
            this.dataPeriod = new fhir.Period(source.dataPeriod);
        }
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (source["provision"]) {
            this.provision = source.provision.map((x) => new fhir.ConsentProvision(x));
        }
        if (source["purpose"]) {
            this.purpose = source.purpose.map((x) => new fhir.Coding(x));
        }
        if (source["securityLabel"]) {
            this.securityLabel = source.securityLabel.map((x) => new fhir.Coding(x));
        }
        if (source["type"]) {
            this.type = source.type;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Check if the current ConsentProvision contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConsentProvision from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ConsentProvision(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConsentProvision is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A record of a healthcare consumerâ€™s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
 */
export class Consent extends fhir.DomainResource {
    /**
     * Default constructor for Consent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Consent';
        this.category = null;
        if (source["category"]) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (this.category === undefined) {
            this.category = null;
        }
        if (source["dateTime"]) {
            this.dateTime = source.dateTime;
        }
        if (source["_dateTime"]) {
            this._dateTime = new fhir.FhirElement(source._dateTime);
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["organization"]) {
            this.organization = source.organization.map((x) => new fhir.Reference(x));
        }
        if (source["patient"]) {
            this.patient = new fhir.Reference(source.patient);
        }
        if (source["performer"]) {
            this.performer = source.performer.map((x) => new fhir.Reference(x));
        }
        if (source["policy"]) {
            this.policy = source.policy.map((x) => new fhir.ConsentPolicy(x));
        }
        if (source["policyRule"]) {
            this.policyRule = new fhir.CodeableConcept(source.policyRule);
        }
        if (source["provision"]) {
            this.provision = new fhir.ConsentProvision(source.provision);
        }
        this.scope = null;
        if (source["scope"]) {
            this.scope = new fhir.CodeableConcept(source.scope);
        }
        if (this.scope === undefined) {
            this.scope = null;
        }
        if (source["sourceAttachment"]) {
            this.sourceAttachment = new fhir.Attachment(source.sourceAttachment);
        }
        if (source["sourceReference"]) {
            this.sourceReference = new fhir.Reference(source.sourceReference);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["verification"]) {
            this.verification = source.verification.map((x) => new fhir.ConsentVerification(x));
        }
    }
    /**
     * Check if the current Consent contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["category"]) || (this["category"].length === 0)) {
            missingElements.push("category");
        }
        if (this["scope"] === undefined) {
            missingElements.push("scope");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Consent from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new Consent(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `Consent is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the Consent.provision.data.meaning field
 */
export var ConsentProvisionDataMeaningEnum;
(function (ConsentProvisionDataMeaningEnum) {
    ConsentProvisionDataMeaningEnum["INSTANCE"] = "instance";
    ConsentProvisionDataMeaningEnum["RELATED"] = "related";
    ConsentProvisionDataMeaningEnum["DEPENDENTS"] = "dependents";
    ConsentProvisionDataMeaningEnum["AUTHOREDBY"] = "authoredby";
})(ConsentProvisionDataMeaningEnum || (ConsentProvisionDataMeaningEnum = {}));
/**
 * Code Values for the Consent.provision.type field
 */
export var ConsentProvisionTypeEnum;
(function (ConsentProvisionTypeEnum) {
    ConsentProvisionTypeEnum["DENY"] = "deny";
    ConsentProvisionTypeEnum["PERMIT"] = "permit";
})(ConsentProvisionTypeEnum || (ConsentProvisionTypeEnum = {}));
/**
 * Code Values for the Consent.status field
 */
export var ConsentStatusEnum;
(function (ConsentStatusEnum) {
    ConsentStatusEnum["DRAFT"] = "draft";
    ConsentStatusEnum["PROPOSED"] = "proposed";
    ConsentStatusEnum["ACTIVE"] = "active";
    ConsentStatusEnum["REJECTED"] = "rejected";
    ConsentStatusEnum["INACTIVE"] = "inactive";
    ConsentStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
})(ConsentStatusEnum || (ConsentStatusEnum = {}));
//# sourceMappingURL=Consent.js.map