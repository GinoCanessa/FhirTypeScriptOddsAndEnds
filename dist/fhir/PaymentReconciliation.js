// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: PaymentReconciliation
import * as fhir from '../fhir.js';
import { PaymentTypeValueSet, } from '../fhirValueSets/PaymentTypeValueSet.js';
import { NoteTypeValueSet, } from '../fhirValueSets/NoteTypeValueSet.js';
import { FmStatusValueSet, } from '../fhirValueSets/FmStatusValueSet.js';
import { RemittanceOutcomeValueSet, } from '../fhirValueSets/RemittanceOutcomeValueSet.js';
import { FormsValueSet, } from '../fhirValueSets/FormsValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Distribution of the payment amount for a previously acknowledged payable.
 */
export class PaymentReconciliationDetail extends fhir.BackboneElement {
    /**
     * Default constructor for PaymentReconciliationDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PaymentReconciliationDetail';
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['predecessor']) {
            this.predecessor = new fhir.Identifier(source.predecessor);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['request']) {
            this.request = new fhir.Reference(source.request);
        }
        if (source['submitter']) {
            this.submitter = new fhir.Reference(source.submitter);
        }
        if (source['response']) {
            this.response = new fhir.Reference(source.response);
        }
        if (source['date']) {
            this.date = new fhir.FhirDate({ value: source.date });
        }
        if (source['responsible']) {
            this.responsible = new fhir.Reference(source.responsible);
        }
        if (source['payee']) {
            this.payee = new fhir.Reference(source.payee);
        }
        if (source['amount']) {
            this.amount = new fhir.Money(source.amount);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return PaymentTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (this["predecessor"]) {
            outcome.issue.push(...this.predecessor.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: PaymentReconciliation.detail.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["request"]) {
            outcome.issue.push(...this.request.doModelValidation().issue);
        }
        if (this["submitter"]) {
            outcome.issue.push(...this.submitter.doModelValidation().issue);
        }
        if (this["response"]) {
            outcome.issue.push(...this.response.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["responsible"]) {
            outcome.issue.push(...this.responsible.doModelValidation().issue);
        }
        if (this["payee"]) {
            outcome.issue.push(...this.payee.doModelValidation().issue);
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A note that describes or explains the processing in a human readable form.
 */
export class PaymentReconciliationProcessNote extends fhir.BackboneElement {
    /**
     * Default constructor for PaymentReconciliationProcessNote - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PaymentReconciliationProcessNote';
        if (source['type']) {
            this.type = source.type;
        }
        if (source['text']) {
            this.text = new fhir.FhirString({ value: source.text });
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return NoteTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["text"]) {
            outcome.issue.push(...this.text.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This resource provides the details including amount of a payment and allocates the payment items being paid.
 */
export class PaymentReconciliation extends fhir.DomainResource {
    /**
     * Default constructor for PaymentReconciliation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PaymentReconciliation';
        /**
         * A unique identifier assigned to this payment reconciliation.
         */
        this.identifier = [];
        /**
         * Distribution of the payment amount for a previously acknowledged payable.
         */
        this.detail = [];
        /**
         * A note that describes or explains the processing in a human readable form.
         */
        this.processNote = [];
        this.resourceType = 'PaymentReconciliation';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['period']) {
            this.period = new fhir.Period(source.period);
        }
        if (source['created']) {
            this.created = new fhir.FhirDateTime({ value: source.created });
        }
        else {
            this.created = null;
        }
        if (source['paymentIssuer']) {
            this.paymentIssuer = new fhir.Reference(source.paymentIssuer);
        }
        if (source['request']) {
            this.request = new fhir.Reference(source.request);
        }
        if (source['requestor']) {
            this.requestor = new fhir.Reference(source.requestor);
        }
        if (source['outcome']) {
            this.outcome = source.outcome;
        }
        if (source['disposition']) {
            this.disposition = new fhir.FhirString({ value: source.disposition });
        }
        if (source['paymentDate']) {
            this.paymentDate = new fhir.FhirDate({ value: source.paymentDate });
        }
        else {
            this.paymentDate = null;
        }
        if (source['paymentAmount']) {
            this.paymentAmount = new fhir.Money(source.paymentAmount);
        }
        else {
            this.paymentAmount = null;
        }
        if (source['paymentIdentifier']) {
            this.paymentIdentifier = new fhir.Identifier(source.paymentIdentifier);
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.PaymentReconciliationDetail(x));
        }
        if (source['formCode']) {
            this.formCode = new fhir.CodeableConcept(source.formCode);
        }
        if (source['processNote']) {
            this.processNote = source.processNote.map((x) => new fhir.PaymentReconciliationProcessNote(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return FmStatusValueSet;
    }
    /**
     * Required-bound Value Set for outcome
     */
    static outcomeRequiredValueSet() {
        return RemittanceOutcomeValueSet;
    }
    /**
     * Example-bound Value Set for formCode
     */
    static formCodeExampleValueSet() {
        return FormsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'PaymentReconciliation' fhir: PaymentReconciliation.resourceType:'PaymentReconciliation'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:FmStatusValueSetEnum fhir: PaymentReconciliation.status:code", }));
        }
        if (this["period"]) {
            outcome.issue.push(...this.period.doModelValidation().issue);
        }
        if (!this['created']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property created:fhir.FhirDateTime fhir: PaymentReconciliation.created:dateTime", }));
        }
        if (this["created"]) {
            outcome.issue.push(...this.created.doModelValidation().issue);
        }
        if (this["paymentIssuer"]) {
            outcome.issue.push(...this.paymentIssuer.doModelValidation().issue);
        }
        if (this["request"]) {
            outcome.issue.push(...this.request.doModelValidation().issue);
        }
        if (this["requestor"]) {
            outcome.issue.push(...this.requestor.doModelValidation().issue);
        }
        if (this["disposition"]) {
            outcome.issue.push(...this.disposition.doModelValidation().issue);
        }
        if (!this['paymentDate']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property paymentDate:fhir.FhirDate fhir: PaymentReconciliation.paymentDate:date", }));
        }
        if (this["paymentDate"]) {
            outcome.issue.push(...this.paymentDate.doModelValidation().issue);
        }
        if (!this['paymentAmount']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property paymentAmount:fhir.Money fhir: PaymentReconciliation.paymentAmount:Money", }));
        }
        if (this["paymentAmount"]) {
            outcome.issue.push(...this.paymentAmount.doModelValidation().issue);
        }
        if (this["paymentIdentifier"]) {
            outcome.issue.push(...this.paymentIdentifier.doModelValidation().issue);
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["formCode"]) {
            outcome.issue.push(...this.formCode.doModelValidation().issue);
        }
        if (this["processNote"]) {
            this.processNote.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=PaymentReconciliation.js.map