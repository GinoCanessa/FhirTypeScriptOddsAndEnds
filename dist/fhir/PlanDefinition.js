// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: PlanDefinition
import * as fhir from '../fhir.js';
import { ObservationCodesValueSet, } from '../fhirValueSets/ObservationCodesValueSet.js';
import { GoalCategoryValueSet, } from '../fhirValueSets/GoalCategoryValueSet.js';
import { ClinicalFindingsValueSet, } from '../fhirValueSets/ClinicalFindingsValueSet.js';
import { GoalPriorityValueSet, } from '../fhirValueSets/GoalPriorityValueSet.js';
import { GoalStartEventValueSet, } from '../fhirValueSets/GoalStartEventValueSet.js';
import { ConditionCodeValueSet, } from '../fhirValueSets/ConditionCodeValueSet.js';
import { ActionConditionKindValueSet, } from '../fhirValueSets/ActionConditionKindValueSet.js';
import { ActionRelationshipTypeValueSet, } from '../fhirValueSets/ActionRelationshipTypeValueSet.js';
import { ActionParticipantTypeValueSet, } from '../fhirValueSets/ActionParticipantTypeValueSet.js';
import { RequestPriorityValueSet, } from '../fhirValueSets/RequestPriorityValueSet.js';
import { ActionTypeValueSet, } from '../fhirValueSets/ActionTypeValueSet.js';
import { ActionGroupingBehaviorValueSet, } from '../fhirValueSets/ActionGroupingBehaviorValueSet.js';
import { ActionSelectionBehaviorValueSet, } from '../fhirValueSets/ActionSelectionBehaviorValueSet.js';
import { ActionRequiredBehaviorValueSet, } from '../fhirValueSets/ActionRequiredBehaviorValueSet.js';
import { ActionPrecheckBehaviorValueSet, } from '../fhirValueSets/ActionPrecheckBehaviorValueSet.js';
import { ActionCardinalityBehaviorValueSet, } from '../fhirValueSets/ActionCardinalityBehaviorValueSet.js';
import { PlanDefinitionTypeValueSet, } from '../fhirValueSets/PlanDefinitionTypeValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { DefinitionTopicValueSet, } from '../fhirValueSets/DefinitionTopicValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Indicates what should be done and within what timeframe.
 */
export class PlanDefinitionGoalTarget extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionGoalTarget - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionGoalTarget';
        this.__detailIsChoice = true;
        if (source['measure']) {
            this.measure = new fhir.CodeableConcept(source.measure);
        }
        if (source['detail']) {
            this.detail = source.detail;
        }
        else if (source['detailQuantity']) {
            this.detail = new fhir.Quantity(source.detailQuantity);
        }
        else if (source['detailRange']) {
            this.detail = new fhir.Range(source.detailRange);
        }
        else if (source['detailCodeableConcept']) {
            this.detail = new fhir.CodeableConcept(source.detailCodeableConcept);
        }
        if (source['due']) {
            this.due = new fhir.Duration(source.due);
        }
    }
    /**
     * Example-bound Value Set for measure
     */
    static measureExampleValueSet() {
        return ObservationCodesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["measure"]) {
            outcome.issue.push(...this.measure.doModelValidation().issue);
        }
        if (this["due"]) {
            outcome.issue.push(...this.due.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Goals that describe what the activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
 */
export class PlanDefinitionGoal extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionGoal - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionGoal';
        /**
         * Identifies problems, conditions, issues, or concerns the goal is intended to address.
         */
        this.addresses = [];
        /**
         * Didactic or other informational resources associated with the goal that provide further supporting information about the goal. Information resources can include inline text commentary and links to web resources.
         */
        this.documentation = [];
        /**
         * Indicates what should be done and within what timeframe.
         */
        this.target = [];
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['description']) {
            this.description = new fhir.CodeableConcept(source.description);
        }
        else {
            this.description = null;
        }
        if (source['priority']) {
            this.priority = new fhir.CodeableConcept(source.priority);
        }
        if (source['start']) {
            this.start = new fhir.CodeableConcept(source.start);
        }
        if (source['addresses']) {
            this.addresses = source.addresses.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['documentation']) {
            this.documentation = source.documentation.map((x) => new fhir.RelatedArtifact(x));
        }
        if (source['target']) {
            this.target = source.target.map((x) => new fhir.PlanDefinitionGoalTarget(x));
        }
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return GoalCategoryValueSet;
    }
    /**
     * Example-bound Value Set for description
     */
    static descriptionExampleValueSet() {
        return ClinicalFindingsValueSet;
    }
    /**
     * Preferred-bound Value Set for priority
     */
    static priorityPreferredValueSet() {
        return GoalPriorityValueSet;
    }
    /**
     * Example-bound Value Set for start
     */
    static startExampleValueSet() {
        return GoalStartEventValueSet;
    }
    /**
     * Example-bound Value Set for addresses
     */
    static addressesExampleValueSet() {
        return ConditionCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['description']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property description:fhir.CodeableConcept fhir: PlanDefinition.goal.description:CodeableConcept", }));
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["priority"]) {
            outcome.issue.push(...this.priority.doModelValidation().issue);
        }
        if (this["start"]) {
            outcome.issue.push(...this.start.doModelValidation().issue);
        }
        if (this["addresses"]) {
            this.addresses.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["documentation"]) {
            this.documentation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["target"]) {
            this.target.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * When multiple conditions of the same kind are present, the effects are combined using AND semantics, so the overall condition is true only if all the conditions are true.
 */
export class PlanDefinitionActionCondition extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionActionCondition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionActionCondition';
        if (source['kind']) {
            this.kind = source.kind;
        }
        else {
            this.kind = null;
        }
        if (source['expression']) {
            this.expression = new fhir.Expression(source.expression);
        }
    }
    /**
     * Required-bound Value Set for kind
     */
    static kindRequiredValueSet() {
        return ActionConditionKindValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['kind']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property kind:ActionConditionKindValueSetEnum fhir: PlanDefinition.action.condition.kind:code", }));
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * When an action depends on multiple actions, the meaning is that all actions are dependencies, rather than that any of the actions are a dependency.
 */
export class PlanDefinitionActionRelatedAction extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionActionRelatedAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionActionRelatedAction';
        this.__offsetIsChoice = true;
        if (source['actionId']) {
            this.actionId = new fhir.FhirId({ value: source.actionId });
        }
        else {
            this.actionId = null;
        }
        if (source['relationship']) {
            this.relationship = source.relationship;
        }
        else {
            this.relationship = null;
        }
        if (source['offset']) {
            this.offset = source.offset;
        }
        else if (source['offsetDuration']) {
            this.offset = new fhir.Duration(source.offsetDuration);
        }
        else if (source['offsetRange']) {
            this.offset = new fhir.Range(source.offsetRange);
        }
    }
    /**
     * Required-bound Value Set for relationship
     */
    static relationshipRequiredValueSet() {
        return ActionRelationshipTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['actionId']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property actionId:fhir.FhirId fhir: PlanDefinition.action.relatedAction.actionId:id", }));
        }
        if (this["actionId"]) {
            outcome.issue.push(...this.actionId.doModelValidation().issue);
        }
        if (!this['relationship']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property relationship:ActionRelationshipTypeValueSetEnum fhir: PlanDefinition.action.relatedAction.relationship:code", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Indicates who should participate in performing the action described.
 */
export class PlanDefinitionActionParticipant extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionActionParticipant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionActionParticipant';
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['role']) {
            this.role = new fhir.CodeableConcept(source.role);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return ActionParticipantTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:ActionParticipantTypeValueSetEnum fhir: PlanDefinition.action.participant.type:code", }));
        }
        if (this["role"]) {
            outcome.issue.push(...this.role.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Dynamic values are applied in the order in which they are defined in the PlanDefinition resource. Note that when dynamic values are also specified by a referenced ActivityDefinition, the dynamicValues from the ActivityDefinition are applied first, followed by the dynamicValues specified here. In addition, if both a transform and dynamic values are specific, the dynamic values are applied to the result of the transform.
 */
export class PlanDefinitionActionDynamicValue extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionActionDynamicValue - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionActionDynamicValue';
        if (source['path']) {
            this.path = new fhir.FhirString({ value: source.path });
        }
        if (source['expression']) {
            this.expression = new fhir.Expression(source.expression);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["path"]) {
            outcome.issue.push(...this.path.doModelValidation().issue);
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Note that there is overlap between many of the elements defined here and the ActivityDefinition resource. When an ActivityDefinition is referenced (using the definition element), the overlapping elements in the plan override the content of the referenced ActivityDefinition unless otherwise documented in the specific elements. See the PlanDefinition resource for more detailed information.
 */
export class PlanDefinitionAction extends fhir.BackboneElement {
    /**
     * Default constructor for PlanDefinitionAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinitionAction';
        /**
         * A code that provides meaning for the action or action group. For example, a section may have a LOINC code for the section of a documentation template.
         */
        this.code = [];
        /**
         * This is different than the clinical evidence documentation, it's an actual business description of the reason for performing the action.
         */
        this.reason = [];
        /**
         * Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
         */
        this.documentation = [];
        /**
         * Identifies goals that this action supports. The reference must be to a goal element defined within this plan definition.
         */
        this.goalId = [];
        this.__subjectIsChoice = true;
        /**
         * A description of when the action should be triggered.
         */
        this.trigger = [];
        /**
         * When multiple conditions of the same kind are present, the effects are combined using AND semantics, so the overall condition is true only if all the conditions are true.
         */
        this.condition = [];
        /**
         * Defines input data requirements for the action.
         */
        this.input = [];
        /**
         * Defines the outputs of the action, if any.
         */
        this.output = [];
        /**
         * When an action depends on multiple actions, the meaning is that all actions are dependencies, rather than that any of the actions are a dependency.
         */
        this.relatedAction = [];
        this.__timingIsChoice = true;
        /**
         * Indicates who should participate in performing the action described.
         */
        this.participant = [];
        this.__definitionIsChoice = true;
        /**
         * Dynamic values are applied in the order in which they are defined in the PlanDefinition resource. Note that when dynamic values are also specified by a referenced ActivityDefinition, the dynamicValues from the ActivityDefinition are applied first, followed by the dynamicValues specified here. In addition, if both a transform and dynamic values are specific, the dynamic values are applied to the result of the transform.
         */
        this.dynamicValue = [];
        /**
         * Sub actions that are contained within the action. The behavior of this action determines the functionality of the sub-actions. For example, a selection behavior of at-most-one indicates that of the sub-actions, at most one may be chosen as part of realizing the action definition.
         */
        this.action = [];
        if (source['prefix']) {
            this.prefix = new fhir.FhirString({ value: source.prefix });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['textEquivalent']) {
            this.textEquivalent = new fhir.FhirString({ value: source.textEquivalent });
        }
        if (source['priority']) {
            this.priority = source.priority;
        }
        if (source['code']) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['reason']) {
            this.reason = source.reason.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['documentation']) {
            this.documentation = source.documentation.map((x) => new fhir.RelatedArtifact(x));
        }
        if (source['goalId']) {
            this.goalId = source.goalId.map((x) => new fhir.FhirId({ value: x }));
        }
        if (source['subject']) {
            this.subject = source.subject;
        }
        else if (source['subjectCodeableConcept']) {
            this.subject = new fhir.CodeableConcept(source.subjectCodeableConcept);
        }
        else if (source['subjectReference']) {
            this.subject = new fhir.Reference(source.subjectReference);
        }
        if (source['trigger']) {
            this.trigger = source.trigger.map((x) => new fhir.TriggerDefinition(x));
        }
        if (source['condition']) {
            this.condition = source.condition.map((x) => new fhir.PlanDefinitionActionCondition(x));
        }
        if (source['input']) {
            this.input = source.input.map((x) => new fhir.DataRequirement(x));
        }
        if (source['output']) {
            this.output = source.output.map((x) => new fhir.DataRequirement(x));
        }
        if (source['relatedAction']) {
            this.relatedAction = source.relatedAction.map((x) => new fhir.PlanDefinitionActionRelatedAction(x));
        }
        if (source['timing']) {
            this.timing = source.timing;
        }
        else if (source['timingDateTime']) {
            this.timing = new fhir.FhirDateTime({ value: source.timingDateTime });
        }
        else if (source['timingAge']) {
            this.timing = new fhir.Age(source.timingAge);
        }
        else if (source['timingPeriod']) {
            this.timing = new fhir.Period(source.timingPeriod);
        }
        else if (source['timingDuration']) {
            this.timing = new fhir.Duration(source.timingDuration);
        }
        else if (source['timingRange']) {
            this.timing = new fhir.Range(source.timingRange);
        }
        else if (source['timingTiming']) {
            this.timing = new fhir.Timing(source.timingTiming);
        }
        if (source['participant']) {
            this.participant = source.participant.map((x) => new fhir.PlanDefinitionActionParticipant(x));
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['groupingBehavior']) {
            this.groupingBehavior = source.groupingBehavior;
        }
        if (source['selectionBehavior']) {
            this.selectionBehavior = source.selectionBehavior;
        }
        if (source['requiredBehavior']) {
            this.requiredBehavior = source.requiredBehavior;
        }
        if (source['precheckBehavior']) {
            this.precheckBehavior = source.precheckBehavior;
        }
        if (source['cardinalityBehavior']) {
            this.cardinalityBehavior = source.cardinalityBehavior;
        }
        if (source['definition']) {
            this.definition = source.definition;
        }
        else if (source['definitionCanonical']) {
            this.definition = new fhir.FhirCanonical({ value: source.definitionCanonical });
        }
        else if (source['definitionUri']) {
            this.definition = new fhir.FhirUri({ value: source.definitionUri });
        }
        if (source['transform']) {
            this.transform = new fhir.FhirCanonical({ value: source.transform });
        }
        if (source['dynamicValue']) {
            this.dynamicValue = source.dynamicValue.map((x) => new fhir.PlanDefinitionActionDynamicValue(x));
        }
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.PlanDefinitionAction(x));
        }
    }
    /**
     * Required-bound Value Set for priority
     */
    static priorityRequiredValueSet() {
        return RequestPriorityValueSet;
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return ActionTypeValueSet;
    }
    /**
     * Required-bound Value Set for groupingBehavior
     */
    static groupingBehaviorRequiredValueSet() {
        return ActionGroupingBehaviorValueSet;
    }
    /**
     * Required-bound Value Set for selectionBehavior
     */
    static selectionBehaviorRequiredValueSet() {
        return ActionSelectionBehaviorValueSet;
    }
    /**
     * Required-bound Value Set for requiredBehavior
     */
    static requiredBehaviorRequiredValueSet() {
        return ActionRequiredBehaviorValueSet;
    }
    /**
     * Required-bound Value Set for precheckBehavior
     */
    static precheckBehaviorRequiredValueSet() {
        return ActionPrecheckBehaviorValueSet;
    }
    /**
     * Required-bound Value Set for cardinalityBehavior
     */
    static cardinalityBehaviorRequiredValueSet() {
        return ActionCardinalityBehaviorValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["prefix"]) {
            outcome.issue.push(...this.prefix.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["textEquivalent"]) {
            outcome.issue.push(...this.textEquivalent.doModelValidation().issue);
        }
        if (this["code"]) {
            this.code.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["reason"]) {
            this.reason.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["documentation"]) {
            this.documentation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["goalId"]) {
            this.goalId.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["trigger"]) {
            this.trigger.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["condition"]) {
            this.condition.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["input"]) {
            this.input.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["output"]) {
            this.output.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["relatedAction"]) {
            this.relatedAction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["participant"]) {
            this.participant.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["transform"]) {
            outcome.issue.push(...this.transform.doModelValidation().issue);
        }
        if (this["dynamicValue"]) {
            this.dynamicValue.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["action"]) {
            this.action.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
 */
export class PlanDefinition extends fhir.DomainResource {
    /**
     * Default constructor for PlanDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PlanDefinition';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this plan definition outside of FHIR, where it is not possible to use the logical URI.
         */
        this.identifier = [];
        this.__subjectIsChoice = true;
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the plan definition to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * Descriptive topics related to the content of the plan definition. Topics provide a high-level categorization of the definition that can be useful for filtering and searching.
         */
        this.topic = [];
        /**
         * An individiual or organization primarily involved in the creation and maintenance of the content.
         */
        this.author = [];
        /**
         * An individual or organization primarily responsible for internal coherence of the content.
         */
        this.editor = [];
        /**
         * An individual or organization primarily responsible for review of some aspect of the content.
         */
        this.reviewer = [];
        /**
         * An individual or organization responsible for officially endorsing the content for use in some setting.
         */
        this.endorser = [];
        /**
         * Each related artifact is either an attachment, or a reference to another resource, but not both.
         */
        this.relatedArtifact = [];
        /**
         * A reference to a Library resource containing any formal logic used by the plan definition.
         */
        this.library = [];
        /**
         * Goals that describe what the activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
         */
        this.goal = [];
        /**
         * Note that there is overlap between many of the elements defined here and the ActivityDefinition resource. When an ActivityDefinition is referenced (using the definition element), the overlapping elements in the plan override the content of the referenced ActivityDefinition unless otherwise documented in the specific elements. See the PlanDefinition resource for more detailed information.
         */
        this.action = [];
        this.resourceType = 'PlanDefinition';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['subtitle']) {
            this.subtitle = new fhir.FhirString({ value: source.subtitle });
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['subject']) {
            this.subject = source.subject;
        }
        else if (source['subjectCodeableConcept']) {
            this.subject = new fhir.CodeableConcept(source.subjectCodeableConcept);
        }
        else if (source['subjectReference']) {
            this.subject = new fhir.Reference(source.subjectReference);
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['usage']) {
            this.usage = new fhir.FhirString({ value: source.usage });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['approvalDate']) {
            this.approvalDate = new fhir.FhirDate({ value: source.approvalDate });
        }
        if (source['lastReviewDate']) {
            this.lastReviewDate = new fhir.FhirDate({ value: source.lastReviewDate });
        }
        if (source['effectivePeriod']) {
            this.effectivePeriod = new fhir.Period(source.effectivePeriod);
        }
        if (source['topic']) {
            this.topic = source.topic.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['author']) {
            this.author = source.author.map((x) => new fhir.ContactDetail(x));
        }
        if (source['editor']) {
            this.editor = source.editor.map((x) => new fhir.ContactDetail(x));
        }
        if (source['reviewer']) {
            this.reviewer = source.reviewer.map((x) => new fhir.ContactDetail(x));
        }
        if (source['endorser']) {
            this.endorser = source.endorser.map((x) => new fhir.ContactDetail(x));
        }
        if (source['relatedArtifact']) {
            this.relatedArtifact = source.relatedArtifact.map((x) => new fhir.RelatedArtifact(x));
        }
        if (source['library']) {
            this.library = source.library.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['goal']) {
            this.goal = source.goal.map((x) => new fhir.PlanDefinitionGoal(x));
        }
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.PlanDefinitionAction(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return PlanDefinitionTypeValueSet;
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Example-bound Value Set for topic
     */
    static topicExampleValueSet() {
        return DefinitionTopicValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'PlanDefinition' fhir: PlanDefinition.resourceType:'PlanDefinition'", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (this["subtitle"]) {
            outcome.issue.push(...this.subtitle.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: PlanDefinition.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["usage"]) {
            outcome.issue.push(...this.usage.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["approvalDate"]) {
            outcome.issue.push(...this.approvalDate.doModelValidation().issue);
        }
        if (this["lastReviewDate"]) {
            outcome.issue.push(...this.lastReviewDate.doModelValidation().issue);
        }
        if (this["effectivePeriod"]) {
            outcome.issue.push(...this.effectivePeriod.doModelValidation().issue);
        }
        if (this["topic"]) {
            this.topic.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["author"]) {
            this.author.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["editor"]) {
            this.editor.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["reviewer"]) {
            this.reviewer.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["endorser"]) {
            this.endorser.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["relatedArtifact"]) {
            this.relatedArtifact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["library"]) {
            this.library.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["goal"]) {
            this.goal.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["action"]) {
            this.action.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=PlanDefinition.js.map