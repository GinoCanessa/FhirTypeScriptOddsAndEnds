// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
 */
export class ValueSetComposeIncludeConceptDesignation extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeConceptDesignation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["language"]) {
            this.language = source.language;
        }
        if (source["_language"]) {
            this._language = new fhir.FhirElement(source._language);
        }
        if (source["use"]) {
            this.use = new fhir.Coding(source.use);
        }
        this.value = null;
        if (source["value"]) {
            this.value = source.value;
        }
        if (this.value === undefined) {
            this.value = null;
        }
        if (source["_value"]) {
            this._value = new fhir.FhirElement(source._value);
        }
    }
    /**
     * Check if the current ValueSetComposeIncludeConceptDesignation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["value"] === undefined) {
            missingElements.push("value");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetComposeIncludeConceptDesignation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetComposeIncludeConceptDesignation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeIncludeConceptDesignation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The list of concepts is considered ordered, though the order might not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
 */
export class ValueSetComposeIncludeConcept extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeConcept - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.code = null;
        if (source["code"]) {
            this.code = source.code;
        }
        if (this.code === undefined) {
            this.code = null;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source["designation"]) {
            this.designation = source.designation.map((x) => new fhir.ValueSetComposeIncludeConceptDesignation(x));
        }
        if (source["display"]) {
            this.display = source.display;
        }
        if (source["_display"]) {
            this._display = new fhir.FhirElement(source._display);
        }
    }
    /**
     * Check if the current ValueSetComposeIncludeConcept contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetComposeIncludeConcept from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetComposeIncludeConcept(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeIncludeConcept is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
 */
export class ValueSetComposeIncludeFilter extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeFilter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.op = null;
        if (source["op"]) {
            this.op = source.op;
        }
        if (this.op === undefined) {
            this.op = null;
        }
        if (source["_op"]) {
            this._op = new fhir.FhirElement(source._op);
        }
        this.property = null;
        if (source["property"]) {
            this.property = source.property;
        }
        if (this.property === undefined) {
            this.property = null;
        }
        if (source["_property"]) {
            this._property = new fhir.FhirElement(source._property);
        }
        this.value = null;
        if (source["value"]) {
            this.value = source.value;
        }
        if (this.value === undefined) {
            this.value = null;
        }
        if (source["_value"]) {
            this._value = new fhir.FhirElement(source._value);
        }
    }
    /**
     * Check if the current ValueSetComposeIncludeFilter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["op"] === undefined) {
            missingElements.push("op");
        }
        if (this["property"] === undefined) {
            missingElements.push("property");
        }
        if (this["value"] === undefined) {
            missingElements.push("value");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetComposeIncludeFilter from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetComposeIncludeFilter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeIncludeFilter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
 */
export class ValueSetComposeInclude extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeInclude - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["concept"]) {
            this.concept = source.concept.map((x) => new fhir.ValueSetComposeIncludeConcept(x));
        }
        if (source["filter"]) {
            this.filter = source.filter.map((x) => new fhir.ValueSetComposeIncludeFilter(x));
        }
        if (source["system"]) {
            this.system = source.system;
        }
        if (source["_system"]) {
            this._system = new fhir.FhirElement(source._system);
        }
        if (source["valueSet"]) {
            this.valueSet = source.valueSet.map((x) => (x));
        }
        if (source["_valueSet"]) {
            this._valueSet = source._valueSet.map((x) => new fhir.FhirElement(x));
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current ValueSetComposeInclude contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetComposeInclude from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetComposeInclude(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeInclude is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
 */
export class ValueSetCompose extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetCompose - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["exclude"]) {
            this.exclude = source.exclude.map((x) => new fhir.ValueSetComposeInclude(x));
        }
        if (source["inactive"]) {
            this.inactive = source.inactive;
        }
        if (source["_inactive"]) {
            this._inactive = new fhir.FhirElement(source._inactive);
        }
        this.include = null;
        if (source["include"]) {
            this.include = source.include.map((x) => new fhir.ValueSetComposeInclude(x));
        }
        if (this.include === undefined) {
            this.include = null;
        }
        if (source["lockedDate"]) {
            this.lockedDate = source.lockedDate;
        }
        if (source["_lockedDate"]) {
            this._lockedDate = new fhir.FhirElement(source._lockedDate);
        }
    }
    /**
     * Check if the current ValueSetCompose contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if ((!this["include"]) || (this["include"].length === 0)) {
            missingElements.push("include");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetCompose from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetCompose(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetCompose is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The server decides which parameters to include here, but at a minimum, the list SHOULD include all of the parameters that affect the $expand operation. If the expansion will be persisted all of these parameters SHALL be included. If the codeSystem on the server has a specified version then this version SHALL be provided as a parameter in the expansion (note that not all code systems have a version).
 */
export class ValueSetExpansionParameter extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetExpansionParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["valueString"]) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"]) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source["valueBoolean"]) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"]) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source["valueInteger"]) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"]) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source["valueDecimal"]) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"]) {
            this._valueDecimal = new fhir.FhirElement(source._valueDecimal);
        }
        if (source["valueUri"]) {
            this.valueUri = source.valueUri;
        }
        if (source["_valueUri"]) {
            this._valueUri = new fhir.FhirElement(source._valueUri);
        }
        if (source["valueCode"]) {
            this.valueCode = source.valueCode;
        }
        if (source["_valueCode"]) {
            this._valueCode = new fhir.FhirElement(source._valueCode);
        }
        if (source["valueDateTime"]) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source["_valueDateTime"]) {
            this._valueDateTime = new fhir.FhirElement(source._valueDateTime);
        }
    }
    /**
     * Check if the current ValueSetExpansionParameter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetExpansionParameter from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetExpansionParameter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetExpansionParameter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The codes that are contained in the value set expansion.
 */
export class ValueSetExpansionContains extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetExpansionContains - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["abstract"]) {
            this.abstract = source.abstract;
        }
        if (source["_abstract"]) {
            this._abstract = new fhir.FhirElement(source._abstract);
        }
        if (source["code"]) {
            this.code = source.code;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source["contains"]) {
            this.contains = source.contains.map((x) => new fhir.ValueSetExpansionContains(x));
        }
        if (source["designation"]) {
            this.designation = source.designation.map((x) => new fhir.ValueSetComposeIncludeConceptDesignation(x));
        }
        if (source["display"]) {
            this.display = source.display;
        }
        if (source["_display"]) {
            this._display = new fhir.FhirElement(source._display);
        }
        if (source["inactive"]) {
            this.inactive = source.inactive;
        }
        if (source["_inactive"]) {
            this._inactive = new fhir.FhirElement(source._inactive);
        }
        if (source["system"]) {
            this.system = source.system;
        }
        if (source["_system"]) {
            this._system = new fhir.FhirElement(source._system);
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current ValueSetExpansionContains contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetExpansionContains from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetExpansionContains(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetExpansionContains is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Expansion is performed to produce a collection of codes that are ready to use for data entry or validation. Value set expansions are always considered to be stateless - they are a record of the set of codes in the value set at a point in time under a given set of conditions, and are not subject to ongoing maintenance.
 * Expansion.parameter is  a simplified list of parameters - a subset of the features of the [Parameters](parameters.html) resource.
 */
export class ValueSetExpansion extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetExpansion - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["contains"]) {
            this.contains = source.contains.map((x) => new fhir.ValueSetExpansionContains(x));
        }
        if (source["identifier"]) {
            this.identifier = source.identifier;
        }
        if (source["_identifier"]) {
            this._identifier = new fhir.FhirElement(source._identifier);
        }
        if (source["offset"]) {
            this.offset = source.offset;
        }
        if (source["_offset"]) {
            this._offset = new fhir.FhirElement(source._offset);
        }
        if (source["parameter"]) {
            this.parameter = source.parameter.map((x) => new fhir.ValueSetExpansionParameter(x));
        }
        this.timestamp = null;
        if (source["timestamp"]) {
            this.timestamp = source.timestamp;
        }
        if (this.timestamp === undefined) {
            this.timestamp = null;
        }
        if (source["_timestamp"]) {
            this._timestamp = new fhir.FhirElement(source._timestamp);
        }
        if (source["total"]) {
            this.total = source.total;
        }
        if (source["_total"]) {
            this._total = new fhir.FhirElement(source._total);
        }
    }
    /**
     * Check if the current ValueSetExpansion contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["timestamp"] === undefined) {
            missingElements.push("timestamp");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSetExpansion from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSetExpansion(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetExpansion is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
 */
export class ValueSet extends fhir.DomainResource {
    /**
     * Default constructor for ValueSet - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'ValueSet';
        if (source["compose"]) {
            this.compose = new fhir.ValueSetCompose(source.compose);
        }
        if (source["contact"]) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source["copyright"]) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"]) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source["date"]) {
            this.date = source.date;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["expansion"]) {
            this.expansion = new fhir.ValueSetExpansion(source.expansion);
        }
        if (source["experimental"]) {
            this.experimental = source.experimental;
        }
        if (source["_experimental"]) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["immutable"]) {
            this.immutable = source.immutable;
        }
        if (source["_immutable"]) {
            this._immutable = new fhir.FhirElement(source._immutable);
        }
        if (source["jurisdiction"]) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["name"]) {
            this.name = source.name;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["publisher"]) {
            this.publisher = source.publisher;
        }
        if (source["_publisher"]) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source["purpose"]) {
            this.purpose = source.purpose;
        }
        if (source["_purpose"]) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["useContext"]) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current ValueSet contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ValueSet from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ValueSet(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSet is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the ValueSet.compose.include.filter.op field
 */
export var ValueSetComposeIncludeFilterOpEnum;
(function (ValueSetComposeIncludeFilterOpEnum) {
    ValueSetComposeIncludeFilterOpEnum["EQUALS"] = "=";
    ValueSetComposeIncludeFilterOpEnum["IS_A"] = "is-a";
    ValueSetComposeIncludeFilterOpEnum["DESCENDENT_OF"] = "descendent-of";
    ValueSetComposeIncludeFilterOpEnum["IS_NOT_A"] = "is-not-a";
    ValueSetComposeIncludeFilterOpEnum["REGEX"] = "regex";
    ValueSetComposeIncludeFilterOpEnum["IN"] = "in";
    ValueSetComposeIncludeFilterOpEnum["NOT_IN"] = "not-in";
    ValueSetComposeIncludeFilterOpEnum["GENERALIZES"] = "generalizes";
    ValueSetComposeIncludeFilterOpEnum["EXISTS"] = "exists";
})(ValueSetComposeIncludeFilterOpEnum || (ValueSetComposeIncludeFilterOpEnum = {}));
/**
 * Code Values for the ValueSet.status field
 */
export var ValueSetStatusEnum;
(function (ValueSetStatusEnum) {
    ValueSetStatusEnum["DRAFT"] = "draft";
    ValueSetStatusEnum["ACTIVE"] = "active";
    ValueSetStatusEnum["RETIRED"] = "retired";
    ValueSetStatusEnum["UNKNOWN"] = "unknown";
})(ValueSetStatusEnum || (ValueSetStatusEnum = {}));
//# sourceMappingURL=ValueSet.js.map