// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ValueSet
import * as fhir from '../fhir.js';
import { LanguagesValueSet, } from '../fhirValueSets/LanguagesValueSet.js';
import { DesignationUseValueSet, } from '../fhirValueSets/DesignationUseValueSet.js';
import { FilterOperatorValueSet, } from '../fhirValueSets/FilterOperatorValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
 */
export class ValueSetComposeIncludeConceptDesignation extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeConceptDesignation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetComposeIncludeConceptDesignation';
        if (source['language']) {
            this.language = new fhir.FhirCode({ value: source.language });
        }
        if (source['use']) {
            this.use = new fhir.Coding(source.use);
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Preferred-bound Value Set for language
     */
    static languagePreferredValueSet() {
        return LanguagesValueSet;
    }
    /**
     * Extensible-bound Value Set for use
     */
    static useExtensibleValueSet() {
        return DesignationUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["language"]) {
            outcome.issue.push(...this.language.doModelValidation().issue);
        }
        if (this["use"]) {
            outcome.issue.push(...this.use.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value:fhir.FhirString fhir: ValueSet.compose.include.concept.designation.value:string", }));
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The list of concepts is considered ordered, though the order might not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
 */
export class ValueSetComposeIncludeConcept extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeConcept - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetComposeIncludeConcept';
        /**
         * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
         */
        this.designation = [];
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
        if (source['designation']) {
            this.designation = source.designation.map((x) => new fhir.ValueSetComposeIncludeConceptDesignation(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: ValueSet.compose.include.concept.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        if (this["designation"]) {
            this.designation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
 */
export class ValueSetComposeIncludeFilter extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeFilter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetComposeIncludeFilter';
        if (source['property']) {
            this.property = new fhir.FhirCode({ value: source.property });
        }
        else {
            this.property = null;
        }
        if (source['op']) {
            this.op = source.op;
        }
        else {
            this.op = null;
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Required-bound Value Set for op
     */
    static opRequiredValueSet() {
        return FilterOperatorValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['property']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property property:fhir.FhirCode fhir: ValueSet.compose.include.filter.property:code", }));
        }
        if (this["property"]) {
            outcome.issue.push(...this.property.doModelValidation().issue);
        }
        if (!this['op']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property op:FilterOperatorValueSetEnum fhir: ValueSet.compose.include.filter.op:code", }));
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value:fhir.FhirString fhir: ValueSet.compose.include.filter.value:string", }));
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
 */
export class ValueSetComposeInclude extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetComposeInclude - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetComposeInclude';
        /**
         * The list of concepts is considered ordered, though the order might not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
         */
        this.concept = [];
        /**
         * Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
         */
        this.filter = [];
        /**
         * The value set URI is either a logical reference to a defined value set such as a [SNOMED CT reference set](snomedct.html#implicit), or a direct reference to a value set definition using ValueSet.url. The reference might not refer to an actual FHIR ValueSet resource; in this case, whatever is referred to is an implicit definition of a value set that needs to be clear about how versions are resolved.
         */
        this.valueSet = [];
        if (source['system']) {
            this.system = new fhir.FhirUri({ value: source.system });
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['concept']) {
            this.concept = source.concept.map((x) => new fhir.ValueSetComposeIncludeConcept(x));
        }
        if (source['filter']) {
            this.filter = source.filter.map((x) => new fhir.ValueSetComposeIncludeFilter(x));
        }
        if (source['valueSet']) {
            this.valueSet = source.valueSet.map((x) => new fhir.FhirCanonical({ value: x }));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["system"]) {
            outcome.issue.push(...this.system.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["concept"]) {
            this.concept.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["filter"]) {
            this.filter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["valueSet"]) {
            this.valueSet.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
 */
export class ValueSetCompose extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetCompose - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetCompose';
        /**
         * All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
         */
        this.include = [];
        /**
         * Usually this is used to selectively exclude codes that were included by subsumption in the inclusions. Any display names specified for the codes are ignored.
         */
        this.exclude = [];
        if (source['lockedDate']) {
            this.lockedDate = new fhir.FhirDate({ value: source.lockedDate });
        }
        if (source['inactive']) {
            this.inactive = new fhir.FhirBoolean({ value: source.inactive });
        }
        if (source['include']) {
            this.include = source.include.map((x) => new fhir.ValueSetComposeInclude(x));
        }
        else {
            this.include = null;
        }
        if (source['exclude']) {
            this.exclude = source.exclude.map((x) => new fhir.ValueSetComposeInclude(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["lockedDate"]) {
            outcome.issue.push(...this.lockedDate.doModelValidation().issue);
        }
        if (this["inactive"]) {
            outcome.issue.push(...this.inactive.doModelValidation().issue);
        }
        if (!this['include']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property include:fhir.ValueSetComposeInclude[] fhir: ValueSet.compose.include:include", }));
        }
        else if (!Array.isArray(this.include)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property include:fhir.ValueSetComposeInclude[] fhir: ValueSet.compose.include:include", }));
        }
        else if (this.include.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property include:fhir.ValueSetComposeInclude[] fhir: ValueSet.compose.include:include", }));
        }
        if (this["include"]) {
            this.include.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["exclude"]) {
            this.exclude.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The server decides which parameters to include here, but at a minimum, the list SHOULD include all of the parameters that affect the $expand operation. If the expansion will be persisted all of these parameters SHALL be included. If the codeSystem on the server has a specified version then this version SHALL be provided as a parameter in the expansion (note that not all code systems have a version).
 */
export class ValueSetExpansionParameter extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetExpansionParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetExpansionParameter';
        this.__valueIsChoice = true;
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueInteger']) {
            this.value = new fhir.FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueDecimal']) {
            this.value = new fhir.FhirDecimal({ value: source.valueDecimal });
        }
        else if (source['valueUri']) {
            this.value = new fhir.FhirUri({ value: source.valueUri });
        }
        else if (source['valueCode']) {
            this.value = new fhir.FhirCode({ value: source.valueCode });
        }
        else if (source['valueDateTime']) {
            this.value = new fhir.FhirDateTime({ value: source.valueDateTime });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: ValueSet.expansion.parameter.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The codes that are contained in the value set expansion.
 */
export class ValueSetExpansionContains extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetExpansionContains - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetExpansionContains';
        /**
         * The designations provided must be based on the value set and code system definitions.
         */
        this.designation = [];
        /**
         * If the expansion uses this element, there is  no implication about the logical relationship between them, and the  structure cannot be used for logical inferencing. The structure  exists to provide navigational assistance for helping human users to  locate codes in the expansion.
         */
        this.contains = [];
        if (source['system']) {
            this.system = new fhir.FhirUri({ value: source.system });
        }
        if (source['abstract']) {
            this.abstract = new fhir.FhirBoolean({ value: source.abstract });
        }
        if (source['inactive']) {
            this.inactive = new fhir.FhirBoolean({ value: source.inactive });
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
        if (source['designation']) {
            this.designation = source.designation.map((x) => new fhir.ValueSetComposeIncludeConceptDesignation(x));
        }
        if (source['contains']) {
            this.contains = source.contains.map((x) => new fhir.ValueSetExpansionContains(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["system"]) {
            outcome.issue.push(...this.system.doModelValidation().issue);
        }
        if (this["abstract"]) {
            outcome.issue.push(...this.abstract.doModelValidation().issue);
        }
        if (this["inactive"]) {
            outcome.issue.push(...this.inactive.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        if (this["designation"]) {
            this.designation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["contains"]) {
            this.contains.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Expansion is performed to produce a collection of codes that are ready to use for data entry or validation. Value set expansions are always considered to be stateless - they are a record of the set of codes in the value set at a point in time under a given set of conditions, and are not subject to ongoing maintenance.
 * Expansion.parameter is  a simplified list of parameters - a subset of the features of the [Parameters](parameters.html) resource.
 */
export class ValueSetExpansion extends fhir.BackboneElement {
    /**
     * Default constructor for ValueSetExpansion - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSetExpansion';
        /**
         * The server decides which parameters to include here, but at a minimum, the list SHOULD include all of the parameters that affect the $expand operation. If the expansion will be persisted all of these parameters SHALL be included. If the codeSystem on the server has a specified version then this version SHALL be provided as a parameter in the expansion (note that not all code systems have a version).
         */
        this.parameter = [];
        /**
         * The codes that are contained in the value set expansion.
         */
        this.contains = [];
        if (source['identifier']) {
            this.identifier = new fhir.FhirUri({ value: source.identifier });
        }
        if (source['timestamp']) {
            this.timestamp = new fhir.FhirDateTime({ value: source.timestamp });
        }
        else {
            this.timestamp = null;
        }
        if (source['total']) {
            this.total = new fhir.FhirInteger({ value: source.total });
        }
        if (source['offset']) {
            this.offset = new fhir.FhirInteger({ value: source.offset });
        }
        if (source['parameter']) {
            this.parameter = source.parameter.map((x) => new fhir.ValueSetExpansionParameter(x));
        }
        if (source['contains']) {
            this.contains = source.contains.map((x) => new fhir.ValueSetExpansionContains(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (!this['timestamp']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property timestamp:fhir.FhirDateTime fhir: ValueSet.expansion.timestamp:dateTime", }));
        }
        if (this["timestamp"]) {
            outcome.issue.push(...this.timestamp.doModelValidation().issue);
        }
        if (this["total"]) {
            outcome.issue.push(...this.total.doModelValidation().issue);
        }
        if (this["offset"]) {
            outcome.issue.push(...this.offset.doModelValidation().issue);
        }
        if (this["parameter"]) {
            this.parameter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["contains"]) {
            this.contains.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
 */
export class ValueSet extends fhir.DomainResource {
    /**
     * Default constructor for ValueSet - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ValueSet';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this value set outside of FHIR, where it is not possible to use the logical URI.
         */
        this.identifier = [];
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the value set to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        this.resourceType = 'ValueSet';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['immutable']) {
            this.immutable = new fhir.FhirBoolean({ value: source.immutable });
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['compose']) {
            this.compose = new fhir.ValueSetCompose(source.compose);
        }
        if (source['expansion']) {
            this.expansion = new fhir.ValueSetExpansion(source.expansion);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'ValueSet' fhir: ValueSet.resourceType:'ValueSet'", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: ValueSet.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["immutable"]) {
            outcome.issue.push(...this.immutable.doModelValidation().issue);
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["compose"]) {
            outcome.issue.push(...this.compose.doModelValidation().issue);
        }
        if (this["expansion"]) {
            outcome.issue.push(...this.expansion.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=ValueSet.js.map