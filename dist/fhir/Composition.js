// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Only list each attester once.
 */
export class CompositionAttester extends fhir.BackboneElement {
    /**
     * Default constructor for CompositionAttester - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.mode = null;
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (this.mode === undefined) {
            this.mode = null;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source["party"]) {
            this.party = new fhir.Reference(source.party);
        }
        if (source["time"]) {
            this.time = source.time;
        }
        if (source["_time"]) {
            this._time = new fhir.FhirElement(source._time);
        }
    }
    /**
     * Check if the current CompositionAttester contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["mode"] === undefined) {
            missingElements.push("mode");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CompositionAttester from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CompositionAttester(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CompositionAttester is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A document is a version specific composition.
 */
export class CompositionRelatesTo extends fhir.BackboneElement {
    /**
     * Default constructor for CompositionRelatesTo - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.code = null;
        if (source["code"]) {
            this.code = source.code;
        }
        if (this.code === undefined) {
            this.code = null;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source["targetIdentifier"]) {
            this.targetIdentifier = new fhir.Identifier(source.targetIdentifier);
        }
        if (source["targetReference"]) {
            this.targetReference = new fhir.Reference(source.targetReference);
        }
    }
    /**
     * Check if the current CompositionRelatesTo contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CompositionRelatesTo from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CompositionRelatesTo(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CompositionRelatesTo is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The event needs to be consistent with the type element, though can provide further information if desired.
 */
export class CompositionEvent extends fhir.BackboneElement {
    /**
     * Default constructor for CompositionEvent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["detail"]) {
            this.detail = source.detail.map((x) => new fhir.Reference(x));
        }
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
    }
    /**
     * Check if the current CompositionEvent contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CompositionEvent from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CompositionEvent(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CompositionEvent is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The root of the sections that make up the composition.
 */
export class CompositionSection extends fhir.BackboneElement {
    /**
     * Default constructor for CompositionSection - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["author"]) {
            this.author = source.author.map((x) => new fhir.Reference(x));
        }
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source["emptyReason"]) {
            this.emptyReason = new fhir.CodeableConcept(source.emptyReason);
        }
        if (source["entry"]) {
            this.entry = source.entry.map((x) => new fhir.Reference(x));
        }
        if (source["focus"]) {
            this.focus = new fhir.Reference(source.focus);
        }
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source["orderedBy"]) {
            this.orderedBy = new fhir.CodeableConcept(source.orderedBy);
        }
        if (source["section"]) {
            this.section = source.section.map((x) => new fhir.CompositionSection(x));
        }
        if (source["text"]) {
            this.text = new fhir.Narrative(source.text);
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
    }
    /**
     * Check if the current CompositionSection contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CompositionSection from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CompositionSection(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CompositionSection is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.).
 */
export class Composition extends fhir.DomainResource {
    /**
     * Default constructor for Composition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Composition';
        if (source["attester"]) {
            this.attester = source.attester.map((x) => new fhir.CompositionAttester(x));
        }
        this.author = null;
        if (source["author"]) {
            this.author = source.author.map((x) => new fhir.Reference(x));
        }
        if (this.author === undefined) {
            this.author = null;
        }
        if (source["category"]) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["confidentiality"]) {
            this.confidentiality = source.confidentiality;
        }
        if (source["_confidentiality"]) {
            this._confidentiality = new fhir.FhirElement(source._confidentiality);
        }
        if (source["custodian"]) {
            this.custodian = new fhir.Reference(source.custodian);
        }
        this.date = null;
        if (source["date"]) {
            this.date = source.date;
        }
        if (this.date === undefined) {
            this.date = null;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["encounter"]) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source["event"]) {
            this.event = source.event.map((x) => new fhir.CompositionEvent(x));
        }
        if (source["identifier"]) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source["relatesTo"]) {
            this.relatesTo = source.relatesTo.map((x) => new fhir.CompositionRelatesTo(x));
        }
        if (source["section"]) {
            this.section = source.section.map((x) => new fhir.CompositionSection(x));
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["subject"]) {
            this.subject = new fhir.Reference(source.subject);
        }
        this.title = null;
        if (source["title"]) {
            this.title = source.title;
        }
        if (this.title === undefined) {
            this.title = null;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        this.type = null;
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (this.type === undefined) {
            this.type = null;
        }
    }
    /**
     * Check if the current Composition contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if ((!this["author"]) || (this["author"].length === 0)) {
            missingElements.push("author");
        }
        if (this["date"] === undefined) {
            missingElements.push("date");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        if (this["title"] === undefined) {
            missingElements.push("title");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Composition from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new Composition(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `Composition is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the Composition.attester.mode field
 */
export var CompositionAttesterModeEnum;
(function (CompositionAttesterModeEnum) {
    CompositionAttesterModeEnum["PERSONAL"] = "personal";
    CompositionAttesterModeEnum["PROFESSIONAL"] = "professional";
    CompositionAttesterModeEnum["LEGAL"] = "legal";
    CompositionAttesterModeEnum["OFFICIAL"] = "official";
})(CompositionAttesterModeEnum || (CompositionAttesterModeEnum = {}));
/**
 * Code Values for the Composition.relatesTo.code field
 */
export var CompositionRelatesToCodeEnum;
(function (CompositionRelatesToCodeEnum) {
    CompositionRelatesToCodeEnum["REPLACES"] = "replaces";
    CompositionRelatesToCodeEnum["TRANSFORMS"] = "transforms";
    CompositionRelatesToCodeEnum["SIGNS"] = "signs";
    CompositionRelatesToCodeEnum["APPENDS"] = "appends";
})(CompositionRelatesToCodeEnum || (CompositionRelatesToCodeEnum = {}));
/**
 * Code Values for the Composition.section.mode field
 */
export var CompositionSectionModeEnum;
(function (CompositionSectionModeEnum) {
    CompositionSectionModeEnum["WORKING"] = "working";
    CompositionSectionModeEnum["SNAPSHOT"] = "snapshot";
    CompositionSectionModeEnum["CHANGES"] = "changes";
})(CompositionSectionModeEnum || (CompositionSectionModeEnum = {}));
/**
 * Code Values for the Composition.status field
 */
export var CompositionStatusEnum;
(function (CompositionStatusEnum) {
    CompositionStatusEnum["PRELIMINARY"] = "preliminary";
    CompositionStatusEnum["FINAL"] = "final";
    CompositionStatusEnum["AMENDED"] = "amended";
    CompositionStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
})(CompositionStatusEnum || (CompositionStatusEnum = {}));
//# sourceMappingURL=Composition.js.map