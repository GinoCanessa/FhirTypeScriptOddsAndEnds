// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: StructureDefinition
import * as fhir from '../fhir.js';
import { ExtensionContextTypeValueSet, } from '../fhirValueSets/ExtensionContextTypeValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { DefinitionUseValueSet, } from '../fhirValueSets/DefinitionUseValueSet.js';
import { FHIRVersionValueSet, } from '../fhirValueSets/FHIRVersionValueSet.js';
import { StructureDefinitionKindValueSet, } from '../fhirValueSets/StructureDefinitionKindValueSet.js';
import { DefinedTypesValueSet, } from '../fhirValueSets/DefinedTypesValueSet.js';
import { TypeDerivationRuleValueSet, } from '../fhirValueSets/TypeDerivationRuleValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * An external specification that the content is mapped to.
 */
export class StructureDefinitionMapping extends fhir.BackboneElement {
    /**
     * Default constructor for StructureDefinitionMapping - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureDefinitionMapping';
        if (source['identity']) {
            this.identity = new fhir.FhirId({ value: source.identity });
        }
        else {
            this.identity = null;
        }
        if (source['uri']) {
            this.uri = new fhir.FhirUri({ value: source.uri });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['comment']) {
            this.comment = new fhir.FhirString({ value: source.comment });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['identity']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property identity:fhir.FhirId fhir: StructureDefinition.mapping.identity:id", }));
        }
        if (this["identity"]) {
            outcome.issue.push(...this.identity.doModelValidation().issue);
        }
        if (this["uri"]) {
            outcome.issue.push(...this.uri.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["comment"]) {
            outcome.issue.push(...this.comment.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Identifies the types of resource or data type elements to which the extension can be applied.
 */
export class StructureDefinitionContext extends fhir.BackboneElement {
    /**
     * Default constructor for StructureDefinitionContext - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureDefinitionContext';
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['expression']) {
            this.expression = new fhir.FhirString({ value: source.expression });
        }
        else {
            this.expression = null;
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return ExtensionContextTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:ExtensionContextTypeValueSetEnum fhir: StructureDefinition.context.type:code", }));
        }
        if (!this['expression']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property expression:fhir.FhirString fhir: StructureDefinition.context.expression:string", }));
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition.
 */
export class StructureDefinitionSnapshot extends fhir.BackboneElement {
    /**
     * Default constructor for StructureDefinitionSnapshot - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureDefinitionSnapshot';
        /**
         * Captures constraints on each element within the resource.
         */
        this.element = [];
        if (source['element']) {
            this.element = source.element.map((x) => new fhir.ElementDefinition(x));
        }
        else {
            this.element = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['element']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property element:fhir.ElementDefinition[] fhir: StructureDefinition.snapshot.element:ElementDefinition", }));
        }
        else if (!Array.isArray(this.element)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property element:fhir.ElementDefinition[] fhir: StructureDefinition.snapshot.element:ElementDefinition", }));
        }
        else if (this.element.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property element:fhir.ElementDefinition[] fhir: StructureDefinition.snapshot.element:ElementDefinition", }));
        }
        if (this["element"]) {
            this.element.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
 */
export class StructureDefinitionDifferential extends fhir.BackboneElement {
    /**
     * Default constructor for StructureDefinitionDifferential - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureDefinitionDifferential';
        /**
         * Captures constraints on each element within the resource.
         */
        this.element = [];
        if (source['element']) {
            this.element = source.element.map((x) => new fhir.ElementDefinition(x));
        }
        else {
            this.element = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['element']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property element:fhir.ElementDefinition[] fhir: StructureDefinition.differential.element:ElementDefinition", }));
        }
        else if (!Array.isArray(this.element)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property element:fhir.ElementDefinition[] fhir: StructureDefinition.differential.element:ElementDefinition", }));
        }
        else if (this.element.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property element:fhir.ElementDefinition[] fhir: StructureDefinition.differential.element:ElementDefinition", }));
        }
        if (this["element"]) {
            this.element.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
 */
export class StructureDefinition extends fhir.DomainResource {
    /**
     * Default constructor for StructureDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureDefinition';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this structure definition outside of FHIR, where it is not possible to use the logical URI.
         */
        this.identifier = [];
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the structure definition to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * A set of key words or terms from external terminologies that may be used to assist with indexing and searching of templates nby describing the use of this structure definition, or the content it describes.
         */
        this.keyword = [];
        /**
         * An external specification that the content is mapped to.
         */
        this.mapping = [];
        /**
         * Identifies the types of resource or data type elements to which the extension can be applied.
         */
        this.context = [];
        /**
         * The rules are only evaluated when the extension is present. When evaluating the invariant, the FHIRPath focus is the element that holds the extension, and %extension refers to the extension itself.
         */
        this.contextInvariant = [];
        this.resourceType = 'StructureDefinition';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['keyword']) {
            this.keyword = source.keyword.map((x) => new fhir.Coding(x));
        }
        if (source['fhirVersion']) {
            this.fhirVersion = new fhir.FhirCode({ value: source.fhirVersion });
        }
        if (source['mapping']) {
            this.mapping = source.mapping.map((x) => new fhir.StructureDefinitionMapping(x));
        }
        if (source['kind']) {
            this.kind = source.kind;
        }
        else {
            this.kind = null;
        }
        if (source['abstract']) {
            this.abstract = new fhir.FhirBoolean({ value: source.abstract });
        }
        else {
            this.abstract = null;
        }
        if (source['context']) {
            this.context = source.context.map((x) => new fhir.StructureDefinitionContext(x));
        }
        if (source['contextInvariant']) {
            this.contextInvariant = source.contextInvariant.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['type']) {
            this.type = new fhir.FhirUri({ value: source.type });
        }
        else {
            this.type = null;
        }
        if (source['baseDefinition']) {
            this.baseDefinition = new fhir.FhirCanonical({ value: source.baseDefinition });
        }
        if (source['derivation']) {
            this.derivation = source.derivation;
        }
        if (source['snapshot']) {
            this.snapshot = new fhir.StructureDefinitionSnapshot(source.snapshot);
        }
        if (source['differential']) {
            this.differential = new fhir.StructureDefinitionDifferential(source.differential);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Extensible-bound Value Set for keyword
     */
    static keywordExtensibleValueSet() {
        return DefinitionUseValueSet;
    }
    /**
     * Required-bound Value Set for fhirVersion
     */
    static fhirVersionRequiredValueSet() {
        return FHIRVersionValueSet;
    }
    /**
     * Required-bound Value Set for kind
     */
    static kindRequiredValueSet() {
        return StructureDefinitionKindValueSet;
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return DefinedTypesValueSet;
    }
    /**
     * Required-bound Value Set for derivation
     */
    static derivationRequiredValueSet() {
        return TypeDerivationRuleValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'StructureDefinition' fhir: StructureDefinition.resourceType:'StructureDefinition'", }));
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: StructureDefinition.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: StructureDefinition.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: StructureDefinition.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["keyword"]) {
            this.keyword.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["fhirVersion"]) {
            outcome.issue.push(...this.fhirVersion.doModelValidation().issue);
        }
        if (this["mapping"]) {
            this.mapping.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['kind']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property kind:StructureDefinitionKindValueSetEnum fhir: StructureDefinition.kind:code", }));
        }
        if (!this['abstract']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property abstract:fhir.FhirBoolean fhir: StructureDefinition.abstract:boolean", }));
        }
        if (this["abstract"]) {
            outcome.issue.push(...this.abstract.doModelValidation().issue);
        }
        if (this["context"]) {
            this.context.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["contextInvariant"]) {
            this.contextInvariant.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.FhirUri fhir: StructureDefinition.type:uri", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["baseDefinition"]) {
            outcome.issue.push(...this.baseDefinition.doModelValidation().issue);
        }
        if (this["snapshot"]) {
            outcome.issue.push(...this.snapshot.doModelValidation().issue);
        }
        if (this["differential"]) {
            outcome.issue.push(...this.differential.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=StructureDefinition.js.map