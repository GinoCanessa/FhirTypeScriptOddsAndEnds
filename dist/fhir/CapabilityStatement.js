// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: CapabilityStatement
import * as fhir from '../fhir.js';
import { RestfulSecurityServiceValueSet, } from '../fhirValueSets/RestfulSecurityServiceValueSet.js';
import { TypeRestfulInteractionValueSet, } from '../fhirValueSets/TypeRestfulInteractionValueSet.js';
import { SearchParamTypeValueSet, } from '../fhirValueSets/SearchParamTypeValueSet.js';
import { ResourceTypesValueSet, } from '../fhirValueSets/ResourceTypesValueSet.js';
import { VersioningPolicyValueSet, } from '../fhirValueSets/VersioningPolicyValueSet.js';
import { ConditionalReadStatusValueSet, } from '../fhirValueSets/ConditionalReadStatusValueSet.js';
import { ConditionalDeleteStatusValueSet, } from '../fhirValueSets/ConditionalDeleteStatusValueSet.js';
import { ReferenceHandlingPolicyValueSet, } from '../fhirValueSets/ReferenceHandlingPolicyValueSet.js';
import { SystemRestfulInteractionValueSet, } from '../fhirValueSets/SystemRestfulInteractionValueSet.js';
import { RestfulCapabilityModeValueSet, } from '../fhirValueSets/RestfulCapabilityModeValueSet.js';
import { MessageTransportValueSet, } from '../fhirValueSets/MessageTransportValueSet.js';
import { EventCapabilityModeValueSet, } from '../fhirValueSets/EventCapabilityModeValueSet.js';
import { DocumentModeValueSet, } from '../fhirValueSets/DocumentModeValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { CapabilityStatementKindValueSet, } from '../fhirValueSets/CapabilityStatementKindValueSet.js';
import { FHIRVersionValueSet, } from '../fhirValueSets/FHIRVersionValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
 */
export class CapabilityStatementSoftware extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementSoftware - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementSoftware';
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['releaseDate']) {
            this.releaseDate = new fhir.FhirDateTime({ value: source.releaseDate });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: CapabilityStatement.software.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["releaseDate"]) {
            outcome.issue.push(...this.releaseDate.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
export class CapabilityStatementImplementation extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementImplementation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementImplementation';
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        else {
            this.description = null;
        }
        if (source['url']) {
            this.url = new fhir.FhirUrl({ value: source.url });
        }
        if (source['custodian']) {
            this.custodian = new fhir.Reference(source.custodian);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['description']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property description:fhir.FhirString fhir: CapabilityStatement.implementation.description:string", }));
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["custodian"]) {
            outcome.issue.push(...this.custodian.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Information about security implementation from an interface perspective - what a client needs to know.
 */
export class CapabilityStatementRestSecurity extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestSecurity - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRestSecurity';
        /**
         * Types of security services that are supported/required by the system.
         */
        this.service = [];
        if (source['cors']) {
            this.cors = new fhir.FhirBoolean({ value: source.cors });
        }
        if (source['service']) {
            this.service = source.service.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
    }
    /**
     * Extensible-bound Value Set for service
     */
    static serviceExtensibleValueSet() {
        return RestfulSecurityServiceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["cors"]) {
            outcome.issue.push(...this.cors.doModelValidation().issue);
        }
        if (this["service"]) {
            this.service.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * In general, a Resource will only appear in a CapabilityStatement if the server actually has some capabilities - e.g. there is at least one interaction supported. However interactions can be omitted to support summarization (_summary = true).
 */
export class CapabilityStatementRestResourceInteraction extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceInteraction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRestResourceInteraction';
        if (source['code']) {
            this.code = source.code;
        }
        else {
            this.code = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
    }
    /**
     * Required-bound Value Set for code
     */
    static codeRequiredValueSet() {
        return TypeRestfulInteractionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:TypeRestfulInteractionValueSetEnum fhir: CapabilityStatement.rest.resource.interaction.code:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The search parameters should include the control search parameters such as _sort, _count, etc. that also apply to this resource (though many will be listed at [CapabilityStatement.rest.searchParam](capabilitystatement-definitions.html#CapabilityStatement.rest.searchParam)). The behavior of some search parameters may be further described by other code or extension elements, or narrative within the capability statement or linked [SearchParameter](searchparameter.html#) definitions.
 */
export class CapabilityStatementRestResourceSearchParam extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceSearchParam - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRestResourceSearchParam';
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['definition']) {
            this.definition = new fhir.FhirCanonical({ value: source.definition });
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return SearchParamTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: CapabilityStatement.rest.resource.searchParam.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["definition"]) {
            outcome.issue.push(...this.definition.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:SearchParamTypeValueSetEnum fhir: CapabilityStatement.rest.resource.searchParam.type:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Operations linked from CapabilityStatement.rest.resource.operation must have OperationDefinition.type = true or OperationDefinition.instance = true.
 * If an operation that is listed in multiple CapabilityStatement.rest.resource.operation (e.g. for different resource types), then clients should understand that the operation is only supported on the specified resource types, and that may be a subset of those listed in OperationDefinition.resource.
 */
export class CapabilityStatementRestResourceOperation extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRestResourceOperation';
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['definition']) {
            this.definition = new fhir.FhirCanonical({ value: source.definition });
        }
        else {
            this.definition = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: CapabilityStatement.rest.resource.operation.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['definition']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property definition:fhir.FhirCanonical fhir: CapabilityStatement.rest.resource.operation.definition:canonical", }));
        }
        if (this["definition"]) {
            outcome.issue.push(...this.definition.doModelValidation().issue);
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Max of one repetition per resource type.
 */
export class CapabilityStatementRestResource extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRestResource';
        /**
         * Supported profiles are different than the profile that applies to a particular resource in .rest.resource.profile. The resource profile is a general statement of what features of the resource are supported overall by the system - the sum total of the facilities it supports. A supported profile is a deeper statement about the functionality of the data and services provided by the server (or used by the client). A typical case is a laboratory system that produces a set of different reports - this is the list of types of data that it publishes. A key aspect of declaring profiles here is the question of how the client converts knowledge that the server publishes this data into working with the data; the client can inspect individual resources to determine whether they conform to a particular profile, but how does it find the ones that do? It does so by searching using the _profile parameter, so any resources listed here must be valid values for the _profile resource (using the identifier in the target profile).
         */
        this.supportedProfile = [];
        /**
         * In general, a Resource will only appear in a CapabilityStatement if the server actually has some capabilities - e.g. there is at least one interaction supported. However interactions can be omitted to support summarization (_summary = true).
         */
        this.interaction = [];
        /**
         * A set of flags that defines how references are supported.
         */
        this.referencePolicy = [];
        /**
         * If this list is empty, the server does not support includes.
         */
        this.searchInclude = [];
        /**
         * If this list is empty, the server does not support reverse includes.
         */
        this.searchRevInclude = [];
        /**
         * The search parameters should include the control search parameters such as _sort, _count, etc. that also apply to this resource (though many will be listed at [CapabilityStatement.rest.searchParam](capabilitystatement-definitions.html#CapabilityStatement.rest.searchParam)). The behavior of some search parameters may be further described by other code or extension elements, or narrative within the capability statement or linked [SearchParameter](searchparameter.html#) definitions.
         */
        this.searchParam = [];
        /**
         * Operations linked from CapabilityStatement.rest.resource.operation must have OperationDefinition.type = true or OperationDefinition.instance = true.
         * If an operation that is listed in multiple CapabilityStatement.rest.resource.operation (e.g. for different resource types), then clients should understand that the operation is only supported on the specified resource types, and that may be a subset of those listed in OperationDefinition.resource.
         */
        this.operation = [];
        if (source['type']) {
            this.type = new fhir.FhirCode({ value: source.type });
        }
        else {
            this.type = null;
        }
        if (source['profile']) {
            this.profile = new fhir.FhirCanonical({ value: source.profile });
        }
        if (source['supportedProfile']) {
            this.supportedProfile = source.supportedProfile.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
        if (source['interaction']) {
            this.interaction = source.interaction.map((x) => new fhir.CapabilityStatementRestResourceInteraction(x));
        }
        if (source['versioning']) {
            this.versioning = source.versioning;
        }
        if (source['readHistory']) {
            this.readHistory = new fhir.FhirBoolean({ value: source.readHistory });
        }
        if (source['updateCreate']) {
            this.updateCreate = new fhir.FhirBoolean({ value: source.updateCreate });
        }
        if (source['conditionalCreate']) {
            this.conditionalCreate = new fhir.FhirBoolean({ value: source.conditionalCreate });
        }
        if (source['conditionalRead']) {
            this.conditionalRead = source.conditionalRead;
        }
        if (source['conditionalUpdate']) {
            this.conditionalUpdate = new fhir.FhirBoolean({ value: source.conditionalUpdate });
        }
        if (source['conditionalDelete']) {
            this.conditionalDelete = source.conditionalDelete;
        }
        if (source['referencePolicy']) {
            this.referencePolicy = source.referencePolicy.map((x) => x);
        }
        if (source['searchInclude']) {
            this.searchInclude = source.searchInclude.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['searchRevInclude']) {
            this.searchRevInclude = source.searchRevInclude.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['searchParam']) {
            this.searchParam = source.searchParam.map((x) => new fhir.CapabilityStatementRestResourceSearchParam(x));
        }
        if (source['operation']) {
            this.operation = source.operation.map((x) => new fhir.CapabilityStatementRestResourceOperation(x));
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return ResourceTypesValueSet;
    }
    /**
     * Required-bound Value Set for versioning
     */
    static versioningRequiredValueSet() {
        return VersioningPolicyValueSet;
    }
    /**
     * Required-bound Value Set for conditionalRead
     */
    static conditionalReadRequiredValueSet() {
        return ConditionalReadStatusValueSet;
    }
    /**
     * Required-bound Value Set for conditionalDelete
     */
    static conditionalDeleteRequiredValueSet() {
        return ConditionalDeleteStatusValueSet;
    }
    /**
     * Required-bound Value Set for referencePolicy
     */
    static referencePolicyRequiredValueSet() {
        return ReferenceHandlingPolicyValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.FhirCode fhir: CapabilityStatement.rest.resource.type:code", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["profile"]) {
            outcome.issue.push(...this.profile.doModelValidation().issue);
        }
        if (this["supportedProfile"]) {
            this.supportedProfile.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        if (this["interaction"]) {
            this.interaction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["readHistory"]) {
            outcome.issue.push(...this.readHistory.doModelValidation().issue);
        }
        if (this["updateCreate"]) {
            outcome.issue.push(...this.updateCreate.doModelValidation().issue);
        }
        if (this["conditionalCreate"]) {
            outcome.issue.push(...this.conditionalCreate.doModelValidation().issue);
        }
        if (this["conditionalUpdate"]) {
            outcome.issue.push(...this.conditionalUpdate.doModelValidation().issue);
        }
        if (this["searchInclude"]) {
            this.searchInclude.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["searchRevInclude"]) {
            this.searchRevInclude.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["searchParam"]) {
            this.searchParam.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["operation"]) {
            this.operation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A specification of restful operations supported by the system.
 */
export class CapabilityStatementRestInteraction extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestInteraction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRestInteraction';
        if (source['code']) {
            this.code = source.code;
        }
        else {
            this.code = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
    }
    /**
     * Required-bound Value Set for code
     */
    static codeRequiredValueSet() {
        return SystemRestfulInteractionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:SystemRestfulInteractionValueSetEnum fhir: CapabilityStatement.rest.interaction.code:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Multiple repetitions allow definition of both client and/or server behaviors or possibly behaviors under different configuration settings (for software or requirements statements).
 */
export class CapabilityStatementRest extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementRest';
        /**
         * Max of one repetition per resource type.
         */
        this.resource = [];
        /**
         * A specification of restful operations supported by the system.
         */
        this.interaction = [];
        /**
         * Typically, the only search parameters supported for all searches are those that apply to all resources - tags, profiles, text search etc. These search parameters should include the control search parameters such as _sort, _count, etc. that also apply to this resource (though many will be listed at [CapabilityStatement.rest.searchParam](capabilitystatement-definitions.html#CapabilityStatement.rest.searchParam)). The behavior of some search parameters may be further described by other code or extension elements, or narrative within the capability statement or linked [SearchParameter](searchparameter.html#) definitions.
         */
        this.searchParam = [];
        /**
         * CapabilityStatement.rest.operation is for operations invoked at the system level, or for operations that are supported across multiple resource types. Operations linked from CapabilityStatement.rest.operation must have OperationDefinition.system = true, or more than one Operation.resource.
         */
        this.operation = [];
        /**
         * At present, the only defined compartments are at [CompartmentDefinition](compartmentdefinition.html).
         */
        this.compartment = [];
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
        if (source['security']) {
            this.security = new fhir.CapabilityStatementRestSecurity(source.security);
        }
        if (source['resource']) {
            this.resource = source.resource.map((x) => new fhir.CapabilityStatementRestResource(x));
        }
        if (source['interaction']) {
            this.interaction = source.interaction.map((x) => new fhir.CapabilityStatementRestInteraction(x));
        }
        if (source['searchParam']) {
            this.searchParam = source.searchParam.map((x) => new fhir.CapabilityStatementRestResourceSearchParam(x));
        }
        if (source['operation']) {
            this.operation = source.operation.map((x) => new fhir.CapabilityStatementRestResourceOperation(x));
        }
        if (source['compartment']) {
            this.compartment = source.compartment.map((x) => new fhir.FhirCanonical({ value: x }));
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return RestfulCapabilityModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['mode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property mode:RestfulCapabilityModeValueSetEnum fhir: CapabilityStatement.rest.mode:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        if (this["security"]) {
            outcome.issue.push(...this.security.doModelValidation().issue);
        }
        if (this["resource"]) {
            this.resource.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["interaction"]) {
            this.interaction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["searchParam"]) {
            this.searchParam.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["operation"]) {
            this.operation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["compartment"]) {
            this.compartment.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An endpoint (network accessible address) to which messages and/or replies are to be sent.
 */
export class CapabilityStatementMessagingEndpoint extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessagingEndpoint - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementMessagingEndpoint';
        if (source['protocol']) {
            this.protocol = new fhir.Coding(source.protocol);
        }
        else {
            this.protocol = null;
        }
        if (source['address']) {
            this.address = new fhir.FhirUrl({ value: source.address });
        }
        else {
            this.address = null;
        }
    }
    /**
     * Extensible-bound Value Set for protocol
     */
    static protocolExtensibleValueSet() {
        return MessageTransportValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['protocol']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property protocol:fhir.Coding fhir: CapabilityStatement.messaging.endpoint.protocol:Coding", }));
        }
        if (this["protocol"]) {
            outcome.issue.push(...this.protocol.doModelValidation().issue);
        }
        if (!this['address']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property address:fhir.FhirUrl fhir: CapabilityStatement.messaging.endpoint.address:url", }));
        }
        if (this["address"]) {
            outcome.issue.push(...this.address.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This is a proposed alternative to the messaging.event structure.
 */
export class CapabilityStatementMessagingSupportedMessage extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessagingSupportedMessage - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementMessagingSupportedMessage';
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['definition']) {
            this.definition = new fhir.FhirCanonical({ value: source.definition });
        }
        else {
            this.definition = null;
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return EventCapabilityModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['mode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property mode:EventCapabilityModeValueSetEnum fhir: CapabilityStatement.messaging.supportedMessage.mode:code", }));
        }
        if (!this['definition']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property definition:fhir.FhirCanonical fhir: CapabilityStatement.messaging.supportedMessage.definition:canonical", }));
        }
        if (this["definition"]) {
            outcome.issue.push(...this.definition.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Multiple repetitions allow the documentation of multiple endpoints per solution.
 */
export class CapabilityStatementMessaging extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessaging - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementMessaging';
        /**
         * An endpoint (network accessible address) to which messages and/or replies are to be sent.
         */
        this.endpoint = [];
        /**
         * This is a proposed alternative to the messaging.event structure.
         */
        this.supportedMessage = [];
        if (source['endpoint']) {
            this.endpoint = source.endpoint.map((x) => new fhir.CapabilityStatementMessagingEndpoint(x));
        }
        if (source['reliableCache']) {
            this.reliableCache = new fhir.FhirUnsignedInt({ value: source.reliableCache });
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
        if (source['supportedMessage']) {
            this.supportedMessage = source.supportedMessage.map((x) => new fhir.CapabilityStatementMessagingSupportedMessage(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["endpoint"]) {
            this.endpoint.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["reliableCache"]) {
            outcome.issue.push(...this.reliableCache.doModelValidation().issue);
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        if (this["supportedMessage"]) {
            this.supportedMessage.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A document definition.
 */
export class CapabilityStatementDocument extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementDocument - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatementDocument';
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirMarkdown({ value: source.documentation });
        }
        if (source['profile']) {
            this.profile = new fhir.FhirCanonical({ value: source.profile });
        }
        else {
            this.profile = null;
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return DocumentModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['mode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property mode:DocumentModeValueSetEnum fhir: CapabilityStatement.document.mode:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        if (!this['profile']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property profile:fhir.FhirCanonical fhir: CapabilityStatement.document.profile:canonical", }));
        }
        if (this["profile"]) {
            outcome.issue.push(...this.profile.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
export class CapabilityStatement extends fhir.DomainResource {
    /**
     * Default constructor for CapabilityStatement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CapabilityStatement';
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the capability statement to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * HL7 defines the following Services: [Terminology Service](terminology-service.html).
         * Many [Implementation Guides](http://fhir.org/guides/registry) define additional services.
         */
        this.instantiates = [];
        /**
         * the contents of any directly or indirectly imported CapabilityStatements SHALL NOT overlap, i.e. they cannot refer to the same rest/resource, operations/name, searchparam/name, interaction/code, messaging/endpoint, document/mode pair.
         * A capability statement that imports another CapabilityStatement automatically instantiates it too (though this is often not a very useful statement for the kinds of CapabilityStatements that are suitable for importing).
         */
        this.imports = [];
        /**
         * "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
         */
        this.format = [];
        /**
         * At present, the patch mime types application/json-patch+json and application/xml-patch+xml are legal. Generally, if a server supports PATCH, it would be expected to support the patch formats and match the formats it supports, but this is not always possible or necessary.
         */
        this.patchFormat = [];
        /**
         * A list of implementation guides that the server does (or should) support in their entirety.
         */
        this.implementationGuide = [];
        /**
         * Multiple repetitions allow definition of both client and/or server behaviors or possibly behaviors under different configuration settings (for software or requirements statements).
         */
        this.rest = [];
        /**
         * Multiple repetitions allow the documentation of multiple endpoints per solution.
         */
        this.messaging = [];
        /**
         * A document definition.
         */
        this.document = [];
        this.resourceType = 'CapabilityStatement';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        else {
            this.date = null;
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['kind']) {
            this.kind = source.kind;
        }
        else {
            this.kind = null;
        }
        if (source['instantiates']) {
            this.instantiates = source.instantiates.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['imports']) {
            this.imports = source.imports.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['software']) {
            this.software = new fhir.CapabilityStatementSoftware(source.software);
        }
        if (source['implementation']) {
            this.implementation = new fhir.CapabilityStatementImplementation(source.implementation);
        }
        if (source['fhirVersion']) {
            this.fhirVersion = new fhir.FhirCode({ value: source.fhirVersion });
        }
        else {
            this.fhirVersion = null;
        }
        if (source['format']) {
            this.format = source.format.map((x) => new fhir.FhirCode({ value: x }));
        }
        else {
            this.format = null;
        }
        if (source['patchFormat']) {
            this.patchFormat = source.patchFormat.map((x) => new fhir.FhirCode({ value: x }));
        }
        if (source['implementationGuide']) {
            this.implementationGuide = source.implementationGuide.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['rest']) {
            this.rest = source.rest.map((x) => new fhir.CapabilityStatementRest(x));
        }
        if (source['messaging']) {
            this.messaging = source.messaging.map((x) => new fhir.CapabilityStatementMessaging(x));
        }
        if (source['document']) {
            this.document = source.document.map((x) => new fhir.CapabilityStatementDocument(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Required-bound Value Set for kind
     */
    static kindRequiredValueSet() {
        return CapabilityStatementKindValueSet;
    }
    /**
     * Required-bound Value Set for fhirVersion
     */
    static fhirVersionRequiredValueSet() {
        return FHIRVersionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'CapabilityStatement' fhir: CapabilityStatement.resourceType:'CapabilityStatement'", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: CapabilityStatement.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (!this['date']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property date:fhir.FhirDateTime fhir: CapabilityStatement.date:dateTime", }));
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (!this['kind']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property kind:CapabilityStatementKindValueSetEnum fhir: CapabilityStatement.kind:code", }));
        }
        if (this["instantiates"]) {
            this.instantiates.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["imports"]) {
            this.imports.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["software"]) {
            outcome.issue.push(...this.software.doModelValidation().issue);
        }
        if (this["implementation"]) {
            outcome.issue.push(...this.implementation.doModelValidation().issue);
        }
        if (!this['fhirVersion']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property fhirVersion:fhir.FhirCode fhir: CapabilityStatement.fhirVersion:code", }));
        }
        if (this["fhirVersion"]) {
            outcome.issue.push(...this.fhirVersion.doModelValidation().issue);
        }
        if (!this['format']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property format:fhir.FhirCode[] fhir: CapabilityStatement.format:code", }));
        }
        else if (!Array.isArray(this.format)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property format:fhir.FhirCode[] fhir: CapabilityStatement.format:code", }));
        }
        else if (this.format.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property format:fhir.FhirCode[] fhir: CapabilityStatement.format:code", }));
        }
        if (this["format"]) {
            this.format.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["patchFormat"]) {
            this.patchFormat.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["implementationGuide"]) {
            this.implementationGuide.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["rest"]) {
            this.rest.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["messaging"]) {
            this.messaging.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["document"]) {
            this.document.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=CapabilityStatement.js.map