// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: CapabilityStatement
import * as fhir from '../fhir.js';
import { RestfulSecurityServiceValueSet } from '../fhirValueSets/RestfulSecurityServiceValueSet.js';
import { TypeRestfulInteractionValueSet } from '../fhirValueSets/TypeRestfulInteractionValueSet.js';
import { SearchParamTypeValueSet } from '../fhirValueSets/SearchParamTypeValueSet.js';
import { ResourceTypesValueSet } from '../fhirValueSets/ResourceTypesValueSet.js';
import { VersioningPolicyValueSet } from '../fhirValueSets/VersioningPolicyValueSet.js';
import { ConditionalReadStatusValueSet } from '../fhirValueSets/ConditionalReadStatusValueSet.js';
import { ConditionalDeleteStatusValueSet } from '../fhirValueSets/ConditionalDeleteStatusValueSet.js';
import { ReferenceHandlingPolicyValueSet } from '../fhirValueSets/ReferenceHandlingPolicyValueSet.js';
import { SystemRestfulInteractionValueSet } from '../fhirValueSets/SystemRestfulInteractionValueSet.js';
import { RestfulCapabilityModeValueSet } from '../fhirValueSets/RestfulCapabilityModeValueSet.js';
import { MessageTransportValueSet } from '../fhirValueSets/MessageTransportValueSet.js';
import { EventCapabilityModeValueSet } from '../fhirValueSets/EventCapabilityModeValueSet.js';
import { DocumentModeValueSet } from '../fhirValueSets/DocumentModeValueSet.js';
import { PublicationStatusValueSet } from '../fhirValueSets/PublicationStatusValueSet.js';
import { CapabilityStatementKindValueSet } from '../fhirValueSets/CapabilityStatementKindValueSet.js';
import { FHIRVersionValueSet } from '../fhirValueSets/FHIRVersionValueSet.js';
/**
 * Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
 */
export class CapabilityStatementSoftware extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementSoftware - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
        if (source['releaseDate']) {
            this.releaseDate = source.releaseDate;
        }
        if (source['_releaseDate']) {
            this._releaseDate = new fhir.FhirElement(source._releaseDate);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["name"]) {
            results.push(["name", 'Missing required element: CapabilityStatement.software.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        if (this["_releaseDate"]) {
            results.push(...this._releaseDate.doModelValidation());
        }
        return results;
    }
}
/**
 * Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
export class CapabilityStatementImplementation extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementImplementation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['description']) {
            this.description = source.description;
        }
        else {
            this.description = null;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['custodian']) {
            this.custodian = new fhir.Reference(source.custodian);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["description"]) {
            results.push(["description", 'Missing required element: CapabilityStatement.implementation.description']);
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["custodian"]) {
            results.push(...this.custodian.doModelValidation());
        }
        return results;
    }
}
/**
 * Information about security implementation from an interface perspective - what a client needs to know.
 */
export class CapabilityStatementRestSecurity extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestSecurity - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['cors']) {
            this.cors = source.cors;
        }
        if (source['_cors']) {
            this._cors = new fhir.FhirElement(source._cors);
        }
        if (source['service']) {
            this.service = source.service.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
    }
    /**
     * Extensible-bound Value Set for service
     */
    static serviceExtensibleValueSet() {
        return RestfulSecurityServiceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_cors"]) {
            results.push(...this._cors.doModelValidation());
        }
        if (this["service"]) {
            this.service.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        return results;
    }
}
/**
 * In general, a Resource will only appear in a CapabilityStatement if the server actually has some capabilities - e.g. there is at least one interaction supported. However interactions can be omitted to support summarization (_summary = true).
 */
export class CapabilityStatementRestResourceInteraction extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceInteraction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['code']) {
            this.code = source.code;
        }
        else {
            this.code = null;
        }
        if (source['_code']) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
    }
    /**
     * Required-bound Value Set for code
     */
    static codeRequiredValueSet() {
        return TypeRestfulInteractionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["code"]) {
            results.push(["code", 'Missing required element: CapabilityStatement.rest.resource.interaction.code']);
        }
        if (this["_code"]) {
            results.push(...this._code.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        return results;
    }
}
/**
 * The search parameters should include the control search parameters such as _sort, _count, etc. that also apply to this resource (though many will be listed at [CapabilityStatement.rest.searchParam](capabilitystatement-definitions.html#CapabilityStatement.rest.searchParam)). The behavior of some search parameters may be further described by other code or extension elements, or narrative within the capability statement or linked [SearchParameter](searchparameter.html#) definitions.
 */
export class CapabilityStatementRestResourceSearchParam extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceSearchParam - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['definition']) {
            this.definition = source.definition;
        }
        if (source['_definition']) {
            this._definition = new fhir.FhirElement(source._definition);
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return SearchParamTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["name"]) {
            results.push(["name", 'Missing required element: CapabilityStatement.rest.resource.searchParam.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_definition"]) {
            results.push(...this._definition.doModelValidation());
        }
        if (!this["type"]) {
            results.push(["type", 'Missing required element: CapabilityStatement.rest.resource.searchParam.type']);
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        return results;
    }
}
/**
 * Operations linked from CapabilityStatement.rest.resource.operation must have OperationDefinition.type = true or OperationDefinition.instance = true.
 * If an operation that is listed in multiple CapabilityStatement.rest.resource.operation (e.g. for different resource types), then clients should understand that the operation is only supported on the specified resource types, and that may be a subset of those listed in OperationDefinition.resource.
 */
export class CapabilityStatementRestResourceOperation extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['definition']) {
            this.definition = source.definition;
        }
        else {
            this.definition = null;
        }
        if (source['_definition']) {
            this._definition = new fhir.FhirElement(source._definition);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["name"]) {
            results.push(["name", 'Missing required element: CapabilityStatement.rest.resource.operation.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (!this["definition"]) {
            results.push(["definition", 'Missing required element: CapabilityStatement.rest.resource.operation.definition']);
        }
        if (this["_definition"]) {
            results.push(...this._definition.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        return results;
    }
}
/**
 * Max of one repetition per resource type.
 */
export class CapabilityStatementRestResource extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source['profile']) {
            this.profile = source.profile;
        }
        if (source['_profile']) {
            this._profile = new fhir.FhirElement(source._profile);
        }
        if (source['supportedProfile']) {
            this.supportedProfile = source.supportedProfile.map((x) => (x));
        }
        if (source['_supportedProfile']) {
            this._supportedProfile = source._supportedProfile.map((x) => new fhir.FhirElement(x));
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source['interaction']) {
            this.interaction = source.interaction.map((x) => new fhir.CapabilityStatementRestResourceInteraction(x));
        }
        if (source['versioning']) {
            this.versioning = source.versioning;
        }
        if (source['_versioning']) {
            this._versioning = new fhir.FhirElement(source._versioning);
        }
        if (source['readHistory']) {
            this.readHistory = source.readHistory;
        }
        if (source['_readHistory']) {
            this._readHistory = new fhir.FhirElement(source._readHistory);
        }
        if (source['updateCreate']) {
            this.updateCreate = source.updateCreate;
        }
        if (source['_updateCreate']) {
            this._updateCreate = new fhir.FhirElement(source._updateCreate);
        }
        if (source['conditionalCreate']) {
            this.conditionalCreate = source.conditionalCreate;
        }
        if (source['_conditionalCreate']) {
            this._conditionalCreate = new fhir.FhirElement(source._conditionalCreate);
        }
        if (source['conditionalRead']) {
            this.conditionalRead = source.conditionalRead;
        }
        if (source['_conditionalRead']) {
            this._conditionalRead = new fhir.FhirElement(source._conditionalRead);
        }
        if (source['conditionalUpdate']) {
            this.conditionalUpdate = source.conditionalUpdate;
        }
        if (source['_conditionalUpdate']) {
            this._conditionalUpdate = new fhir.FhirElement(source._conditionalUpdate);
        }
        if (source['conditionalDelete']) {
            this.conditionalDelete = source.conditionalDelete;
        }
        if (source['_conditionalDelete']) {
            this._conditionalDelete = new fhir.FhirElement(source._conditionalDelete);
        }
        if (source['referencePolicy']) {
            this.referencePolicy = source.referencePolicy.map((x) => (x));
        }
        if (source['_referencePolicy']) {
            this._referencePolicy = source._referencePolicy.map((x) => new fhir.FhirElement(x));
        }
        if (source['searchInclude']) {
            this.searchInclude = source.searchInclude.map((x) => (x));
        }
        if (source['_searchInclude']) {
            this._searchInclude = source._searchInclude.map((x) => new fhir.FhirElement(x));
        }
        if (source['searchRevInclude']) {
            this.searchRevInclude = source.searchRevInclude.map((x) => (x));
        }
        if (source['_searchRevInclude']) {
            this._searchRevInclude = source._searchRevInclude.map((x) => new fhir.FhirElement(x));
        }
        if (source['searchParam']) {
            this.searchParam = source.searchParam.map((x) => new fhir.CapabilityStatementRestResourceSearchParam(x));
        }
        if (source['operation']) {
            this.operation = source.operation.map((x) => new fhir.CapabilityStatementRestResourceOperation(x));
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return ResourceTypesValueSet;
    }
    /**
     * Required-bound Value Set for versioning
     */
    static versioningRequiredValueSet() {
        return VersioningPolicyValueSet;
    }
    /**
     * Required-bound Value Set for conditionalRead
     */
    static conditionalReadRequiredValueSet() {
        return ConditionalReadStatusValueSet;
    }
    /**
     * Required-bound Value Set for conditionalDelete
     */
    static conditionalDeleteRequiredValueSet() {
        return ConditionalDeleteStatusValueSet;
    }
    /**
     * Required-bound Value Set for referencePolicy
     */
    static referencePolicyRequiredValueSet() {
        return ReferenceHandlingPolicyValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["type"]) {
            results.push(["type", 'Missing required element: CapabilityStatement.rest.resource.type']);
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        if (this["_profile"]) {
            results.push(...this._profile.doModelValidation());
        }
        if (this["_supportedProfile"]) {
            this._supportedProfile.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        if (this["interaction"]) {
            this.interaction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_versioning"]) {
            results.push(...this._versioning.doModelValidation());
        }
        if (this["_readHistory"]) {
            results.push(...this._readHistory.doModelValidation());
        }
        if (this["_updateCreate"]) {
            results.push(...this._updateCreate.doModelValidation());
        }
        if (this["_conditionalCreate"]) {
            results.push(...this._conditionalCreate.doModelValidation());
        }
        if (this["_conditionalRead"]) {
            results.push(...this._conditionalRead.doModelValidation());
        }
        if (this["_conditionalUpdate"]) {
            results.push(...this._conditionalUpdate.doModelValidation());
        }
        if (this["_conditionalDelete"]) {
            results.push(...this._conditionalDelete.doModelValidation());
        }
        if (this["_referencePolicy"]) {
            this._referencePolicy.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_searchInclude"]) {
            this._searchInclude.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_searchRevInclude"]) {
            this._searchRevInclude.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["searchParam"]) {
            this.searchParam.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["operation"]) {
            this.operation.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * A specification of restful operations supported by the system.
 */
export class CapabilityStatementRestInteraction extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestInteraction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['code']) {
            this.code = source.code;
        }
        else {
            this.code = null;
        }
        if (source['_code']) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
    }
    /**
     * Required-bound Value Set for code
     */
    static codeRequiredValueSet() {
        return SystemRestfulInteractionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["code"]) {
            results.push(["code", 'Missing required element: CapabilityStatement.rest.interaction.code']);
        }
        if (this["_code"]) {
            results.push(...this._code.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        return results;
    }
}
/**
 * Multiple repetitions allow definition of both client and/or server behaviors or possibly behaviors under different configuration settings (for software or requirements statements).
 */
export class CapabilityStatementRest extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['_mode']) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source['security']) {
            this.security = new fhir.CapabilityStatementRestSecurity(source.security);
        }
        if (source['resource']) {
            this.resource = source.resource.map((x) => new fhir.CapabilityStatementRestResource(x));
        }
        if (source['interaction']) {
            this.interaction = source.interaction.map((x) => new fhir.CapabilityStatementRestInteraction(x));
        }
        if (source['searchParam']) {
            this.searchParam = source.searchParam.map((x) => new fhir.CapabilityStatementRestResourceSearchParam(x));
        }
        if (source['operation']) {
            this.operation = source.operation.map((x) => new fhir.CapabilityStatementRestResourceOperation(x));
        }
        if (source['compartment']) {
            this.compartment = source.compartment.map((x) => (x));
        }
        if (source['_compartment']) {
            this._compartment = source._compartment.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return RestfulCapabilityModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["mode"]) {
            results.push(["mode", 'Missing required element: CapabilityStatement.rest.mode']);
        }
        if (this["_mode"]) {
            results.push(...this._mode.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        if (this["security"]) {
            results.push(...this.security.doModelValidation());
        }
        if (this["resource"]) {
            this.resource.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["interaction"]) {
            this.interaction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["searchParam"]) {
            this.searchParam.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["operation"]) {
            this.operation.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_compartment"]) {
            this._compartment.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * An endpoint (network accessible address) to which messages and/or replies are to be sent.
 */
export class CapabilityStatementMessagingEndpoint extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessagingEndpoint - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['protocol']) {
            this.protocol = new fhir.Coding(source.protocol);
        }
        else {
            this.protocol = null;
        }
        if (source['address']) {
            this.address = source.address;
        }
        else {
            this.address = null;
        }
        if (source['_address']) {
            this._address = new fhir.FhirElement(source._address);
        }
    }
    /**
     * Extensible-bound Value Set for protocol
     */
    static protocolExtensibleValueSet() {
        return MessageTransportValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["protocol"]) {
            results.push(["protocol", 'Missing required element: CapabilityStatement.messaging.endpoint.protocol']);
        }
        if (this["protocol"]) {
            results.push(...this.protocol.doModelValidation());
        }
        if (!this["address"]) {
            results.push(["address", 'Missing required element: CapabilityStatement.messaging.endpoint.address']);
        }
        if (this["_address"]) {
            results.push(...this._address.doModelValidation());
        }
        return results;
    }
}
/**
 * This is a proposed alternative to the messaging.event structure.
 */
export class CapabilityStatementMessagingSupportedMessage extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessagingSupportedMessage - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['_mode']) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source['definition']) {
            this.definition = source.definition;
        }
        else {
            this.definition = null;
        }
        if (source['_definition']) {
            this._definition = new fhir.FhirElement(source._definition);
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return EventCapabilityModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["mode"]) {
            results.push(["mode", 'Missing required element: CapabilityStatement.messaging.supportedMessage.mode']);
        }
        if (this["_mode"]) {
            results.push(...this._mode.doModelValidation());
        }
        if (!this["definition"]) {
            results.push(["definition", 'Missing required element: CapabilityStatement.messaging.supportedMessage.definition']);
        }
        if (this["_definition"]) {
            results.push(...this._definition.doModelValidation());
        }
        return results;
    }
}
/**
 * Multiple repetitions allow the documentation of multiple endpoints per solution.
 */
export class CapabilityStatementMessaging extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessaging - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['endpoint']) {
            this.endpoint = source.endpoint.map((x) => new fhir.CapabilityStatementMessagingEndpoint(x));
        }
        if (source['reliableCache']) {
            this.reliableCache = source.reliableCache;
        }
        if (source['_reliableCache']) {
            this._reliableCache = new fhir.FhirElement(source._reliableCache);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source['supportedMessage']) {
            this.supportedMessage = source.supportedMessage.map((x) => new fhir.CapabilityStatementMessagingSupportedMessage(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["endpoint"]) {
            this.endpoint.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_reliableCache"]) {
            results.push(...this._reliableCache.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        if (this["supportedMessage"]) {
            this.supportedMessage.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * A document definition.
 */
export class CapabilityStatementDocument extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementDocument - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['_mode']) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source['documentation']) {
            this.documentation = source.documentation;
        }
        if (source['_documentation']) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source['profile']) {
            this.profile = source.profile;
        }
        else {
            this.profile = null;
        }
        if (source['_profile']) {
            this._profile = new fhir.FhirElement(source._profile);
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return DocumentModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["mode"]) {
            results.push(["mode", 'Missing required element: CapabilityStatement.document.mode']);
        }
        if (this["_mode"]) {
            results.push(...this._mode.doModelValidation());
        }
        if (this["_documentation"]) {
            results.push(...this._documentation.doModelValidation());
        }
        if (!this["profile"]) {
            results.push(["profile", 'Missing required element: CapabilityStatement.document.profile']);
        }
        if (this["_profile"]) {
            results.push(...this._profile.doModelValidation());
        }
        return results;
    }
}
/**
 * A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
export class CapabilityStatement extends fhir.DomainResource {
    /**
     * Default constructor for CapabilityStatement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'CapabilityStatement';
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
        if (source['name']) {
            this.name = source.name;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['title']) {
            this.title = source.title;
        }
        if (source['_title']) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['experimental']) {
            this.experimental = source.experimental;
        }
        if (source['_experimental']) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source['date']) {
            this.date = source.date;
        }
        else {
            this.date = null;
        }
        if (source['_date']) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source['publisher']) {
            this.publisher = source.publisher;
        }
        if (source['_publisher']) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = source.purpose;
        }
        if (source['_purpose']) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source['copyright']) {
            this.copyright = source.copyright;
        }
        if (source['_copyright']) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source['kind']) {
            this.kind = source.kind;
        }
        else {
            this.kind = null;
        }
        if (source['_kind']) {
            this._kind = new fhir.FhirElement(source._kind);
        }
        if (source['instantiates']) {
            this.instantiates = source.instantiates.map((x) => (x));
        }
        if (source['_instantiates']) {
            this._instantiates = source._instantiates.map((x) => new fhir.FhirElement(x));
        }
        if (source['imports']) {
            this.imports = source.imports.map((x) => (x));
        }
        if (source['_imports']) {
            this._imports = source._imports.map((x) => new fhir.FhirElement(x));
        }
        if (source['software']) {
            this.software = new fhir.CapabilityStatementSoftware(source.software);
        }
        if (source['implementation']) {
            this.implementation = new fhir.CapabilityStatementImplementation(source.implementation);
        }
        if (source['fhirVersion']) {
            this.fhirVersion = source.fhirVersion;
        }
        else {
            this.fhirVersion = null;
        }
        if (source['_fhirVersion']) {
            this._fhirVersion = new fhir.FhirElement(source._fhirVersion);
        }
        if (source['format']) {
            this.format = source.format.map((x) => (x));
        }
        else {
            this.format = null;
        }
        if (source['_format']) {
            this._format = source._format.map((x) => new fhir.FhirElement(x));
        }
        if (source['patchFormat']) {
            this.patchFormat = source.patchFormat.map((x) => (x));
        }
        if (source['_patchFormat']) {
            this._patchFormat = source._patchFormat.map((x) => new fhir.FhirElement(x));
        }
        if (source['implementationGuide']) {
            this.implementationGuide = source.implementationGuide.map((x) => (x));
        }
        if (source['_implementationGuide']) {
            this._implementationGuide = source._implementationGuide.map((x) => new fhir.FhirElement(x));
        }
        if (source['rest']) {
            this.rest = source.rest.map((x) => new fhir.CapabilityStatementRest(x));
        }
        if (source['messaging']) {
            this.messaging = source.messaging.map((x) => new fhir.CapabilityStatementMessaging(x));
        }
        if (source['document']) {
            this.document = source.document.map((x) => new fhir.CapabilityStatementDocument(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Required-bound Value Set for kind
     */
    static kindRequiredValueSet() {
        return CapabilityStatementKindValueSet;
    }
    /**
     * Required-bound Value Set for fhirVersion
     */
    static fhirVersionRequiredValueSet() {
        return FHIRVersionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: CapabilityStatement.resourceType']);
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_title"]) {
            results.push(...this._title.doModelValidation());
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: CapabilityStatement.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["_experimental"]) {
            results.push(...this._experimental.doModelValidation());
        }
        if (!this["date"]) {
            results.push(["date", 'Missing required element: CapabilityStatement.date']);
        }
        if (this["_date"]) {
            results.push(...this._date.doModelValidation());
        }
        if (this["_publisher"]) {
            results.push(...this._publisher.doModelValidation());
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_purpose"]) {
            results.push(...this._purpose.doModelValidation());
        }
        if (this["_copyright"]) {
            results.push(...this._copyright.doModelValidation());
        }
        if (!this["kind"]) {
            results.push(["kind", 'Missing required element: CapabilityStatement.kind']);
        }
        if (this["_kind"]) {
            results.push(...this._kind.doModelValidation());
        }
        if (this["_instantiates"]) {
            this._instantiates.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_imports"]) {
            this._imports.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["software"]) {
            results.push(...this.software.doModelValidation());
        }
        if (this["implementation"]) {
            results.push(...this.implementation.doModelValidation());
        }
        if (!this["fhirVersion"]) {
            results.push(["fhirVersion", 'Missing required element: CapabilityStatement.fhirVersion']);
        }
        if (this["_fhirVersion"]) {
            results.push(...this._fhirVersion.doModelValidation());
        }
        if ((!this["format"]) || (this["format"].length === 0)) {
            results.push(["format", 'Missing required element: CapabilityStatement.format']);
        }
        if (this["_format"]) {
            this._format.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_patchFormat"]) {
            this._patchFormat.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_implementationGuide"]) {
            this._implementationGuide.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["rest"]) {
            this.rest.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["messaging"]) {
            this.messaging.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["document"]) {
            this.document.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=CapabilityStatement.js.map