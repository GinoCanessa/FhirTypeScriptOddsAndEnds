// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
 */
export class CapabilityStatementSoftware extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementSoftware - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["releaseDate"]) {
            this.releaseDate = source.releaseDate;
        }
        if (source["_releaseDate"]) {
            this._releaseDate = new fhir.FhirElement(source._releaseDate);
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current CapabilityStatementSoftware contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementSoftware from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementSoftware(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementSoftware is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
export class CapabilityStatementImplementation extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementImplementation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["custodian"]) {
            this.custodian = new fhir.Reference(source.custodian);
        }
        this.description = null;
        if (source["description"]) {
            this.description = source.description;
        }
        if (this.description === undefined) {
            this.description = null;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Check if the current CapabilityStatementImplementation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["description"] === undefined) {
            missingElements.push("description");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementImplementation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementImplementation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementImplementation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about security implementation from an interface perspective - what a client needs to know.
 */
export class CapabilityStatementRestSecurity extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestSecurity - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["cors"]) {
            this.cors = source.cors;
        }
        if (source["_cors"]) {
            this._cors = new fhir.FhirElement(source._cors);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["service"]) {
            this.service = source.service.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Check if the current CapabilityStatementRestSecurity contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRestSecurity from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRestSecurity(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRestSecurity is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * In general, a Resource will only appear in a CapabilityStatement if the server actually has some capabilities - e.g. there is at least one interaction supported. However interactions can be omitted to support summarization (_summary = true).
 */
export class CapabilityStatementRestResourceInteraction extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceInteraction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.code = null;
        if (source["code"]) {
            this.code = source.code;
        }
        if (this.code === undefined) {
            this.code = null;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
    }
    /**
     * Check if the current CapabilityStatementRestResourceInteraction contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRestResourceInteraction from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRestResourceInteraction(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRestResourceInteraction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The search parameters should include the control search parameters such as _sort, _count, etc. that also apply to this resource (though many will be listed at [CapabilityStatement.rest.searchParam](capabilitystatement-definitions.html#CapabilityStatement.rest.searchParam)). The behavior of some search parameters may be further described by other code or extension elements, or narrative within the capability statement or linked [SearchParameter](searchparameter.html#) definitions.
 */
export class CapabilityStatementRestResourceSearchParam extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceSearchParam - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["definition"]) {
            this.definition = source.definition;
        }
        if (source["_definition"]) {
            this._definition = new fhir.FhirElement(source._definition);
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        this.type = null;
        if (source["type"]) {
            this.type = source.type;
        }
        if (this.type === undefined) {
            this.type = null;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Check if the current CapabilityStatementRestResourceSearchParam contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRestResourceSearchParam from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRestResourceSearchParam(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRestResourceSearchParam is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Operations linked from CapabilityStatement.rest.resource.operation must have OperationDefinition.type = true or OperationDefinition.instance = true.
 * If an operation that is listed in multiple CapabilityStatement.rest.resource.operation (e.g. for different resource types), then clients should understand that the operation is only supported on the specified resource types, and that may be a subset of those listed in OperationDefinition.resource.
 */
export class CapabilityStatementRestResourceOperation extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResourceOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.definition = null;
        if (source["definition"]) {
            this.definition = source.definition;
        }
        if (this.definition === undefined) {
            this.definition = null;
        }
        if (source["_definition"]) {
            this._definition = new fhir.FhirElement(source._definition);
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
    }
    /**
     * Check if the current CapabilityStatementRestResourceOperation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["definition"] === undefined) {
            missingElements.push("definition");
        }
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRestResourceOperation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRestResourceOperation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRestResourceOperation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Max of one repetition per resource type.
 */
export class CapabilityStatementRestResource extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestResource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["conditionalCreate"]) {
            this.conditionalCreate = source.conditionalCreate;
        }
        if (source["_conditionalCreate"]) {
            this._conditionalCreate = new fhir.FhirElement(source._conditionalCreate);
        }
        if (source["conditionalDelete"]) {
            this.conditionalDelete = source.conditionalDelete;
        }
        if (source["_conditionalDelete"]) {
            this._conditionalDelete = new fhir.FhirElement(source._conditionalDelete);
        }
        if (source["conditionalRead"]) {
            this.conditionalRead = source.conditionalRead;
        }
        if (source["_conditionalRead"]) {
            this._conditionalRead = new fhir.FhirElement(source._conditionalRead);
        }
        if (source["conditionalUpdate"]) {
            this.conditionalUpdate = source.conditionalUpdate;
        }
        if (source["_conditionalUpdate"]) {
            this._conditionalUpdate = new fhir.FhirElement(source._conditionalUpdate);
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source["interaction"]) {
            this.interaction = source.interaction.map((x) => new fhir.CapabilityStatementRestResourceInteraction(x));
        }
        if (source["operation"]) {
            this.operation = source.operation.map((x) => new fhir.CapabilityStatementRestResourceOperation(x));
        }
        if (source["profile"]) {
            this.profile = source.profile;
        }
        if (source["_profile"]) {
            this._profile = new fhir.FhirElement(source._profile);
        }
        if (source["readHistory"]) {
            this.readHistory = source.readHistory;
        }
        if (source["_readHistory"]) {
            this._readHistory = new fhir.FhirElement(source._readHistory);
        }
        if (source["referencePolicy"]) {
            this.referencePolicy = source.referencePolicy.map((x) => (x));
        }
        if (source["_referencePolicy"]) {
            this._referencePolicy = source._referencePolicy.map((x) => new fhir.FhirElement(x));
        }
        if (source["searchInclude"]) {
            this.searchInclude = source.searchInclude.map((x) => (x));
        }
        if (source["_searchInclude"]) {
            this._searchInclude = source._searchInclude.map((x) => new fhir.FhirElement(x));
        }
        if (source["searchParam"]) {
            this.searchParam = source.searchParam.map((x) => new fhir.CapabilityStatementRestResourceSearchParam(x));
        }
        if (source["searchRevInclude"]) {
            this.searchRevInclude = source.searchRevInclude.map((x) => (x));
        }
        if (source["_searchRevInclude"]) {
            this._searchRevInclude = source._searchRevInclude.map((x) => new fhir.FhirElement(x));
        }
        if (source["supportedProfile"]) {
            this.supportedProfile = source.supportedProfile.map((x) => (x));
        }
        if (source["_supportedProfile"]) {
            this._supportedProfile = source._supportedProfile.map((x) => new fhir.FhirElement(x));
        }
        this.type = null;
        if (source["type"]) {
            this.type = source.type;
        }
        if (this.type === undefined) {
            this.type = null;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source["updateCreate"]) {
            this.updateCreate = source.updateCreate;
        }
        if (source["_updateCreate"]) {
            this._updateCreate = new fhir.FhirElement(source._updateCreate);
        }
        if (source["versioning"]) {
            this.versioning = source.versioning;
        }
        if (source["_versioning"]) {
            this._versioning = new fhir.FhirElement(source._versioning);
        }
    }
    /**
     * Check if the current CapabilityStatementRestResource contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRestResource from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRestResource(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRestResource is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A specification of restful operations supported by the system.
 */
export class CapabilityStatementRestInteraction extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRestInteraction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.code = null;
        if (source["code"]) {
            this.code = source.code;
        }
        if (this.code === undefined) {
            this.code = null;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
    }
    /**
     * Check if the current CapabilityStatementRestInteraction contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRestInteraction from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRestInteraction(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRestInteraction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Multiple repetitions allow definition of both client and/or server behaviors or possibly behaviors under different configuration settings (for software or requirements statements).
 */
export class CapabilityStatementRest extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementRest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["compartment"]) {
            this.compartment = source.compartment.map((x) => (x));
        }
        if (source["_compartment"]) {
            this._compartment = source._compartment.map((x) => new fhir.FhirElement(x));
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source["interaction"]) {
            this.interaction = source.interaction.map((x) => new fhir.CapabilityStatementRestInteraction(x));
        }
        this.mode = null;
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (this.mode === undefined) {
            this.mode = null;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source["operation"]) {
            this.operation = source.operation.map((x) => new fhir.CapabilityStatementRestResourceOperation(x));
        }
        if (source["resource"]) {
            this.resource = source.resource.map((x) => new fhir.CapabilityStatementRestResource(x));
        }
        if (source["searchParam"]) {
            this.searchParam = source.searchParam.map((x) => new fhir.CapabilityStatementRestResourceSearchParam(x));
        }
        if (source["security"]) {
            this.security = new fhir.CapabilityStatementRestSecurity(source.security);
        }
    }
    /**
     * Check if the current CapabilityStatementRest contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["mode"] === undefined) {
            missingElements.push("mode");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementRest from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementRest(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementRest is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An endpoint (network accessible address) to which messages and/or replies are to be sent.
 */
export class CapabilityStatementMessagingEndpoint extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessagingEndpoint - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.address = null;
        if (source["address"]) {
            this.address = source.address;
        }
        if (this.address === undefined) {
            this.address = null;
        }
        if (source["_address"]) {
            this._address = new fhir.FhirElement(source._address);
        }
        this.protocol = null;
        if (source["protocol"]) {
            this.protocol = new fhir.Coding(source.protocol);
        }
        if (this.protocol === undefined) {
            this.protocol = null;
        }
    }
    /**
     * Check if the current CapabilityStatementMessagingEndpoint contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["address"] === undefined) {
            missingElements.push("address");
        }
        if (this["protocol"] === undefined) {
            missingElements.push("protocol");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementMessagingEndpoint from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementMessagingEndpoint(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementMessagingEndpoint is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * This is a proposed alternative to the messaging.event structure.
 */
export class CapabilityStatementMessagingSupportedMessage extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessagingSupportedMessage - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.definition = null;
        if (source["definition"]) {
            this.definition = source.definition;
        }
        if (this.definition === undefined) {
            this.definition = null;
        }
        if (source["_definition"]) {
            this._definition = new fhir.FhirElement(source._definition);
        }
        this.mode = null;
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (this.mode === undefined) {
            this.mode = null;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
    }
    /**
     * Check if the current CapabilityStatementMessagingSupportedMessage contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["definition"] === undefined) {
            missingElements.push("definition");
        }
        if (this["mode"] === undefined) {
            missingElements.push("mode");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementMessagingSupportedMessage from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementMessagingSupportedMessage(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementMessagingSupportedMessage is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Multiple repetitions allow the documentation of multiple endpoints per solution.
 */
export class CapabilityStatementMessaging extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementMessaging - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source["endpoint"]) {
            this.endpoint = source.endpoint.map((x) => new fhir.CapabilityStatementMessagingEndpoint(x));
        }
        if (source["reliableCache"]) {
            this.reliableCache = source.reliableCache;
        }
        if (source["_reliableCache"]) {
            this._reliableCache = new fhir.FhirElement(source._reliableCache);
        }
        if (source["supportedMessage"]) {
            this.supportedMessage = source.supportedMessage.map((x) => new fhir.CapabilityStatementMessagingSupportedMessage(x));
        }
    }
    /**
     * Check if the current CapabilityStatementMessaging contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementMessaging from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementMessaging(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementMessaging is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A document definition.
 */
export class CapabilityStatementDocument extends fhir.BackboneElement {
    /**
     * Default constructor for CapabilityStatementDocument - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.mode = null;
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (this.mode === undefined) {
            this.mode = null;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        this.profile = null;
        if (source["profile"]) {
            this.profile = source.profile;
        }
        if (this.profile === undefined) {
            this.profile = null;
        }
        if (source["_profile"]) {
            this._profile = new fhir.FhirElement(source._profile);
        }
    }
    /**
     * Check if the current CapabilityStatementDocument contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["mode"] === undefined) {
            missingElements.push("mode");
        }
        if (this["profile"] === undefined) {
            missingElements.push("profile");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatementDocument from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatementDocument(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatementDocument is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
export class CapabilityStatement extends fhir.DomainResource {
    /**
     * Default constructor for CapabilityStatement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'CapabilityStatement';
        if (source["contact"]) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source["copyright"]) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"]) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        this.date = null;
        if (source["date"]) {
            this.date = source.date;
        }
        if (this.date === undefined) {
            this.date = null;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["document"]) {
            this.document = source.document.map((x) => new fhir.CapabilityStatementDocument(x));
        }
        if (source["experimental"]) {
            this.experimental = source.experimental;
        }
        if (source["_experimental"]) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        this.fhirVersion = null;
        if (source["fhirVersion"]) {
            this.fhirVersion = source.fhirVersion;
        }
        if (this.fhirVersion === undefined) {
            this.fhirVersion = null;
        }
        if (source["_fhirVersion"]) {
            this._fhirVersion = new fhir.FhirElement(source._fhirVersion);
        }
        this.format = null;
        if (source["format"]) {
            this.format = source.format.map((x) => (x));
        }
        if (this.format === undefined) {
            this.format = null;
        }
        if (source["_format"]) {
            this._format = source._format.map((x) => new fhir.FhirElement(x));
        }
        if (source["implementation"]) {
            this.implementation = new fhir.CapabilityStatementImplementation(source.implementation);
        }
        if (source["implementationGuide"]) {
            this.implementationGuide = source.implementationGuide.map((x) => (x));
        }
        if (source["_implementationGuide"]) {
            this._implementationGuide = source._implementationGuide.map((x) => new fhir.FhirElement(x));
        }
        if (source["imports"]) {
            this.imports = source.imports.map((x) => (x));
        }
        if (source["_imports"]) {
            this._imports = source._imports.map((x) => new fhir.FhirElement(x));
        }
        if (source["instantiates"]) {
            this.instantiates = source.instantiates.map((x) => (x));
        }
        if (source["_instantiates"]) {
            this._instantiates = source._instantiates.map((x) => new fhir.FhirElement(x));
        }
        if (source["jurisdiction"]) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        this.kind = null;
        if (source["kind"]) {
            this.kind = source.kind;
        }
        if (this.kind === undefined) {
            this.kind = null;
        }
        if (source["_kind"]) {
            this._kind = new fhir.FhirElement(source._kind);
        }
        if (source["messaging"]) {
            this.messaging = source.messaging.map((x) => new fhir.CapabilityStatementMessaging(x));
        }
        if (source["name"]) {
            this.name = source.name;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["patchFormat"]) {
            this.patchFormat = source.patchFormat.map((x) => (x));
        }
        if (source["_patchFormat"]) {
            this._patchFormat = source._patchFormat.map((x) => new fhir.FhirElement(x));
        }
        if (source["publisher"]) {
            this.publisher = source.publisher;
        }
        if (source["_publisher"]) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source["purpose"]) {
            this.purpose = source.purpose;
        }
        if (source["_purpose"]) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source["rest"]) {
            this.rest = source.rest.map((x) => new fhir.CapabilityStatementRest(x));
        }
        if (source["software"]) {
            this.software = new fhir.CapabilityStatementSoftware(source.software);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["useContext"]) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current CapabilityStatement contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["date"] === undefined) {
            missingElements.push("date");
        }
        if (this["fhirVersion"] === undefined) {
            missingElements.push("fhirVersion");
        }
        if ((!this["format"]) || (this["format"].length === 0)) {
            missingElements.push("format");
        }
        if (this["kind"] === undefined) {
            missingElements.push("kind");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a CapabilityStatement from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new CapabilityStatement(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `CapabilityStatement is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the CapabilityStatement.rest.resource.interaction.code field
 */
export var CapabilityStatementRestResourceInteractionCodeEnum;
(function (CapabilityStatementRestResourceInteractionCodeEnum) {
    CapabilityStatementRestResourceInteractionCodeEnum["READ"] = "read";
    CapabilityStatementRestResourceInteractionCodeEnum["VREAD"] = "vread";
    CapabilityStatementRestResourceInteractionCodeEnum["UPDATE"] = "update";
    CapabilityStatementRestResourceInteractionCodeEnum["PATCH"] = "patch";
    CapabilityStatementRestResourceInteractionCodeEnum["DELETE"] = "delete";
    CapabilityStatementRestResourceInteractionCodeEnum["HISTORY_INSTANCE"] = "history-instance";
    CapabilityStatementRestResourceInteractionCodeEnum["HISTORY_TYPE"] = "history-type";
    CapabilityStatementRestResourceInteractionCodeEnum["CREATE"] = "create";
    CapabilityStatementRestResourceInteractionCodeEnum["SEARCH_TYPE"] = "search-type";
})(CapabilityStatementRestResourceInteractionCodeEnum || (CapabilityStatementRestResourceInteractionCodeEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.resource.searchParam.type field
 */
export var CapabilityStatementRestResourceSearchParamTypeEnum;
(function (CapabilityStatementRestResourceSearchParamTypeEnum) {
    CapabilityStatementRestResourceSearchParamTypeEnum["NUMBER"] = "number";
    CapabilityStatementRestResourceSearchParamTypeEnum["DATE"] = "date";
    CapabilityStatementRestResourceSearchParamTypeEnum["STRING"] = "string";
    CapabilityStatementRestResourceSearchParamTypeEnum["TOKEN"] = "token";
    CapabilityStatementRestResourceSearchParamTypeEnum["REFERENCE"] = "reference";
    CapabilityStatementRestResourceSearchParamTypeEnum["COMPOSITE"] = "composite";
    CapabilityStatementRestResourceSearchParamTypeEnum["QUANTITY"] = "quantity";
    CapabilityStatementRestResourceSearchParamTypeEnum["URI"] = "uri";
    CapabilityStatementRestResourceSearchParamTypeEnum["SPECIAL"] = "special";
})(CapabilityStatementRestResourceSearchParamTypeEnum || (CapabilityStatementRestResourceSearchParamTypeEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.resource.conditionalDelete field
 */
export var CapabilityStatementRestResourceConditionalDeleteEnum;
(function (CapabilityStatementRestResourceConditionalDeleteEnum) {
    CapabilityStatementRestResourceConditionalDeleteEnum["NOT_SUPPORTED"] = "not-supported";
    CapabilityStatementRestResourceConditionalDeleteEnum["SINGLE"] = "single";
    CapabilityStatementRestResourceConditionalDeleteEnum["MULTIPLE"] = "multiple";
})(CapabilityStatementRestResourceConditionalDeleteEnum || (CapabilityStatementRestResourceConditionalDeleteEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.resource.conditionalRead field
 */
export var CapabilityStatementRestResourceConditionalReadEnum;
(function (CapabilityStatementRestResourceConditionalReadEnum) {
    CapabilityStatementRestResourceConditionalReadEnum["NOT_SUPPORTED"] = "not-supported";
    CapabilityStatementRestResourceConditionalReadEnum["MODIFIED_SINCE"] = "modified-since";
    CapabilityStatementRestResourceConditionalReadEnum["NOT_MATCH"] = "not-match";
    CapabilityStatementRestResourceConditionalReadEnum["FULL_SUPPORT"] = "full-support";
})(CapabilityStatementRestResourceConditionalReadEnum || (CapabilityStatementRestResourceConditionalReadEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.resource.referencePolicy field
 */
export var CapabilityStatementRestResourceReferencePolicyEnum;
(function (CapabilityStatementRestResourceReferencePolicyEnum) {
    CapabilityStatementRestResourceReferencePolicyEnum["LITERAL"] = "literal";
    CapabilityStatementRestResourceReferencePolicyEnum["LOGICAL"] = "logical";
    CapabilityStatementRestResourceReferencePolicyEnum["RESOLVES"] = "resolves";
    CapabilityStatementRestResourceReferencePolicyEnum["ENFORCED"] = "enforced";
    CapabilityStatementRestResourceReferencePolicyEnum["LOCAL"] = "local";
})(CapabilityStatementRestResourceReferencePolicyEnum || (CapabilityStatementRestResourceReferencePolicyEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.resource.versioning field
 */
export var CapabilityStatementRestResourceVersioningEnum;
(function (CapabilityStatementRestResourceVersioningEnum) {
    CapabilityStatementRestResourceVersioningEnum["NO_VERSION"] = "no-version";
    CapabilityStatementRestResourceVersioningEnum["VERSIONED"] = "versioned";
    CapabilityStatementRestResourceVersioningEnum["VERSIONED_UPDATE"] = "versioned-update";
})(CapabilityStatementRestResourceVersioningEnum || (CapabilityStatementRestResourceVersioningEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.interaction.code field
 */
export var CapabilityStatementRestInteractionCodeEnum;
(function (CapabilityStatementRestInteractionCodeEnum) {
    CapabilityStatementRestInteractionCodeEnum["TRANSACTION"] = "transaction";
    CapabilityStatementRestInteractionCodeEnum["BATCH"] = "batch";
    CapabilityStatementRestInteractionCodeEnum["SEARCH_SYSTEM"] = "search-system";
    CapabilityStatementRestInteractionCodeEnum["HISTORY_SYSTEM"] = "history-system";
})(CapabilityStatementRestInteractionCodeEnum || (CapabilityStatementRestInteractionCodeEnum = {}));
/**
 * Code Values for the CapabilityStatement.rest.mode field
 */
export var CapabilityStatementRestModeEnum;
(function (CapabilityStatementRestModeEnum) {
    CapabilityStatementRestModeEnum["CLIENT"] = "client";
    CapabilityStatementRestModeEnum["SERVER"] = "server";
})(CapabilityStatementRestModeEnum || (CapabilityStatementRestModeEnum = {}));
/**
 * Code Values for the CapabilityStatement.messaging.supportedMessage.mode field
 */
export var CapabilityStatementMessagingSupportedMessageModeEnum;
(function (CapabilityStatementMessagingSupportedMessageModeEnum) {
    CapabilityStatementMessagingSupportedMessageModeEnum["SENDER"] = "sender";
    CapabilityStatementMessagingSupportedMessageModeEnum["RECEIVER"] = "receiver";
})(CapabilityStatementMessagingSupportedMessageModeEnum || (CapabilityStatementMessagingSupportedMessageModeEnum = {}));
/**
 * Code Values for the CapabilityStatement.document.mode field
 */
export var CapabilityStatementDocumentModeEnum;
(function (CapabilityStatementDocumentModeEnum) {
    CapabilityStatementDocumentModeEnum["PRODUCER"] = "producer";
    CapabilityStatementDocumentModeEnum["CONSUMER"] = "consumer";
})(CapabilityStatementDocumentModeEnum || (CapabilityStatementDocumentModeEnum = {}));
/**
 * Code Values for the CapabilityStatement.format field
 */
export var CapabilityStatementFormatEnum;
(function (CapabilityStatementFormatEnum) {
    CapabilityStatementFormatEnum["XML"] = "xml";
    CapabilityStatementFormatEnum["JSON"] = "json";
    CapabilityStatementFormatEnum["TTL"] = "ttl";
    CapabilityStatementFormatEnum["MIME"] = "MIME";
})(CapabilityStatementFormatEnum || (CapabilityStatementFormatEnum = {}));
/**
 * Code Values for the CapabilityStatement.kind field
 */
export var CapabilityStatementKindEnum;
(function (CapabilityStatementKindEnum) {
    CapabilityStatementKindEnum["INSTANCE"] = "instance";
    CapabilityStatementKindEnum["CAPABILITY"] = "capability";
    CapabilityStatementKindEnum["REQUIREMENTS"] = "requirements";
})(CapabilityStatementKindEnum || (CapabilityStatementKindEnum = {}));
/**
 * Code Values for the CapabilityStatement.status field
 */
export var CapabilityStatementStatusEnum;
(function (CapabilityStatementStatusEnum) {
    CapabilityStatementStatusEnum["DRAFT"] = "draft";
    CapabilityStatementStatusEnum["ACTIVE"] = "active";
    CapabilityStatementStatusEnum["RETIRED"] = "retired";
    CapabilityStatementStatusEnum["UNKNOWN"] = "unknown";
})(CapabilityStatementStatusEnum || (CapabilityStatementStatusEnum = {}));
//# sourceMappingURL=CapabilityStatement.js.map