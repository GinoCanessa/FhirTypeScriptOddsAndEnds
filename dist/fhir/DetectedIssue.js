// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: DetectedIssue
import * as fhir from '../fhir.js';
import { ManifestationOrSymptomValueSet } from '../fhirValueSets/ManifestationOrSymptomValueSet.js';
import { DetectedissueMitigationActionValueSet } from '../fhirValueSets/DetectedissueMitigationActionValueSet.js';
import { ObservationStatusValueSet } from '../fhirValueSets/ObservationStatusValueSet.js';
import { DetectedissueCategoryValueSet } from '../fhirValueSets/DetectedissueCategoryValueSet.js';
import { DetectedissueSeverityValueSet } from '../fhirValueSets/DetectedissueSeverityValueSet.js';
/**
 * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
 */
export class DetectedIssueEvidence extends fhir.BackboneElement {
    /**
     * Default constructor for DetectedIssueEvidence - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['code']) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Example-bound Value Set for code
     */
    codeExampleValueSet() {
        return ManifestationOrSymptomValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["code"]) {
            this.code.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
 */
export class DetectedIssueMitigation extends fhir.BackboneElement {
    /**
     * Default constructor for DetectedIssueMitigation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['action']) {
            this.action = new fhir.CodeableConcept(source.action);
        }
        else {
            this.action = null;
        }
        if (source['date']) {
            this.date = source.date;
        }
        if (source['_date']) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source['author']) {
            this.author = new fhir.Reference(source.author);
        }
    }
    /**
     * Preferred-bound Value Set for action
     */
    actionPreferredValueSet() {
        return DetectedissueMitigationActionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["action"]) {
            results.push(["action", 'Missing required element: DetectedIssue.mitigation.action']);
        }
        if (this["action"]) {
            results.push(...this.action.doModelValidation());
        }
        if (this["_date"]) {
            results.push(...this._date.doModelValidation());
        }
        if (this["author"]) {
            results.push(...this.author.doModelValidation());
        }
        return results;
    }
}
/**
 * Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
 */
export class DetectedIssue extends fhir.DomainResource {
    /**
     * Default constructor for DetectedIssue - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'DetectedIssue';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['severity']) {
            this.severity = source.severity;
        }
        if (source['_severity']) {
            this._severity = new fhir.FhirElement(source._severity);
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        if (source['identifiedDateTime']) {
            this.identifiedDateTime = source.identifiedDateTime;
        }
        if (source['_identifiedDateTime']) {
            this._identifiedDateTime = new fhir.FhirElement(source._identifiedDateTime);
        }
        if (source['identifiedPeriod']) {
            this.identifiedPeriod = new fhir.Period(source.identifiedPeriod);
        }
        if (source['author']) {
            this.author = new fhir.Reference(source.author);
        }
        if (source['implicated']) {
            this.implicated = source.implicated.map((x) => new fhir.Reference(x));
        }
        if (source['evidence']) {
            this.evidence = source.evidence.map((x) => new fhir.DetectedIssueEvidence(x));
        }
        if (source['detail']) {
            this.detail = source.detail;
        }
        if (source['_detail']) {
            this._detail = new fhir.FhirElement(source._detail);
        }
        if (source['reference']) {
            this.reference = source.reference;
        }
        if (source['_reference']) {
            this._reference = new fhir.FhirElement(source._reference);
        }
        if (source['mitigation']) {
            this.mitigation = source.mitigation.map((x) => new fhir.DetectedIssueMitigation(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    statusRequiredValueSet() {
        return ObservationStatusValueSet;
    }
    /**
     * Preferred-bound Value Set for code
     */
    codePreferredValueSet() {
        return DetectedissueCategoryValueSet;
    }
    /**
     * Required-bound Value Set for severity
     */
    severityRequiredValueSet() {
        return DetectedissueSeverityValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: DetectedIssue.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: DetectedIssue.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["code"]) {
            results.push(...this.code.doModelValidation());
        }
        if (this["_severity"]) {
            results.push(...this._severity.doModelValidation());
        }
        if (this["patient"]) {
            results.push(...this.patient.doModelValidation());
        }
        if (this["_identifiedDateTime"]) {
            results.push(...this._identifiedDateTime.doModelValidation());
        }
        if (this["identifiedPeriod"]) {
            results.push(...this.identifiedPeriod.doModelValidation());
        }
        if (this["author"]) {
            results.push(...this.author.doModelValidation());
        }
        if (this["implicated"]) {
            this.implicated.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["evidence"]) {
            this.evidence.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_detail"]) {
            results.push(...this._detail.doModelValidation());
        }
        if (this["_reference"]) {
            results.push(...this._reference.doModelValidation());
        }
        if (this["mitigation"]) {
            this.mitigation.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=DetectedIssue.js.map