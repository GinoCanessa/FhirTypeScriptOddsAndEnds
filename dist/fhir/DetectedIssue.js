// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: DetectedIssue
import * as fhir from '../fhir.js';
import { ManifestationOrSymptomValueSet, } from '../fhirValueSets/ManifestationOrSymptomValueSet.js';
import { DetectedissueMitigationActionValueSet, } from '../fhirValueSets/DetectedissueMitigationActionValueSet.js';
import { ObservationStatusValueSet, } from '../fhirValueSets/ObservationStatusValueSet.js';
import { DetectedissueCategoryValueSet, } from '../fhirValueSets/DetectedissueCategoryValueSet.js';
import { DetectedissueSeverityValueSet, } from '../fhirValueSets/DetectedissueSeverityValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
 */
export class DetectedIssueEvidence extends fhir.BackboneElement {
    /**
     * Default constructor for DetectedIssueEvidence - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DetectedIssueEvidence';
        /**
         * A manifestation that led to the recording of this detected issue.
         */
        this.code = [];
        /**
         * Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport.
         */
        this.detail = [];
        if (source['code']) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ManifestationOrSymptomValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["code"]) {
            this.code.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
 */
export class DetectedIssueMitigation extends fhir.BackboneElement {
    /**
     * Default constructor for DetectedIssueMitigation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DetectedIssueMitigation';
        if (source['action']) {
            this.action = new fhir.CodeableConcept(source.action);
        }
        else {
            this.action = null;
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['author']) {
            this.author = new fhir.Reference(source.author);
        }
    }
    /**
     * Preferred-bound Value Set for action
     */
    static actionPreferredValueSet() {
        return DetectedissueMitigationActionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['action']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.CodeableConcept fhir: DetectedIssue.mitigation.action:CodeableConcept", }));
        }
        if (this["action"]) {
            outcome.issue.push(...this.action.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["author"]) {
            outcome.issue.push(...this.author.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
 */
export class DetectedIssue extends fhir.DomainResource {
    /**
     * Default constructor for DetectedIssue - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DetectedIssue';
        /**
         * Business identifier associated with the detected issue record.
         */
        this.identifier = [];
        this.__identifiedIsChoice = true;
        /**
         * There's an implicit constraint on the number of implicated resources based on DetectedIssue.type; e.g. For drug-drug, there would be more than one.  For timing, there would typically only be one.
         */
        this.implicated = [];
        /**
         * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
         */
        this.evidence = [];
        /**
         * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
         */
        this.mitigation = [];
        this.resourceType = 'DetectedIssue';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['severity']) {
            this.severity = source.severity;
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        if (source['identified']) {
            this.identified = source.identified;
        }
        else if (source['identifiedDateTime']) {
            this.identified = new fhir.FhirDateTime({ value: source.identifiedDateTime });
        }
        else if (source['identifiedPeriod']) {
            this.identified = new fhir.Period(source.identifiedPeriod);
        }
        if (source['author']) {
            this.author = new fhir.Reference(source.author);
        }
        if (source['implicated']) {
            this.implicated = source.implicated.map((x) => new fhir.Reference(x));
        }
        if (source['evidence']) {
            this.evidence = source.evidence.map((x) => new fhir.DetectedIssueEvidence(x));
        }
        if (source['detail']) {
            this.detail = new fhir.FhirString({ value: source.detail });
        }
        if (source['reference']) {
            this.reference = new fhir.FhirUri({ value: source.reference });
        }
        if (source['mitigation']) {
            this.mitigation = source.mitigation.map((x) => new fhir.DetectedIssueMitigation(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return ObservationStatusValueSet;
    }
    /**
     * Preferred-bound Value Set for code
     */
    static codePreferredValueSet() {
        return DetectedissueCategoryValueSet;
    }
    /**
     * Required-bound Value Set for severity
     */
    static severityRequiredValueSet() {
        return DetectedissueSeverityValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'DetectedIssue' fhir: DetectedIssue.resourceType:'DetectedIssue'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:ObservationStatusValueSetEnum fhir: DetectedIssue.status:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["author"]) {
            outcome.issue.push(...this.author.doModelValidation().issue);
        }
        if (this["implicated"]) {
            this.implicated.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["evidence"]) {
            this.evidence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detail"]) {
            outcome.issue.push(...this.detail.doModelValidation().issue);
        }
        if (this["reference"]) {
            outcome.issue.push(...this.reference.doModelValidation().issue);
        }
        if (this["mitigation"]) {
            this.mitigation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=DetectedIssue.js.map