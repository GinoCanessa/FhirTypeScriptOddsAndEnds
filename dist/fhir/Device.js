// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Device
import * as fhir from '../fhir.js';
import { UdiEntryTypeValueSet } from '../fhirValueSets/UdiEntryTypeValueSet.js';
import { DeviceNametypeValueSet } from '../fhirValueSets/DeviceNametypeValueSet.js';
import { DeviceStatusValueSet } from '../fhirValueSets/DeviceStatusValueSet.js';
import { DeviceStatusReasonValueSet } from '../fhirValueSets/DeviceStatusReasonValueSet.js';
import { DeviceTypeValueSet } from '../fhirValueSets/DeviceTypeValueSet.js';
/**
 * UDI may identify an unique instance of a device, or it may only identify the type of the device.  See [UDI mappings](device-mappings.html#udi) for a complete mapping of UDI parts to Device.
 */
export class DeviceUdiCarrier extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceUdiCarrier - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['deviceIdentifier']) {
            this.deviceIdentifier = source.deviceIdentifier;
        }
        if (source['_deviceIdentifier']) {
            this._deviceIdentifier = new fhir.FhirElement(source._deviceIdentifier);
        }
        if (source['issuer']) {
            this.issuer = source.issuer;
        }
        if (source['_issuer']) {
            this._issuer = new fhir.FhirElement(source._issuer);
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction;
        }
        if (source['_jurisdiction']) {
            this._jurisdiction = new fhir.FhirElement(source._jurisdiction);
        }
        if (source['carrierAIDC']) {
            this.carrierAIDC = source.carrierAIDC;
        }
        if (source['_carrierAIDC']) {
            this._carrierAIDC = new fhir.FhirElement(source._carrierAIDC);
        }
        if (source['carrierHRF']) {
            this.carrierHRF = source.carrierHRF;
        }
        if (source['_carrierHRF']) {
            this._carrierHRF = new fhir.FhirElement(source._carrierHRF);
        }
        if (source['entryType']) {
            this.entryType = source.entryType;
        }
        if (source['_entryType']) {
            this._entryType = new fhir.FhirElement(source._entryType);
        }
    }
    /**
     * Required-bound Value Set for entryType
     */
    static entryTypeRequiredValueSet() {
        return UdiEntryTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_deviceIdentifier"]) {
            results.push(...this._deviceIdentifier.doModelValidation());
        }
        if (this["_issuer"]) {
            results.push(...this._issuer.doModelValidation());
        }
        if (this["_jurisdiction"]) {
            results.push(...this._jurisdiction.doModelValidation());
        }
        if (this["_carrierAIDC"]) {
            results.push(...this._carrierAIDC.doModelValidation());
        }
        if (this["_carrierHRF"]) {
            results.push(...this._carrierHRF.doModelValidation());
        }
        if (this["_entryType"]) {
            results.push(...this._entryType.doModelValidation());
        }
        return results;
    }
}
/**
 * This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
 */
export class DeviceDeviceName extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDeviceName - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return DeviceNametypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["name"]) {
            results.push(["name", 'Missing required element: Device.deviceName.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (!this["type"]) {
            results.push(["type", 'Missing required element: Device.deviceName.type']);
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        return results;
    }
}
/**
 * The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
 */
export class DeviceSpecialization extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceSpecialization - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['systemType']) {
            this.systemType = new fhir.CodeableConcept(source.systemType);
        }
        else {
            this.systemType = null;
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["systemType"]) {
            results.push(["systemType", 'Missing required element: Device.specialization.systemType']);
        }
        if (this["systemType"]) {
            results.push(...this.systemType.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        return results;
    }
}
/**
 * The actual design of the device or software version running on the device.
 */
export class DeviceVersion extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceVersion - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['component']) {
            this.component = new fhir.Identifier(source.component);
        }
        if (source['value']) {
            this.value = source.value;
        }
        else {
            this.value = null;
        }
        if (source['_value']) {
            this._value = new fhir.FhirElement(source._value);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["component"]) {
            results.push(...this.component.doModelValidation());
        }
        if (!this["value"]) {
            results.push(["value", 'Missing required element: Device.version.value']);
        }
        if (this["_value"]) {
            results.push(...this._value.doModelValidation());
        }
        return results;
    }
}
/**
 * The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
 */
export class DeviceProperty extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceProperty - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['valueQuantity']) {
            this.valueQuantity = source.valueQuantity.map((x) => new fhir.Quantity(x));
        }
        if (source['valueCode']) {
            this.valueCode = source.valueCode.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["type"]) {
            results.push(["type", 'Missing required element: Device.property.type']);
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["valueQuantity"]) {
            this.valueQuantity.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["valueCode"]) {
            this.valueCode.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
 */
export class Device extends fhir.DomainResource {
    /**
     * Default constructor for Device - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Device';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['definition']) {
            this.definition = new fhir.Reference(source.definition);
        }
        if (source['udiCarrier']) {
            this.udiCarrier = source.udiCarrier.map((x) => new fhir.DeviceUdiCarrier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['statusReason']) {
            this.statusReason = source.statusReason.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['distinctIdentifier']) {
            this.distinctIdentifier = source.distinctIdentifier;
        }
        if (source['_distinctIdentifier']) {
            this._distinctIdentifier = new fhir.FhirElement(source._distinctIdentifier);
        }
        if (source['manufacturer']) {
            this.manufacturer = source.manufacturer;
        }
        if (source['_manufacturer']) {
            this._manufacturer = new fhir.FhirElement(source._manufacturer);
        }
        if (source['manufactureDate']) {
            this.manufactureDate = source.manufactureDate;
        }
        if (source['_manufactureDate']) {
            this._manufactureDate = new fhir.FhirElement(source._manufactureDate);
        }
        if (source['expirationDate']) {
            this.expirationDate = source.expirationDate;
        }
        if (source['_expirationDate']) {
            this._expirationDate = new fhir.FhirElement(source._expirationDate);
        }
        if (source['lotNumber']) {
            this.lotNumber = source.lotNumber;
        }
        if (source['_lotNumber']) {
            this._lotNumber = new fhir.FhirElement(source._lotNumber);
        }
        if (source['serialNumber']) {
            this.serialNumber = source.serialNumber;
        }
        if (source['_serialNumber']) {
            this._serialNumber = new fhir.FhirElement(source._serialNumber);
        }
        if (source['deviceName']) {
            this.deviceName = source.deviceName.map((x) => new fhir.DeviceDeviceName(x));
        }
        if (source['modelNumber']) {
            this.modelNumber = source.modelNumber;
        }
        if (source['_modelNumber']) {
            this._modelNumber = new fhir.FhirElement(source._modelNumber);
        }
        if (source['partNumber']) {
            this.partNumber = source.partNumber;
        }
        if (source['_partNumber']) {
            this._partNumber = new fhir.FhirElement(source._partNumber);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['specialization']) {
            this.specialization = source.specialization.map((x) => new fhir.DeviceSpecialization(x));
        }
        if (source['version']) {
            this.version = source.version.map((x) => new fhir.DeviceVersion(x));
        }
        if (source['property']) {
            this.property = source.property.map((x) => new fhir.DeviceProperty(x));
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        if (source['owner']) {
            this.owner = new fhir.Reference(source.owner);
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactPoint(x));
        }
        if (source['location']) {
            this.location = new fhir.Reference(source.location);
        }
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source['safety']) {
            this.safety = source.safety.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['parent']) {
            this.parent = new fhir.Reference(source.parent);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return DeviceStatusValueSet;
    }
    /**
     * Extensible-bound Value Set for statusReason
     */
    static statusReasonExtensibleValueSet() {
        return DeviceStatusReasonValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return DeviceTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: Device.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["definition"]) {
            results.push(...this.definition.doModelValidation());
        }
        if (this["udiCarrier"]) {
            this.udiCarrier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["statusReason"]) {
            this.statusReason.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_distinctIdentifier"]) {
            results.push(...this._distinctIdentifier.doModelValidation());
        }
        if (this["_manufacturer"]) {
            results.push(...this._manufacturer.doModelValidation());
        }
        if (this["_manufactureDate"]) {
            results.push(...this._manufactureDate.doModelValidation());
        }
        if (this["_expirationDate"]) {
            results.push(...this._expirationDate.doModelValidation());
        }
        if (this["_lotNumber"]) {
            results.push(...this._lotNumber.doModelValidation());
        }
        if (this["_serialNumber"]) {
            results.push(...this._serialNumber.doModelValidation());
        }
        if (this["deviceName"]) {
            this.deviceName.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_modelNumber"]) {
            results.push(...this._modelNumber.doModelValidation());
        }
        if (this["_partNumber"]) {
            results.push(...this._partNumber.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["specialization"]) {
            this.specialization.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["version"]) {
            this.version.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["property"]) {
            this.property.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["patient"]) {
            results.push(...this.patient.doModelValidation());
        }
        if (this["owner"]) {
            results.push(...this.owner.doModelValidation());
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["location"]) {
            results.push(...this.location.doModelValidation());
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["note"]) {
            this.note.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["safety"]) {
            this.safety.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["parent"]) {
            results.push(...this.parent.doModelValidation());
        }
        return results;
    }
}
//# sourceMappingURL=Device.js.map