// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
 */
export class TerminologyCapabilitiesSoftware extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesSoftware - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesSoftware contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesSoftware from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesSoftware(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesSoftware is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
export class TerminologyCapabilitiesImplementation extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesImplementation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.description = null;
        if (source["description"]) {
            this.description = source.description;
        }
        if (this.description === undefined) {
            this.description = null;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesImplementation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["description"] === undefined) {
            missingElements.push("description");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesImplementation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesImplementation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesImplementation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Filter Properties supported.
 */
export class TerminologyCapabilitiesCodeSystemVersionFilter extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesCodeSystemVersionFilter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.code = null;
        if (source["code"]) {
            this.code = source.code;
        }
        if (this.code === undefined) {
            this.code = null;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        this.op = null;
        if (source["op"]) {
            this.op = source.op.map((x) => (x));
        }
        if (this.op === undefined) {
            this.op = null;
        }
        if (source["_op"]) {
            this._op = source._op.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesCodeSystemVersionFilter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        if ((!this["op"]) || (this["op"].length === 0)) {
            missingElements.push("op");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesCodeSystemVersionFilter from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesCodeSystemVersionFilter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesCodeSystemVersionFilter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Language translations might not be available for all codes.
 */
export class TerminologyCapabilitiesCodeSystemVersion extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesCodeSystemVersion - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = source.code;
        }
        if (source["_code"]) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source["compositional"]) {
            this.compositional = source.compositional;
        }
        if (source["_compositional"]) {
            this._compositional = new fhir.FhirElement(source._compositional);
        }
        if (source["filter"]) {
            this.filter = source.filter.map((x) => new fhir.TerminologyCapabilitiesCodeSystemVersionFilter(x));
        }
        if (source["isDefault"]) {
            this.isDefault = source.isDefault;
        }
        if (source["_isDefault"]) {
            this._isDefault = new fhir.FhirElement(source._isDefault);
        }
        if (source["language"]) {
            this.language = source.language.map((x) => (x));
        }
        if (source["_language"]) {
            this._language = source._language.map((x) => new fhir.FhirElement(x));
        }
        if (source["property"]) {
            this.property = source.property.map((x) => (x));
        }
        if (source["_property"]) {
            this._property = source._property.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesCodeSystemVersion contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesCodeSystemVersion from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesCodeSystemVersion(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesCodeSystemVersion is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
 */
export class TerminologyCapabilitiesCodeSystem extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesCodeSystem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["subsumption"]) {
            this.subsumption = source.subsumption;
        }
        if (source["_subsumption"]) {
            this._subsumption = new fhir.FhirElement(source._subsumption);
        }
        if (source["uri"]) {
            this.uri = source.uri;
        }
        if (source["_uri"]) {
            this._uri = new fhir.FhirElement(source._uri);
        }
        if (source["version"]) {
            this.version = source.version.map((x) => new fhir.TerminologyCapabilitiesCodeSystemVersion(x));
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesCodeSystem contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesCodeSystem from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesCodeSystem(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesCodeSystem is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Supported expansion parameter.
 */
export class TerminologyCapabilitiesExpansionParameter extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesExpansionParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesExpansionParameter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesExpansionParameter from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesExpansionParameter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesExpansionParameter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
 */
export class TerminologyCapabilitiesExpansion extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesExpansion - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["hierarchical"]) {
            this.hierarchical = source.hierarchical;
        }
        if (source["_hierarchical"]) {
            this._hierarchical = new fhir.FhirElement(source._hierarchical);
        }
        if (source["incomplete"]) {
            this.incomplete = source.incomplete;
        }
        if (source["_incomplete"]) {
            this._incomplete = new fhir.FhirElement(source._incomplete);
        }
        if (source["paging"]) {
            this.paging = source.paging;
        }
        if (source["_paging"]) {
            this._paging = new fhir.FhirElement(source._paging);
        }
        if (source["parameter"]) {
            this.parameter = source.parameter.map((x) => new fhir.TerminologyCapabilitiesExpansionParameter(x));
        }
        if (source["textFilter"]) {
            this.textFilter = source.textFilter;
        }
        if (source["_textFilter"]) {
            this._textFilter = new fhir.FhirElement(source._textFilter);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesExpansion contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesExpansion from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesExpansion(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesExpansion is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
 */
export class TerminologyCapabilitiesValidateCode extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesValidateCode - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.translations = null;
        if (source["translations"]) {
            this.translations = source.translations;
        }
        if (this.translations === undefined) {
            this.translations = null;
        }
        if (source["_translations"]) {
            this._translations = new fhir.FhirElement(source._translations);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesValidateCode contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["translations"] === undefined) {
            missingElements.push("translations");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesValidateCode from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesValidateCode(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesValidateCode is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
 */
export class TerminologyCapabilitiesTranslation extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesTranslation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.needsMap = null;
        if (source["needsMap"]) {
            this.needsMap = source.needsMap;
        }
        if (this.needsMap === undefined) {
            this.needsMap = null;
        }
        if (source["_needsMap"]) {
            this._needsMap = new fhir.FhirElement(source._needsMap);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesTranslation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["needsMap"] === undefined) {
            missingElements.push("needsMap");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesTranslation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesTranslation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesTranslation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Whether the $closure operation is supported.
 */
export class TerminologyCapabilitiesClosure extends fhir.BackboneElement {
    /**
     * Default constructor for TerminologyCapabilitiesClosure - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["translation"]) {
            this.translation = source.translation;
        }
        if (source["_translation"]) {
            this._translation = new fhir.FhirElement(source._translation);
        }
    }
    /**
     * Check if the current TerminologyCapabilitiesClosure contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilitiesClosure from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilitiesClosure(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilitiesClosure is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
export class TerminologyCapabilities extends fhir.DomainResource {
    /**
     * Default constructor for TerminologyCapabilities - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'TerminologyCapabilities';
        if (source["closure"]) {
            this.closure = new fhir.TerminologyCapabilitiesClosure(source.closure);
        }
        if (source["codeSearch"]) {
            this.codeSearch = source.codeSearch;
        }
        if (source["_codeSearch"]) {
            this._codeSearch = new fhir.FhirElement(source._codeSearch);
        }
        if (source["codeSystem"]) {
            this.codeSystem = source.codeSystem.map((x) => new fhir.TerminologyCapabilitiesCodeSystem(x));
        }
        if (source["contact"]) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source["copyright"]) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"]) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        this.date = null;
        if (source["date"]) {
            this.date = source.date;
        }
        if (this.date === undefined) {
            this.date = null;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["expansion"]) {
            this.expansion = new fhir.TerminologyCapabilitiesExpansion(source.expansion);
        }
        if (source["experimental"]) {
            this.experimental = source.experimental;
        }
        if (source["_experimental"]) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source["implementation"]) {
            this.implementation = new fhir.TerminologyCapabilitiesImplementation(source.implementation);
        }
        if (source["jurisdiction"]) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        this.kind = null;
        if (source["kind"]) {
            this.kind = source.kind;
        }
        if (this.kind === undefined) {
            this.kind = null;
        }
        if (source["_kind"]) {
            this._kind = new fhir.FhirElement(source._kind);
        }
        if (source["lockedDate"]) {
            this.lockedDate = source.lockedDate;
        }
        if (source["_lockedDate"]) {
            this._lockedDate = new fhir.FhirElement(source._lockedDate);
        }
        if (source["name"]) {
            this.name = source.name;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["publisher"]) {
            this.publisher = source.publisher;
        }
        if (source["_publisher"]) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source["purpose"]) {
            this.purpose = source.purpose;
        }
        if (source["_purpose"]) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source["software"]) {
            this.software = new fhir.TerminologyCapabilitiesSoftware(source.software);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source["translation"]) {
            this.translation = new fhir.TerminologyCapabilitiesTranslation(source.translation);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["useContext"]) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source["validateCode"]) {
            this.validateCode = new fhir.TerminologyCapabilitiesValidateCode(source.validateCode);
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current TerminologyCapabilities contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["date"] === undefined) {
            missingElements.push("date");
        }
        if (this["kind"] === undefined) {
            missingElements.push("kind");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TerminologyCapabilities from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new TerminologyCapabilities(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TerminologyCapabilities is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the TerminologyCapabilities.codeSearch field
 */
export var TerminologyCapabilitiesCodeSearchEnum;
(function (TerminologyCapabilitiesCodeSearchEnum) {
    TerminologyCapabilitiesCodeSearchEnum["EXPLICIT"] = "explicit";
    TerminologyCapabilitiesCodeSearchEnum["ALL"] = "all";
})(TerminologyCapabilitiesCodeSearchEnum || (TerminologyCapabilitiesCodeSearchEnum = {}));
/**
 * Code Values for the TerminologyCapabilities.kind field
 */
export var TerminologyCapabilitiesKindEnum;
(function (TerminologyCapabilitiesKindEnum) {
    TerminologyCapabilitiesKindEnum["INSTANCE"] = "instance";
    TerminologyCapabilitiesKindEnum["CAPABILITY"] = "capability";
    TerminologyCapabilitiesKindEnum["REQUIREMENTS"] = "requirements";
})(TerminologyCapabilitiesKindEnum || (TerminologyCapabilitiesKindEnum = {}));
/**
 * Code Values for the TerminologyCapabilities.status field
 */
export var TerminologyCapabilitiesStatusEnum;
(function (TerminologyCapabilitiesStatusEnum) {
    TerminologyCapabilitiesStatusEnum["DRAFT"] = "draft";
    TerminologyCapabilitiesStatusEnum["ACTIVE"] = "active";
    TerminologyCapabilitiesStatusEnum["RETIRED"] = "retired";
    TerminologyCapabilitiesStatusEnum["UNKNOWN"] = "unknown";
})(TerminologyCapabilitiesStatusEnum || (TerminologyCapabilitiesStatusEnum = {}));
//# sourceMappingURL=TerminologyCapabilities.js.map