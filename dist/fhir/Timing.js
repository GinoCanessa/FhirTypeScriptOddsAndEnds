// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * A set of rules that describe when the event is scheduled.
 */
export class TimingRepeat extends fhir.FhirElement {
    /**
     * Default constructor for TimingRepeat - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["boundsDuration"]) {
            this.boundsDuration = new fhir.Duration(source.boundsDuration);
        }
        if (source["boundsRange"]) {
            this.boundsRange = new fhir.Range(source.boundsRange);
        }
        if (source["boundsPeriod"]) {
            this.boundsPeriod = new fhir.Period(source.boundsPeriod);
        }
        if (source["count"]) {
            this.count = source.count;
        }
        if (source["_count"]) {
            this._count = new fhir.FhirElement(source._count);
        }
        if (source["countMax"]) {
            this.countMax = source.countMax;
        }
        if (source["_countMax"]) {
            this._countMax = new fhir.FhirElement(source._countMax);
        }
        if (source["dayOfWeek"]) {
            this.dayOfWeek = source.dayOfWeek.map((x) => (x));
        }
        if (source["_dayOfWeek"]) {
            this._dayOfWeek = source._dayOfWeek.map((x) => new fhir.FhirElement(x));
        }
        if (source["duration"]) {
            this.duration = source.duration;
        }
        if (source["_duration"]) {
            this._duration = new fhir.FhirElement(source._duration);
        }
        if (source["durationMax"]) {
            this.durationMax = source.durationMax;
        }
        if (source["_durationMax"]) {
            this._durationMax = new fhir.FhirElement(source._durationMax);
        }
        if (source["durationUnit"]) {
            this.durationUnit = source.durationUnit;
        }
        if (source["_durationUnit"]) {
            this._durationUnit = new fhir.FhirElement(source._durationUnit);
        }
        if (source["frequency"]) {
            this.frequency = source.frequency;
        }
        if (source["_frequency"]) {
            this._frequency = new fhir.FhirElement(source._frequency);
        }
        if (source["frequencyMax"]) {
            this.frequencyMax = source.frequencyMax;
        }
        if (source["_frequencyMax"]) {
            this._frequencyMax = new fhir.FhirElement(source._frequencyMax);
        }
        if (source["offset"]) {
            this.offset = source.offset;
        }
        if (source["_offset"]) {
            this._offset = new fhir.FhirElement(source._offset);
        }
        if (source["period"]) {
            this.period = source.period;
        }
        if (source["_period"]) {
            this._period = new fhir.FhirElement(source._period);
        }
        if (source["periodMax"]) {
            this.periodMax = source.periodMax;
        }
        if (source["_periodMax"]) {
            this._periodMax = new fhir.FhirElement(source._periodMax);
        }
        if (source["periodUnit"]) {
            this.periodUnit = source.periodUnit;
        }
        if (source["_periodUnit"]) {
            this._periodUnit = new fhir.FhirElement(source._periodUnit);
        }
        if (source["timeOfDay"]) {
            this.timeOfDay = source.timeOfDay.map((x) => (x));
        }
        if (source["_timeOfDay"]) {
            this._timeOfDay = source._timeOfDay.map((x) => new fhir.FhirElement(x));
        }
        if (source["when"]) {
            this.when = source.when.map((x) => (x));
        }
        if (source["_when"]) {
            this._when = source._when.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Check if the current TimingRepeat contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TimingRepeat from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TimingRepeat(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TimingRepeat is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 */
export class Timing extends fhir.BackboneElement {
    /**
     * Default constructor for Timing - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source["event"]) {
            this.event = source.event.map((x) => (x));
        }
        if (source["_event"]) {
            this._event = source._event.map((x) => new fhir.FhirElement(x));
        }
        if (source["repeat"]) {
            this.repeat = new fhir.TimingRepeat(source.repeat);
        }
    }
    /**
     * Check if the current Timing contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Timing from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new Timing(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `Timing is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the Timing.repeat.dayOfWeek field
 */
export var TimingRepeatDayOfWeekEnum;
(function (TimingRepeatDayOfWeekEnum) {
    TimingRepeatDayOfWeekEnum["MON"] = "mon";
    TimingRepeatDayOfWeekEnum["TUE"] = "tue";
    TimingRepeatDayOfWeekEnum["WED"] = "wed";
    TimingRepeatDayOfWeekEnum["THU"] = "thu";
    TimingRepeatDayOfWeekEnum["FRI"] = "fri";
    TimingRepeatDayOfWeekEnum["SAT"] = "sat";
    TimingRepeatDayOfWeekEnum["SUN"] = "sun";
})(TimingRepeatDayOfWeekEnum || (TimingRepeatDayOfWeekEnum = {}));
/**
 * Code Values for the Timing.repeat.durationUnit field
 */
export var TimingRepeatDurationUnitEnum;
(function (TimingRepeatDurationUnitEnum) {
    TimingRepeatDurationUnitEnum["S"] = "s";
    TimingRepeatDurationUnitEnum["MIN"] = "min";
    TimingRepeatDurationUnitEnum["H"] = "h";
    TimingRepeatDurationUnitEnum["D"] = "d";
    TimingRepeatDurationUnitEnum["WK"] = "wk";
    TimingRepeatDurationUnitEnum["MO"] = "mo";
    TimingRepeatDurationUnitEnum["A"] = "a";
})(TimingRepeatDurationUnitEnum || (TimingRepeatDurationUnitEnum = {}));
/**
 * Code Values for the Timing.repeat.periodUnit field
 */
export var TimingRepeatPeriodUnitEnum;
(function (TimingRepeatPeriodUnitEnum) {
    TimingRepeatPeriodUnitEnum["S"] = "s";
    TimingRepeatPeriodUnitEnum["MIN"] = "min";
    TimingRepeatPeriodUnitEnum["H"] = "h";
    TimingRepeatPeriodUnitEnum["D"] = "d";
    TimingRepeatPeriodUnitEnum["WK"] = "wk";
    TimingRepeatPeriodUnitEnum["MO"] = "mo";
    TimingRepeatPeriodUnitEnum["A"] = "a";
})(TimingRepeatPeriodUnitEnum || (TimingRepeatPeriodUnitEnum = {}));
//# sourceMappingURL=Timing.js.map