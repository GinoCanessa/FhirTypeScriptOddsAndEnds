// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: Timing
import * as fhir from '../fhir.js';
import { UnitsOfTimeValueSet } from '../fhirValueSets/UnitsOfTimeValueSet.js';
import { DaysOfWeekValueSet } from '../fhirValueSets/DaysOfWeekValueSet.js';
import { EventTimingValueSet } from '../fhirValueSets/EventTimingValueSet.js';
import { TimingAbbreviationValueSet } from '../fhirValueSets/TimingAbbreviationValueSet.js';
/**
 * A set of rules that describe when the event is scheduled.
 */
export class TimingRepeat extends fhir.FhirElement {
    /**
     * Default constructor for TimingRepeat - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['boundsDuration']) {
            this.boundsDuration = new fhir.Duration(source.boundsDuration);
        }
        if (source['boundsRange']) {
            this.boundsRange = new fhir.Range(source.boundsRange);
        }
        if (source['boundsPeriod']) {
            this.boundsPeriod = new fhir.Period(source.boundsPeriod);
        }
        if (source['count']) {
            this.count = source.count;
        }
        if (source['_count']) {
            this._count = new fhir.FhirElement(source._count);
        }
        if (source['countMax']) {
            this.countMax = source.countMax;
        }
        if (source['_countMax']) {
            this._countMax = new fhir.FhirElement(source._countMax);
        }
        if (source['duration']) {
            this.duration = source.duration;
        }
        if (source['_duration']) {
            this._duration = new fhir.FhirElement(source._duration);
        }
        if (source['durationMax']) {
            this.durationMax = source.durationMax;
        }
        if (source['_durationMax']) {
            this._durationMax = new fhir.FhirElement(source._durationMax);
        }
        if (source['durationUnit']) {
            this.durationUnit = source.durationUnit;
        }
        if (source['_durationUnit']) {
            this._durationUnit = new fhir.FhirElement(source._durationUnit);
        }
        if (source['frequency']) {
            this.frequency = source.frequency;
        }
        if (source['_frequency']) {
            this._frequency = new fhir.FhirElement(source._frequency);
        }
        if (source['frequencyMax']) {
            this.frequencyMax = source.frequencyMax;
        }
        if (source['_frequencyMax']) {
            this._frequencyMax = new fhir.FhirElement(source._frequencyMax);
        }
        if (source['period']) {
            this.period = source.period;
        }
        if (source['_period']) {
            this._period = new fhir.FhirElement(source._period);
        }
        if (source['periodMax']) {
            this.periodMax = source.periodMax;
        }
        if (source['_periodMax']) {
            this._periodMax = new fhir.FhirElement(source._periodMax);
        }
        if (source['periodUnit']) {
            this.periodUnit = source.periodUnit;
        }
        if (source['_periodUnit']) {
            this._periodUnit = new fhir.FhirElement(source._periodUnit);
        }
        if (source['dayOfWeek']) {
            this.dayOfWeek = source.dayOfWeek.map((x) => (x));
        }
        if (source['_dayOfWeek']) {
            this._dayOfWeek = source._dayOfWeek.map((x) => new fhir.FhirElement(x));
        }
        if (source['timeOfDay']) {
            this.timeOfDay = source.timeOfDay.map((x) => (x));
        }
        if (source['_timeOfDay']) {
            this._timeOfDay = source._timeOfDay.map((x) => new fhir.FhirElement(x));
        }
        if (source['when']) {
            this.when = source.when.map((x) => (x));
        }
        if (source['_when']) {
            this._when = source._when.map((x) => new fhir.FhirElement(x));
        }
        if (source['offset']) {
            this.offset = source.offset;
        }
        if (source['_offset']) {
            this._offset = new fhir.FhirElement(source._offset);
        }
    }
    /**
     * Required-bound Value Set for durationUnit
     */
    durationUnitRequiredValueSet() {
        return UnitsOfTimeValueSet;
    }
    /**
     * Required-bound Value Set for periodUnit
     */
    periodUnitRequiredValueSet() {
        return UnitsOfTimeValueSet;
    }
    /**
     * Required-bound Value Set for dayOfWeek
     */
    dayOfWeekRequiredValueSet() {
        return DaysOfWeekValueSet;
    }
    /**
     * Required-bound Value Set for when
     */
    whenRequiredValueSet() {
        return EventTimingValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["boundsDuration"]) {
            results.push(...this.boundsDuration.doModelValidation());
        }
        if (this["boundsRange"]) {
            results.push(...this.boundsRange.doModelValidation());
        }
        if (this["boundsPeriod"]) {
            results.push(...this.boundsPeriod.doModelValidation());
        }
        if (this["_count"]) {
            results.push(...this._count.doModelValidation());
        }
        if (this["_countMax"]) {
            results.push(...this._countMax.doModelValidation());
        }
        if (this["_duration"]) {
            results.push(...this._duration.doModelValidation());
        }
        if (this["_durationMax"]) {
            results.push(...this._durationMax.doModelValidation());
        }
        if (this["_durationUnit"]) {
            results.push(...this._durationUnit.doModelValidation());
        }
        if (this["_frequency"]) {
            results.push(...this._frequency.doModelValidation());
        }
        if (this["_frequencyMax"]) {
            results.push(...this._frequencyMax.doModelValidation());
        }
        if (this["_period"]) {
            results.push(...this._period.doModelValidation());
        }
        if (this["_periodMax"]) {
            results.push(...this._periodMax.doModelValidation());
        }
        if (this["_periodUnit"]) {
            results.push(...this._periodUnit.doModelValidation());
        }
        if (this["_dayOfWeek"]) {
            this._dayOfWeek.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_timeOfDay"]) {
            this._timeOfDay.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_when"]) {
            this._when.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_offset"]) {
            results.push(...this._offset.doModelValidation());
        }
        return results;
    }
}
/**
 * Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 */
export class Timing extends fhir.BackboneElement {
    /**
     * Default constructor for Timing - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['event']) {
            this.event = source.event.map((x) => (x));
        }
        if (source['_event']) {
            this._event = source._event.map((x) => new fhir.FhirElement(x));
        }
        if (source['repeat']) {
            this.repeat = new fhir.TimingRepeat(source.repeat);
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
    }
    /**
     * Preferred-bound Value Set for code
     */
    codePreferredValueSet() {
        return TimingAbbreviationValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_event"]) {
            this._event.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["repeat"]) {
            results.push(...this.repeat.doModelValidation());
        }
        if (this["code"]) {
            results.push(...this.code.doModelValidation());
        }
        return results;
    }
}
//# sourceMappingURL=Timing.js.map