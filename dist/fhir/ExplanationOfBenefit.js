// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ExplanationOfBenefit
import * as fhir from '../fhir.js';
import { RelatedClaimRelationshipValueSet, } from '../fhirValueSets/RelatedClaimRelationshipValueSet.js';
import { PayeetypeValueSet, } from '../fhirValueSets/PayeetypeValueSet.js';
import { ClaimCareteamroleValueSet, } from '../fhirValueSets/ClaimCareteamroleValueSet.js';
import { ProviderQualificationValueSet, } from '../fhirValueSets/ProviderQualificationValueSet.js';
import { ClaimInformationcategoryValueSet, } from '../fhirValueSets/ClaimInformationcategoryValueSet.js';
import { ClaimExceptionValueSet, } from '../fhirValueSets/ClaimExceptionValueSet.js';
import { MissingToothReasonValueSet, } from '../fhirValueSets/MissingToothReasonValueSet.js';
import { ExDiagnosistypeValueSet, } from '../fhirValueSets/ExDiagnosistypeValueSet.js';
import { ExDiagnosisOnAdmissionValueSet, } from '../fhirValueSets/ExDiagnosisOnAdmissionValueSet.js';
import { ExDiagnosisrelatedgroupValueSet, } from '../fhirValueSets/ExDiagnosisrelatedgroupValueSet.js';
import { ExProcedureTypeValueSet, } from '../fhirValueSets/ExProcedureTypeValueSet.js';
import { V3ActIncidentCodeValueSet, } from '../fhirValueSets/V3ActIncidentCodeValueSet.js';
import { AdjudicationValueSet, } from '../fhirValueSets/AdjudicationValueSet.js';
import { AdjudicationReasonValueSet, } from '../fhirValueSets/AdjudicationReasonValueSet.js';
import { ExRevenueCenterValueSet, } from '../fhirValueSets/ExRevenueCenterValueSet.js';
import { ExBenefitcategoryValueSet, } from '../fhirValueSets/ExBenefitcategoryValueSet.js';
import { ServiceUsclsValueSet, } from '../fhirValueSets/ServiceUsclsValueSet.js';
import { ClaimModifiersValueSet, } from '../fhirValueSets/ClaimModifiersValueSet.js';
import { ExProgramCodeValueSet, } from '../fhirValueSets/ExProgramCodeValueSet.js';
import { ToothValueSet, } from '../fhirValueSets/ToothValueSet.js';
import { SurfaceValueSet, } from '../fhirValueSets/SurfaceValueSet.js';
import { ExPaymenttypeValueSet, } from '../fhirValueSets/ExPaymenttypeValueSet.js';
import { PaymentAdjustmentReasonValueSet, } from '../fhirValueSets/PaymentAdjustmentReasonValueSet.js';
import { NoteTypeValueSet, } from '../fhirValueSets/NoteTypeValueSet.js';
import { LanguagesValueSet, } from '../fhirValueSets/LanguagesValueSet.js';
import { BenefitTypeValueSet, } from '../fhirValueSets/BenefitTypeValueSet.js';
import { BenefitNetworkValueSet, } from '../fhirValueSets/BenefitNetworkValueSet.js';
import { BenefitUnitValueSet, } from '../fhirValueSets/BenefitUnitValueSet.js';
import { BenefitTermValueSet, } from '../fhirValueSets/BenefitTermValueSet.js';
import { ExplanationofbenefitStatusValueSet, } from '../fhirValueSets/ExplanationofbenefitStatusValueSet.js';
import { ClaimTypeValueSet, } from '../fhirValueSets/ClaimTypeValueSet.js';
import { ClaimSubtypeValueSet, } from '../fhirValueSets/ClaimSubtypeValueSet.js';
import { ClaimUseValueSet, } from '../fhirValueSets/ClaimUseValueSet.js';
import { FundsreserveValueSet, } from '../fhirValueSets/FundsreserveValueSet.js';
import { RemittanceOutcomeValueSet, } from '../fhirValueSets/RemittanceOutcomeValueSet.js';
import { FormsValueSet, } from '../fhirValueSets/FormsValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * For example,  for the original treatment and follow-up exams.
 */
export class ExplanationOfBenefitRelated extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitRelated - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitRelated';
        if (source['claim']) {
            this.claim = new fhir.Reference(source.claim);
        }
        if (source['relationship']) {
            this.relationship = new fhir.CodeableConcept(source.relationship);
        }
        if (source['reference']) {
            this.reference = new fhir.Identifier(source.reference);
        }
    }
    /**
     * Example-bound Value Set for relationship
     */
    static relationshipExampleValueSet() {
        return RelatedClaimRelationshipValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["claim"]) {
            outcome.issue.push(...this.claim.doModelValidation().issue);
        }
        if (this["relationship"]) {
            outcome.issue.push(...this.relationship.doModelValidation().issue);
        }
        if (this["reference"]) {
            outcome.issue.push(...this.reference.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Often providers agree to receive the benefits payable to reduce the near-term costs to the patient. The insurer may decline to pay the provider and may choose to pay the subscriber instead.
 */
export class ExplanationOfBenefitPayee extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitPayee - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitPayee';
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['party']) {
            this.party = new fhir.Reference(source.party);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return PayeetypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["party"]) {
            outcome.issue.push(...this.party.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The members of the team who provided the products and services.
 */
export class ExplanationOfBenefitCareTeam extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitCareTeam - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitCareTeam';
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['provider']) {
            this.provider = new fhir.Reference(source.provider);
        }
        else {
            this.provider = null;
        }
        if (source['responsible']) {
            this.responsible = new fhir.FhirBoolean({ value: source.responsible });
        }
        if (source['role']) {
            this.role = new fhir.CodeableConcept(source.role);
        }
        if (source['qualification']) {
            this.qualification = new fhir.CodeableConcept(source.qualification);
        }
    }
    /**
     * Example-bound Value Set for role
     */
    static roleExampleValueSet() {
        return ClaimCareteamroleValueSet;
    }
    /**
     * Example-bound Value Set for qualification
     */
    static qualificationExampleValueSet() {
        return ProviderQualificationValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.careTeam.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['provider']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property provider:fhir.Reference fhir: ExplanationOfBenefit.careTeam.provider:Reference", }));
        }
        if (this["provider"]) {
            outcome.issue.push(...this.provider.doModelValidation().issue);
        }
        if (this["responsible"]) {
            outcome.issue.push(...this.responsible.doModelValidation().issue);
        }
        if (this["role"]) {
            outcome.issue.push(...this.role.doModelValidation().issue);
        }
        if (this["qualification"]) {
            outcome.issue.push(...this.qualification.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Often there are multiple jurisdiction specific valuesets which are required.
 */
export class ExplanationOfBenefitSupportingInfo extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitSupportingInfo - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitSupportingInfo';
        this.__timingIsChoice = true;
        this.__valueIsChoice = true;
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        else {
            this.category = null;
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['timing']) {
            this.timing = source.timing;
        }
        else if (source['timingDate']) {
            this.timing = new fhir.FhirDate({ value: source.timingDate });
        }
        else if (source['timingPeriod']) {
            this.timing = new fhir.Period(source.timingPeriod);
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueQuantity']) {
            this.value = new fhir.Quantity(source.valueQuantity);
        }
        else if (source['valueAttachment']) {
            this.value = new fhir.Attachment(source.valueAttachment);
        }
        else if (source['valueReference']) {
            this.value = new fhir.Reference(source.valueReference);
        }
        if (source['reason']) {
            this.reason = new fhir.Coding(source.reason);
        }
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ClaimInformationcategoryValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ClaimExceptionValueSet;
    }
    /**
     * Example-bound Value Set for reason
     */
    static reasonExampleValueSet() {
        return MissingToothReasonValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.supportingInfo.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['category']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property category:fhir.CodeableConcept fhir: ExplanationOfBenefit.supportingInfo.category:CodeableConcept", }));
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["reason"]) {
            outcome.issue.push(...this.reason.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Information about diagnoses relevant to the claim items.
 */
export class ExplanationOfBenefitDiagnosis extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitDiagnosis - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitDiagnosis';
        this.__diagnosisIsChoice = true;
        /**
         * For example: admitting, primary, secondary, discharge.
         */
        this.type = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['diagnosis']) {
            this.diagnosis = source.diagnosis;
        }
        else if (source['diagnosisCodeableConcept']) {
            this.diagnosis = new fhir.CodeableConcept(source.diagnosisCodeableConcept);
        }
        else if (source['diagnosisReference']) {
            this.diagnosis = new fhir.Reference(source.diagnosisReference);
        }
        else {
            this.diagnosis = null;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['onAdmission']) {
            this.onAdmission = new fhir.CodeableConcept(source.onAdmission);
        }
        if (source['packageCode']) {
            this.packageCode = new fhir.CodeableConcept(source.packageCode);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return ExDiagnosistypeValueSet;
    }
    /**
     * Example-bound Value Set for onAdmission
     */
    static onAdmissionExampleValueSet() {
        return ExDiagnosisOnAdmissionValueSet;
    }
    /**
     * Example-bound Value Set for packageCode
     */
    static packageCodeExampleValueSet() {
        return ExDiagnosisrelatedgroupValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.diagnosis.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['diagnosis']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property diagnosis: fhir: ExplanationOfBenefit.diagnosis.diagnosis[x]:", }));
        }
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["onAdmission"]) {
            outcome.issue.push(...this.onAdmission.doModelValidation().issue);
        }
        if (this["packageCode"]) {
            outcome.issue.push(...this.packageCode.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Procedures performed on the patient relevant to the billing items with the claim.
 */
export class ExplanationOfBenefitProcedure extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitProcedure - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitProcedure';
        /**
         * When the condition was observed or the relative ranking.
         */
        this.type = [];
        this.__procedureIsChoice = true;
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['procedure']) {
            this.procedure = source.procedure;
        }
        else if (source['procedureCodeableConcept']) {
            this.procedure = new fhir.CodeableConcept(source.procedureCodeableConcept);
        }
        else if (source['procedureReference']) {
            this.procedure = new fhir.Reference(source.procedureReference);
        }
        else {
            this.procedure = null;
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return ExProcedureTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.procedure.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (!this['procedure']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property procedure: fhir: ExplanationOfBenefit.procedure.procedure[x]:", }));
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * All insurance coverages for the patient which may be applicable for reimbursement, of the products and services listed in the claim, are typically provided in the claim to allow insurers to confirm the ordering of the insurance coverages relative to local 'coordination of benefit' rules. One coverage (and only one) with 'focal=true' is to be used in the adjudication of this claim. Coverages appearing before the focal Coverage in the list, and where 'Coverage.subrogation=false', should provide a reference to the ClaimResponse containing the adjudication results of the prior claim.
 */
export class ExplanationOfBenefitInsurance extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitInsurance - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitInsurance';
        /**
         * This value is an alphanumeric string that may be provided over the phone, via text, via paper, or within a ClaimResponse resource and is not a FHIR Identifier.
         */
        this.preAuthRef = [];
        if (source['focal']) {
            this.focal = new fhir.FhirBoolean({ value: source.focal });
        }
        else {
            this.focal = null;
        }
        if (source['coverage']) {
            this.coverage = new fhir.Reference(source.coverage);
        }
        else {
            this.coverage = null;
        }
        if (source['preAuthRef']) {
            this.preAuthRef = source.preAuthRef.map((x) => new fhir.FhirString({ value: x }));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['focal']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property focal:fhir.FhirBoolean fhir: ExplanationOfBenefit.insurance.focal:boolean", }));
        }
        if (this["focal"]) {
            outcome.issue.push(...this.focal.doModelValidation().issue);
        }
        if (!this['coverage']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property coverage:fhir.Reference fhir: ExplanationOfBenefit.insurance.coverage:Reference", }));
        }
        if (this["coverage"]) {
            outcome.issue.push(...this.coverage.doModelValidation().issue);
        }
        if (this["preAuthRef"]) {
            this.preAuthRef.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Details of a accident which resulted in injuries which required the products and services listed in the claim.
 */
export class ExplanationOfBenefitAccident extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitAccident - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitAccident';
        this.__locationIsChoice = true;
        if (source['date']) {
            this.date = new fhir.FhirDate({ value: source.date });
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['location']) {
            this.location = source.location;
        }
        else if (source['locationAddress']) {
            this.location = new fhir.Address(source.locationAddress);
        }
        else if (source['locationReference']) {
            this.location = new fhir.Reference(source.locationReference);
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return V3ActIncidentCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
 */
export class ExplanationOfBenefitItemAdjudication extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitItemAdjudication - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitItemAdjudication';
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        else {
            this.category = null;
        }
        if (source['reason']) {
            this.reason = new fhir.CodeableConcept(source.reason);
        }
        if (source['amount']) {
            this.amount = new fhir.Money(source.amount);
        }
        if (source['value']) {
            this.value = new fhir.FhirDecimal({ value: source.value });
        }
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return AdjudicationValueSet;
    }
    /**
     * Example-bound Value Set for reason
     */
    static reasonExampleValueSet() {
        return AdjudicationReasonValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['category']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property category:fhir.CodeableConcept fhir: ExplanationOfBenefit.item.adjudication.category:CodeableConcept", }));
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (this["reason"]) {
            outcome.issue.push(...this.reason.doModelValidation().issue);
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Third-tier of goods and services.
 */
export class ExplanationOfBenefitItemDetailSubDetail extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitItemDetailSubDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitItemDetailSubDetail';
        /**
         * For example, in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or outside of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        this.noteNumber = [];
        /**
         * The adjudication results.
         */
        this.adjudication = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['revenue']) {
            this.revenue = new fhir.CodeableConcept(source.revenue);
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
        if (source['noteNumber']) {
            this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
    }
    /**
     * Example-bound Value Set for revenue
     */
    static revenueExampleValueSet() {
        return ExRevenueCenterValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.item.detail.subDetail.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["revenue"]) {
            outcome.issue.push(...this.revenue.doModelValidation().issue);
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: ExplanationOfBenefit.item.detail.subDetail.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["noteNumber"]) {
            this.noteNumber.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Second-tier of goods and services.
 */
export class ExplanationOfBenefitItemDetail extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitItemDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitItemDetail';
        /**
         * For example, in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        this.noteNumber = [];
        /**
         * The adjudication results.
         */
        this.adjudication = [];
        /**
         * Third-tier of goods and services.
         */
        this.subDetail = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['revenue']) {
            this.revenue = new fhir.CodeableConcept(source.revenue);
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
        if (source['noteNumber']) {
            this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
        if (source['subDetail']) {
            this.subDetail = source.subDetail.map((x) => new fhir.ExplanationOfBenefitItemDetailSubDetail(x));
        }
    }
    /**
     * Example-bound Value Set for revenue
     */
    static revenueExampleValueSet() {
        return ExRevenueCenterValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.item.detail.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["revenue"]) {
            outcome.issue.push(...this.revenue.doModelValidation().issue);
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: ExplanationOfBenefit.item.detail.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["noteNumber"]) {
            this.noteNumber.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["subDetail"]) {
            this.subDetail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
 */
export class ExplanationOfBenefitItem extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitItem';
        /**
         * Care team members related to this service or product.
         */
        this.careTeamSequence = [];
        /**
         * Diagnoses applicable for this service or product.
         */
        this.diagnosisSequence = [];
        /**
         * Procedures applicable for this service or product.
         */
        this.procedureSequence = [];
        /**
         * Exceptions, special conditions and supporting information applicable for this service or product.
         */
        this.informationSequence = [];
        /**
         * For example, in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        this.__servicedIsChoice = true;
        this.__locationIsChoice = true;
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        /**
         * A region or surface of the bodySite, e.g. limb region or tooth surface(s).
         */
        this.subSite = [];
        /**
         * A billed item may include goods or services provided in multiple encounters.
         */
        this.encounter = [];
        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        this.noteNumber = [];
        /**
         * If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
         */
        this.adjudication = [];
        /**
         * Second-tier of goods and services.
         */
        this.detail = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['careTeamSequence']) {
            this.careTeamSequence = source.careTeamSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['diagnosisSequence']) {
            this.diagnosisSequence = source.diagnosisSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['procedureSequence']) {
            this.procedureSequence = source.procedureSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['informationSequence']) {
            this.informationSequence = source.informationSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['revenue']) {
            this.revenue = new fhir.CodeableConcept(source.revenue);
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['serviced']) {
            this.serviced = source.serviced;
        }
        else if (source['servicedDate']) {
            this.serviced = new fhir.FhirDate({ value: source.servicedDate });
        }
        else if (source['servicedPeriod']) {
            this.serviced = new fhir.Period(source.servicedPeriod);
        }
        if (source['location']) {
            this.location = source.location;
        }
        else if (source['locationCodeableConcept']) {
            this.location = new fhir.CodeableConcept(source.locationCodeableConcept);
        }
        else if (source['locationAddress']) {
            this.location = new fhir.Address(source.locationAddress);
        }
        else if (source['locationReference']) {
            this.location = new fhir.Reference(source.locationReference);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
        if (source['bodySite']) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source['subSite']) {
            this.subSite = source.subSite.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['encounter']) {
            this.encounter = source.encounter.map((x) => new fhir.Reference(x));
        }
        if (source['noteNumber']) {
            this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.ExplanationOfBenefitItemDetail(x));
        }
    }
    /**
     * Example-bound Value Set for revenue
     */
    static revenueExampleValueSet() {
        return ExRevenueCenterValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return ToothValueSet;
    }
    /**
     * Example-bound Value Set for subSite
     */
    static subSiteExampleValueSet() {
        return SurfaceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: ExplanationOfBenefit.item.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["careTeamSequence"]) {
            this.careTeamSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["diagnosisSequence"]) {
            this.diagnosisSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["procedureSequence"]) {
            this.procedureSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["informationSequence"]) {
            this.informationSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["revenue"]) {
            outcome.issue.push(...this.revenue.doModelValidation().issue);
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: ExplanationOfBenefit.item.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["bodySite"]) {
            outcome.issue.push(...this.bodySite.doModelValidation().issue);
        }
        if (this["subSite"]) {
            this.subSite.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["encounter"]) {
            this.encounter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["noteNumber"]) {
            this.noteNumber.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The third-tier service adjudications for payor added services.
 */
export class ExplanationOfBenefitAddItemDetailSubDetail extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitAddItemDetailSubDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitAddItemDetailSubDetail';
        /**
         * For example, in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        this.noteNumber = [];
        /**
         * The adjudication results.
         */
        this.adjudication = [];
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['noteNumber']) {
            this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: ExplanationOfBenefit.addItem.detail.subDetail.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["noteNumber"]) {
            this.noteNumber.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The second-tier service adjudications for payor added services.
 */
export class ExplanationOfBenefitAddItemDetail extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitAddItemDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitAddItemDetail';
        /**
         * For example, in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        this.noteNumber = [];
        /**
         * The adjudication results.
         */
        this.adjudication = [];
        /**
         * The third-tier service adjudications for payor added services.
         */
        this.subDetail = [];
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['noteNumber']) {
            this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
        if (source['subDetail']) {
            this.subDetail = source.subDetail.map((x) => new fhir.ExplanationOfBenefitAddItemDetailSubDetail(x));
        }
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: ExplanationOfBenefit.addItem.detail.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["noteNumber"]) {
            this.noteNumber.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["subDetail"]) {
            this.subDetail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The first-tier service adjudications for payor added product or service lines.
 */
export class ExplanationOfBenefitAddItem extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitAddItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitAddItem';
        /**
         * Claim items which this service line is intended to replace.
         */
        this.itemSequence = [];
        /**
         * The sequence number of the details within the claim item which this line is intended to replace.
         */
        this.detailSequence = [];
        /**
         * The sequence number of the sub-details woithin the details within the claim item which this line is intended to replace.
         */
        this.subDetailSequence = [];
        /**
         * The providers who are authorized for the services rendered to the patient.
         */
        this.provider = [];
        /**
         * For example, in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        this.__servicedIsChoice = true;
        this.__locationIsChoice = true;
        /**
         * A region or surface of the bodySite, e.g. limb region or tooth surface(s).
         */
        this.subSite = [];
        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        this.noteNumber = [];
        /**
         * The adjudication results.
         */
        this.adjudication = [];
        /**
         * The second-tier service adjudications for payor added services.
         */
        this.detail = [];
        if (source['itemSequence']) {
            this.itemSequence = source.itemSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['detailSequence']) {
            this.detailSequence = source.detailSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['subDetailSequence']) {
            this.subDetailSequence = source.subDetailSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['provider']) {
            this.provider = source.provider.map((x) => new fhir.Reference(x));
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['serviced']) {
            this.serviced = source.serviced;
        }
        else if (source['servicedDate']) {
            this.serviced = new fhir.FhirDate({ value: source.servicedDate });
        }
        else if (source['servicedPeriod']) {
            this.serviced = new fhir.Period(source.servicedPeriod);
        }
        if (source['location']) {
            this.location = source.location;
        }
        else if (source['locationCodeableConcept']) {
            this.location = new fhir.CodeableConcept(source.locationCodeableConcept);
        }
        else if (source['locationAddress']) {
            this.location = new fhir.Address(source.locationAddress);
        }
        else if (source['locationReference']) {
            this.location = new fhir.Reference(source.locationReference);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['bodySite']) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source['subSite']) {
            this.subSite = source.subSite.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['noteNumber']) {
            this.noteNumber = source.noteNumber.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.ExplanationOfBenefitAddItemDetail(x));
        }
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return ToothValueSet;
    }
    /**
     * Example-bound Value Set for subSite
     */
    static subSiteExampleValueSet() {
        return SurfaceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["itemSequence"]) {
            this.itemSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detailSequence"]) {
            this.detailSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["subDetailSequence"]) {
            this.subDetailSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["provider"]) {
            this.provider.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: ExplanationOfBenefit.addItem.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["bodySite"]) {
            outcome.issue.push(...this.bodySite.doModelValidation().issue);
        }
        if (this["subSite"]) {
            this.subSite.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["noteNumber"]) {
            this.noteNumber.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Totals for amounts submitted, co-pays, benefits payable etc.
 */
export class ExplanationOfBenefitTotal extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitTotal - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitTotal';
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        else {
            this.category = null;
        }
        if (source['amount']) {
            this.amount = new fhir.Money(source.amount);
        }
        else {
            this.amount = null;
        }
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return AdjudicationValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['category']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property category:fhir.CodeableConcept fhir: ExplanationOfBenefit.total.category:CodeableConcept", }));
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['amount']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property amount:fhir.Money fhir: ExplanationOfBenefit.total.amount:Money", }));
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Payment details for the adjudication of the claim.
 */
export class ExplanationOfBenefitPayment extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitPayment - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitPayment';
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['adjustment']) {
            this.adjustment = new fhir.Money(source.adjustment);
        }
        if (source['adjustmentReason']) {
            this.adjustmentReason = new fhir.CodeableConcept(source.adjustmentReason);
        }
        if (source['date']) {
            this.date = new fhir.FhirDate({ value: source.date });
        }
        if (source['amount']) {
            this.amount = new fhir.Money(source.amount);
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return ExPaymenttypeValueSet;
    }
    /**
     * Example-bound Value Set for adjustmentReason
     */
    static adjustmentReasonExampleValueSet() {
        return PaymentAdjustmentReasonValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["adjustment"]) {
            outcome.issue.push(...this.adjustment.doModelValidation().issue);
        }
        if (this["adjustmentReason"]) {
            outcome.issue.push(...this.adjustmentReason.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A note that describes or explains adjudication results in a human readable form.
 */
export class ExplanationOfBenefitProcessNote extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitProcessNote - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitProcessNote';
        if (source['number']) {
            this.number = new fhir.FhirPositiveInt({ value: source.number });
        }
        if (source['type']) {
            this.type = source.type;
        }
        if (source['text']) {
            this.text = new fhir.FhirString({ value: source.text });
        }
        if (source['language']) {
            this.language = new fhir.CodeableConcept(source.language);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return NoteTypeValueSet;
    }
    /**
     * Preferred-bound Value Set for language
     */
    static languagePreferredValueSet() {
        return LanguagesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["number"]) {
            outcome.issue.push(...this.number.doModelValidation().issue);
        }
        if (this["text"]) {
            outcome.issue.push(...this.text.doModelValidation().issue);
        }
        if (this["language"]) {
            outcome.issue.push(...this.language.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Benefits Used to date.
 */
export class ExplanationOfBenefitBenefitBalanceFinancial extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitBenefitBalanceFinancial - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitBenefitBalanceFinancial';
        this.__allowedIsChoice = true;
        this.__usedIsChoice = true;
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['allowed']) {
            this.allowed = source.allowed;
        }
        else if (source['allowedUnsignedInt']) {
            this.allowed = new fhir.FhirUnsignedInt({ value: source.allowedUnsignedInt });
        }
        else if (source['allowedString']) {
            this.allowed = new fhir.FhirString({ value: source.allowedString });
        }
        else if (source['allowedMoney']) {
            this.allowed = new fhir.Money(source.allowedMoney);
        }
        if (source['used']) {
            this.used = source.used;
        }
        else if (source['usedUnsignedInt']) {
            this.used = new fhir.FhirUnsignedInt({ value: source.usedUnsignedInt });
        }
        else if (source['usedMoney']) {
            this.used = new fhir.Money(source.usedMoney);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return BenefitTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: ExplanationOfBenefit.benefitBalance.financial.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Balance by Benefit Category.
 */
export class ExplanationOfBenefitBenefitBalance extends fhir.BackboneElement {
    /**
     * Default constructor for ExplanationOfBenefitBenefitBalance - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefitBenefitBalance';
        /**
         * Benefits Used to date.
         */
        this.financial = [];
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        else {
            this.category = null;
        }
        if (source['excluded']) {
            this.excluded = new fhir.FhirBoolean({ value: source.excluded });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['network']) {
            this.network = new fhir.CodeableConcept(source.network);
        }
        if (source['unit']) {
            this.unit = new fhir.CodeableConcept(source.unit);
        }
        if (source['term']) {
            this.term = new fhir.CodeableConcept(source.term);
        }
        if (source['financial']) {
            this.financial = source.financial.map((x) => new fhir.ExplanationOfBenefitBenefitBalanceFinancial(x));
        }
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for network
     */
    static networkExampleValueSet() {
        return BenefitNetworkValueSet;
    }
    /**
     * Example-bound Value Set for unit
     */
    static unitExampleValueSet() {
        return BenefitUnitValueSet;
    }
    /**
     * Example-bound Value Set for term
     */
    static termExampleValueSet() {
        return BenefitTermValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['category']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property category:fhir.CodeableConcept fhir: ExplanationOfBenefit.benefitBalance.category:CodeableConcept", }));
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (this["excluded"]) {
            outcome.issue.push(...this.excluded.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["network"]) {
            outcome.issue.push(...this.network.doModelValidation().issue);
        }
        if (this["unit"]) {
            outcome.issue.push(...this.unit.doModelValidation().issue);
        }
        if (this["term"]) {
            outcome.issue.push(...this.term.doModelValidation().issue);
        }
        if (this["financial"]) {
            this.financial.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
 */
export class ExplanationOfBenefit extends fhir.DomainResource {
    /**
     * Default constructor for ExplanationOfBenefit - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ExplanationOfBenefit';
        /**
         * A unique identifier assigned to this explanation of benefit.
         */
        this.identifier = [];
        /**
         * For example,  for the original treatment and follow-up exams.
         */
        this.related = [];
        /**
         * This value is only present on preauthorization adjudications.
         */
        this.preAuthRef = [];
        /**
         * This value is only present on preauthorization adjudications.
         */
        this.preAuthRefPeriod = [];
        /**
         * The members of the team who provided the products and services.
         */
        this.careTeam = [];
        /**
         * Often there are multiple jurisdiction specific valuesets which are required.
         */
        this.supportingInfo = [];
        /**
         * Information about diagnoses relevant to the claim items.
         */
        this.diagnosis = [];
        /**
         * Procedures performed on the patient relevant to the billing items with the claim.
         */
        this.procedure = [];
        /**
         * All insurance coverages for the patient which may be applicable for reimbursement, of the products and services listed in the claim, are typically provided in the claim to allow insurers to confirm the ordering of the insurance coverages relative to local 'coordination of benefit' rules. One coverage (and only one) with 'focal=true' is to be used in the adjudication of this claim. Coverages appearing before the focal Coverage in the list, and where 'Coverage.subrogation=false', should provide a reference to the ClaimResponse containing the adjudication results of the prior claim.
         */
        this.insurance = [];
        /**
         * A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
         */
        this.item = [];
        /**
         * The first-tier service adjudications for payor added product or service lines.
         */
        this.addItem = [];
        /**
         * The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
         */
        this.adjudication = [];
        /**
         * Totals for amounts submitted, co-pays, benefits payable etc.
         */
        this.total = [];
        /**
         * A note that describes or explains adjudication results in a human readable form.
         */
        this.processNote = [];
        /**
         * Balance by Benefit Category.
         */
        this.benefitBalance = [];
        this.resourceType = 'ExplanationOfBenefit';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['subType']) {
            this.subType = new fhir.CodeableConcept(source.subType);
        }
        if (source['use']) {
            this.use = source.use;
        }
        else {
            this.use = null;
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        else {
            this.patient = null;
        }
        if (source['billablePeriod']) {
            this.billablePeriod = new fhir.Period(source.billablePeriod);
        }
        if (source['created']) {
            this.created = new fhir.FhirDateTime({ value: source.created });
        }
        else {
            this.created = null;
        }
        if (source['enterer']) {
            this.enterer = new fhir.Reference(source.enterer);
        }
        if (source['insurer']) {
            this.insurer = new fhir.Reference(source.insurer);
        }
        else {
            this.insurer = null;
        }
        if (source['provider']) {
            this.provider = new fhir.Reference(source.provider);
        }
        else {
            this.provider = null;
        }
        if (source['priority']) {
            this.priority = new fhir.CodeableConcept(source.priority);
        }
        if (source['fundsReserveRequested']) {
            this.fundsReserveRequested = new fhir.CodeableConcept(source.fundsReserveRequested);
        }
        if (source['fundsReserve']) {
            this.fundsReserve = new fhir.CodeableConcept(source.fundsReserve);
        }
        if (source['related']) {
            this.related = source.related.map((x) => new fhir.ExplanationOfBenefitRelated(x));
        }
        if (source['prescription']) {
            this.prescription = new fhir.Reference(source.prescription);
        }
        if (source['originalPrescription']) {
            this.originalPrescription = new fhir.Reference(source.originalPrescription);
        }
        if (source['payee']) {
            this.payee = new fhir.ExplanationOfBenefitPayee(source.payee);
        }
        if (source['referral']) {
            this.referral = new fhir.Reference(source.referral);
        }
        if (source['facility']) {
            this.facility = new fhir.Reference(source.facility);
        }
        if (source['claim']) {
            this.claim = new fhir.Reference(source.claim);
        }
        if (source['claimResponse']) {
            this.claimResponse = new fhir.Reference(source.claimResponse);
        }
        if (source['outcome']) {
            this.outcome = source.outcome;
        }
        else {
            this.outcome = null;
        }
        if (source['disposition']) {
            this.disposition = new fhir.FhirString({ value: source.disposition });
        }
        if (source['preAuthRef']) {
            this.preAuthRef = source.preAuthRef.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['preAuthRefPeriod']) {
            this.preAuthRefPeriod = source.preAuthRefPeriod.map((x) => new fhir.Period(x));
        }
        if (source['careTeam']) {
            this.careTeam = source.careTeam.map((x) => new fhir.ExplanationOfBenefitCareTeam(x));
        }
        if (source['supportingInfo']) {
            this.supportingInfo = source.supportingInfo.map((x) => new fhir.ExplanationOfBenefitSupportingInfo(x));
        }
        if (source['diagnosis']) {
            this.diagnosis = source.diagnosis.map((x) => new fhir.ExplanationOfBenefitDiagnosis(x));
        }
        if (source['procedure']) {
            this.procedure = source.procedure.map((x) => new fhir.ExplanationOfBenefitProcedure(x));
        }
        if (source['precedence']) {
            this.precedence = new fhir.FhirPositiveInt({ value: source.precedence });
        }
        if (source['insurance']) {
            this.insurance = source.insurance.map((x) => new fhir.ExplanationOfBenefitInsurance(x));
        }
        else {
            this.insurance = null;
        }
        if (source['accident']) {
            this.accident = new fhir.ExplanationOfBenefitAccident(source.accident);
        }
        if (source['item']) {
            this.item = source.item.map((x) => new fhir.ExplanationOfBenefitItem(x));
        }
        if (source['addItem']) {
            this.addItem = source.addItem.map((x) => new fhir.ExplanationOfBenefitAddItem(x));
        }
        if (source['adjudication']) {
            this.adjudication = source.adjudication.map((x) => new fhir.ExplanationOfBenefitItemAdjudication(x));
        }
        if (source['total']) {
            this.total = source.total.map((x) => new fhir.ExplanationOfBenefitTotal(x));
        }
        if (source['payment']) {
            this.payment = new fhir.ExplanationOfBenefitPayment(source.payment);
        }
        if (source['formCode']) {
            this.formCode = new fhir.CodeableConcept(source.formCode);
        }
        if (source['form']) {
            this.form = new fhir.Attachment(source.form);
        }
        if (source['processNote']) {
            this.processNote = source.processNote.map((x) => new fhir.ExplanationOfBenefitProcessNote(x));
        }
        if (source['benefitPeriod']) {
            this.benefitPeriod = new fhir.Period(source.benefitPeriod);
        }
        if (source['benefitBalance']) {
            this.benefitBalance = source.benefitBalance.map((x) => new fhir.ExplanationOfBenefitBenefitBalance(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return ExplanationofbenefitStatusValueSet;
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return ClaimTypeValueSet;
    }
    /**
     * Example-bound Value Set for subType
     */
    static subTypeExampleValueSet() {
        return ClaimSubtypeValueSet;
    }
    /**
     * Required-bound Value Set for use
     */
    static useRequiredValueSet() {
        return ClaimUseValueSet;
    }
    /**
     * Example-bound Value Set for fundsReserveRequested
     */
    static fundsReserveRequestedExampleValueSet() {
        return FundsreserveValueSet;
    }
    /**
     * Example-bound Value Set for fundsReserve
     */
    static fundsReserveExampleValueSet() {
        return FundsreserveValueSet;
    }
    /**
     * Required-bound Value Set for outcome
     */
    static outcomeRequiredValueSet() {
        return RemittanceOutcomeValueSet;
    }
    /**
     * Example-bound Value Set for formCode
     */
    static formCodeExampleValueSet() {
        return FormsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'ExplanationOfBenefit' fhir: ExplanationOfBenefit.resourceType:'ExplanationOfBenefit'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:ExplanationofbenefitStatusValueSetEnum fhir: ExplanationOfBenefit.status:code", }));
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: ExplanationOfBenefit.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["subType"]) {
            outcome.issue.push(...this.subType.doModelValidation().issue);
        }
        if (!this['use']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property use:ClaimUseValueSetEnum fhir: ExplanationOfBenefit.use:code", }));
        }
        if (!this['patient']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property patient:fhir.Reference fhir: ExplanationOfBenefit.patient:Reference", }));
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["billablePeriod"]) {
            outcome.issue.push(...this.billablePeriod.doModelValidation().issue);
        }
        if (!this['created']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property created:fhir.FhirDateTime fhir: ExplanationOfBenefit.created:dateTime", }));
        }
        if (this["created"]) {
            outcome.issue.push(...this.created.doModelValidation().issue);
        }
        if (this["enterer"]) {
            outcome.issue.push(...this.enterer.doModelValidation().issue);
        }
        if (!this['insurer']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property insurer:fhir.Reference fhir: ExplanationOfBenefit.insurer:Reference", }));
        }
        if (this["insurer"]) {
            outcome.issue.push(...this.insurer.doModelValidation().issue);
        }
        if (!this['provider']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property provider:fhir.Reference fhir: ExplanationOfBenefit.provider:Reference", }));
        }
        if (this["provider"]) {
            outcome.issue.push(...this.provider.doModelValidation().issue);
        }
        if (this["priority"]) {
            outcome.issue.push(...this.priority.doModelValidation().issue);
        }
        if (this["fundsReserveRequested"]) {
            outcome.issue.push(...this.fundsReserveRequested.doModelValidation().issue);
        }
        if (this["fundsReserve"]) {
            outcome.issue.push(...this.fundsReserve.doModelValidation().issue);
        }
        if (this["related"]) {
            this.related.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["prescription"]) {
            outcome.issue.push(...this.prescription.doModelValidation().issue);
        }
        if (this["originalPrescription"]) {
            outcome.issue.push(...this.originalPrescription.doModelValidation().issue);
        }
        if (this["payee"]) {
            outcome.issue.push(...this.payee.doModelValidation().issue);
        }
        if (this["referral"]) {
            outcome.issue.push(...this.referral.doModelValidation().issue);
        }
        if (this["facility"]) {
            outcome.issue.push(...this.facility.doModelValidation().issue);
        }
        if (this["claim"]) {
            outcome.issue.push(...this.claim.doModelValidation().issue);
        }
        if (this["claimResponse"]) {
            outcome.issue.push(...this.claimResponse.doModelValidation().issue);
        }
        if (!this['outcome']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property outcome:RemittanceOutcomeValueSetEnum fhir: ExplanationOfBenefit.outcome:code", }));
        }
        if (this["disposition"]) {
            outcome.issue.push(...this.disposition.doModelValidation().issue);
        }
        if (this["preAuthRef"]) {
            this.preAuthRef.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["preAuthRefPeriod"]) {
            this.preAuthRefPeriod.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["careTeam"]) {
            this.careTeam.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["supportingInfo"]) {
            this.supportingInfo.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["diagnosis"]) {
            this.diagnosis.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["procedure"]) {
            this.procedure.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["precedence"]) {
            outcome.issue.push(...this.precedence.doModelValidation().issue);
        }
        if (!this['insurance']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property insurance:fhir.ExplanationOfBenefitInsurance[] fhir: ExplanationOfBenefit.insurance:insurance", }));
        }
        else if (!Array.isArray(this.insurance)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property insurance:fhir.ExplanationOfBenefitInsurance[] fhir: ExplanationOfBenefit.insurance:insurance", }));
        }
        else if (this.insurance.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property insurance:fhir.ExplanationOfBenefitInsurance[] fhir: ExplanationOfBenefit.insurance:insurance", }));
        }
        if (this["insurance"]) {
            this.insurance.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["accident"]) {
            outcome.issue.push(...this.accident.doModelValidation().issue);
        }
        if (this["item"]) {
            this.item.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["addItem"]) {
            this.addItem.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["adjudication"]) {
            this.adjudication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["total"]) {
            this.total.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["payment"]) {
            outcome.issue.push(...this.payment.doModelValidation().issue);
        }
        if (this["formCode"]) {
            outcome.issue.push(...this.formCode.doModelValidation().issue);
        }
        if (this["form"]) {
            outcome.issue.push(...this.form.doModelValidation().issue);
        }
        if (this["processNote"]) {
            this.processNote.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["benefitPeriod"]) {
            outcome.issue.push(...this.benefitPeriod.doModelValidation().issue);
        }
        if (this["benefitBalance"]) {
            this.benefitBalance.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=ExplanationOfBenefit.js.map