// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Patient
import * as fhir from '../fhir.js';
import { PatientContactrelationshipValueSet, } from '../fhirValueSets/PatientContactrelationshipValueSet.js';
import { AdministrativeGenderValueSet, } from '../fhirValueSets/AdministrativeGenderValueSet.js';
import { LanguagesValueSet, } from '../fhirValueSets/LanguagesValueSet.js';
import { LinkTypeValueSet, } from '../fhirValueSets/LinkTypeValueSet.js';
import { MaritalStatusValueSet, } from '../fhirValueSets/MaritalStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Contact covers all kinds of contact parties: family members, business contacts, guardians, caregivers. Not applicable to register pedigree and family ties beyond use of having contact.
 */
export class PatientContact extends fhir.BackboneElement {
    /**
     * Default constructor for PatientContact - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PatientContact';
        /**
         * The nature of the relationship between the patient and the contact person.
         */
        this.relationship = [];
        /**
         * Contact may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently, and also to help with identification.
         */
        this.telecom = [];
        if (source['relationship']) {
            this.relationship = source.relationship.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['name']) {
            this.name = new fhir.HumanName(source.name);
        }
        if (source['telecom']) {
            this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x));
        }
        if (source['address']) {
            this.address = new fhir.Address(source.address);
        }
        if (source['gender']) {
            this.gender = source.gender;
        }
        if (source['organization']) {
            this.organization = new fhir.Reference(source.organization);
        }
        if (source['period']) {
            this.period = new fhir.Period(source.period);
        }
    }
    /**
     * Extensible-bound Value Set for relationship
     */
    static relationshipExtensibleValueSet() {
        return PatientContactrelationshipValueSet;
    }
    /**
     * Required-bound Value Set for gender
     */
    static genderRequiredValueSet() {
        return AdministrativeGenderValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["relationship"]) {
            this.relationship.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["telecom"]) {
            this.telecom.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["address"]) {
            outcome.issue.push(...this.address.doModelValidation().issue);
        }
        if (this["organization"]) {
            outcome.issue.push(...this.organization.doModelValidation().issue);
        }
        if (this["period"]) {
            outcome.issue.push(...this.period.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple Patient.Communication associations.   For animals, language is not a relevant field, and should be absent from the instance. If the Patient does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
 */
export class PatientCommunication extends fhir.BackboneElement {
    /**
     * Default constructor for PatientCommunication - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PatientCommunication';
        if (source['language']) {
            this.language = new fhir.CodeableConcept(source.language);
        }
        else {
            this.language = null;
        }
        if (source['preferred']) {
            this.preferred = new fhir.FhirBoolean({ value: source.preferred });
        }
    }
    /**
     * Preferred-bound Value Set for language
     */
    static languagePreferredValueSet() {
        return LanguagesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['language']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property language:fhir.CodeableConcept fhir: Patient.communication.language:CodeableConcept", }));
        }
        if (this["language"]) {
            outcome.issue.push(...this.language.doModelValidation().issue);
        }
        if (this["preferred"]) {
            outcome.issue.push(...this.preferred.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * There is no assumption that linked patient records have mutual links.
 */
export class PatientLink extends fhir.BackboneElement {
    /**
     * Default constructor for PatientLink - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'PatientLink';
        if (source['other']) {
            this.other = new fhir.Reference(source.other);
        }
        else {
            this.other = null;
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return LinkTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['other']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property other:fhir.Reference fhir: Patient.link.other:Reference", }));
        }
        if (this["other"]) {
            outcome.issue.push(...this.other.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:LinkTypeValueSetEnum fhir: Patient.link.type:code", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 */
export class Patient extends fhir.DomainResource {
    /**
     * Default constructor for Patient - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Patient';
        /**
         * An identifier for this patient.
         */
        this.identifier = [];
        /**
         * A patient may have multiple names with different uses or applicable periods. For animals, the name is a "HumanName" in the sense that is assigned and used by humans and has the same patterns.
         */
        this.name = [];
        /**
         * A Patient may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently and also to help with identification. The address might not go directly to the individual, but may reach another party that is able to proxy for the patient (i.e. home phone, or pet owner's phone).
         */
        this.telecom = [];
        this.__deceasedIsChoice = true;
        /**
         * Patient may have multiple addresses with different uses or applicable periods.
         */
        this.address = [];
        this.__multipleBirthIsChoice = true;
        /**
         * Guidelines:
         * * Use id photos, not clinical photos.
         * * Limit dimensions to thumbnail.
         * * Keep byte count low to ease resource updates.
         */
        this.photo = [];
        /**
         * Contact covers all kinds of contact parties: family members, business contacts, guardians, caregivers. Not applicable to register pedigree and family ties beyond use of having contact.
         */
        this.contact = [];
        /**
         * If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple Patient.Communication associations.   For animals, language is not a relevant field, and should be absent from the instance. If the Patient does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
         */
        this.communication = [];
        /**
         * This may be the primary care provider (in a GP context), or it may be a patient nominated care manager in a community/disability setting, or even organization that will provide people to perform the care provider roles.  It is not to be used to record Care Teams, these should be in a CareTeam resource that may be linked to the CarePlan or EpisodeOfCare resources.
         * Multiple GPs may be recorded against the patient for various reasons, such as a student that has his home GP listed along with the GP at university during the school semesters, or a "fly-in/fly-out" worker that has the onsite GP also included with his home GP to remain aware of medical issues.
         * Jurisdictions may decide that they can profile this down to 1 if desired, or 1 per type.
         */
        this.generalPractitioner = [];
        /**
         * There is no assumption that linked patient records have mutual links.
         */
        this.link = [];
        this.resourceType = 'Patient';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['active']) {
            this.active = new fhir.FhirBoolean({ value: source.active });
        }
        if (source['name']) {
            this.name = source.name.map((x) => new fhir.HumanName(x));
        }
        if (source['telecom']) {
            this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x));
        }
        if (source['gender']) {
            this.gender = source.gender;
        }
        if (source['birthDate']) {
            this.birthDate = new fhir.FhirDate({ value: source.birthDate });
        }
        if (source['deceased']) {
            this.deceased = source.deceased;
        }
        else if (source['deceasedBoolean']) {
            this.deceased = new fhir.FhirBoolean({ value: source.deceasedBoolean });
        }
        else if (source['deceasedDateTime']) {
            this.deceased = new fhir.FhirDateTime({ value: source.deceasedDateTime });
        }
        if (source['address']) {
            this.address = source.address.map((x) => new fhir.Address(x));
        }
        if (source['maritalStatus']) {
            this.maritalStatus = new fhir.CodeableConcept(source.maritalStatus);
        }
        if (source['multipleBirth']) {
            this.multipleBirth = source.multipleBirth;
        }
        else if (source['multipleBirthBoolean']) {
            this.multipleBirth = new fhir.FhirBoolean({ value: source.multipleBirthBoolean });
        }
        else if (source['multipleBirthInteger']) {
            this.multipleBirth = new fhir.FhirInteger({ value: source.multipleBirthInteger });
        }
        if (source['photo']) {
            this.photo = source.photo.map((x) => new fhir.Attachment(x));
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.PatientContact(x));
        }
        if (source['communication']) {
            this.communication = source.communication.map((x) => new fhir.PatientCommunication(x));
        }
        if (source['generalPractitioner']) {
            this.generalPractitioner = source.generalPractitioner.map((x) => new fhir.Reference(x));
        }
        if (source['managingOrganization']) {
            this.managingOrganization = new fhir.Reference(source.managingOrganization);
        }
        if (source['link']) {
            this.link = source.link.map((x) => new fhir.PatientLink(x));
        }
    }
    /**
     * Required-bound Value Set for gender
     */
    static genderRequiredValueSet() {
        return AdministrativeGenderValueSet;
    }
    /**
     * Extensible-bound Value Set for maritalStatus
     */
    static maritalStatusExtensibleValueSet() {
        return MaritalStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Patient' fhir: Patient.resourceType:'Patient'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["active"]) {
            outcome.issue.push(...this.active.doModelValidation().issue);
        }
        if (this["name"]) {
            this.name.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["telecom"]) {
            this.telecom.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["birthDate"]) {
            outcome.issue.push(...this.birthDate.doModelValidation().issue);
        }
        if (this["address"]) {
            this.address.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["maritalStatus"]) {
            outcome.issue.push(...this.maritalStatus.doModelValidation().issue);
        }
        if (this["photo"]) {
            this.photo.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["communication"]) {
            this.communication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["generalPractitioner"]) {
            this.generalPractitioner.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["managingOrganization"]) {
            outcome.issue.push(...this.managingOrganization.doModelValidation().issue);
        }
        if (this["link"]) {
            this.link.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Patient.js.map