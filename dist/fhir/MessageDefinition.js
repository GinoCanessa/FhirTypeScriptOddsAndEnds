// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: MessageDefinition
import * as fhir from '../fhir.js';
import { ResourceTypesValueSet, } from '../fhirValueSets/ResourceTypesValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { MessageSignificanceCategoryValueSet, } from '../fhirValueSets/MessageSignificanceCategoryValueSet.js';
import { MessageheaderResponseRequestValueSet, } from '../fhirValueSets/MessageheaderResponseRequestValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Identifies the resource (or resources) that are being addressed by the event.  For example, the Encounter for an admit message or two Account records for a merge.
 */
export class MessageDefinitionFocus extends fhir.BackboneElement {
    /**
     * Default constructor for MessageDefinitionFocus - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MessageDefinitionFocus';
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['profile']) {
            this.profile = new fhir.FhirCanonical({ value: source.profile });
        }
        if (source['min']) {
            this.min = new fhir.FhirUnsignedInt({ value: source.min });
        }
        else {
            this.min = null;
        }
        if (source['max']) {
            this.max = new fhir.FhirString({ value: source.max });
        }
    }
    /**
     * Required-bound Value Set for code
     */
    static codeRequiredValueSet() {
        return ResourceTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: MessageDefinition.focus.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["profile"]) {
            outcome.issue.push(...this.profile.doModelValidation().issue);
        }
        if (!this['min']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property min:fhir.FhirUnsignedInt fhir: MessageDefinition.focus.min:unsignedInt", }));
        }
        if (this["min"]) {
            outcome.issue.push(...this.min.doModelValidation().issue);
        }
        if (this["max"]) {
            outcome.issue.push(...this.max.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This indicates an application level response to "close" a transaction implicit in a particular request message.  To define a complete workflow scenario, look to the [[PlanDefinition]] resource which allows the definition of complex orchestrations, conditionality, etc.
 */
export class MessageDefinitionAllowedResponse extends fhir.BackboneElement {
    /**
     * Default constructor for MessageDefinitionAllowedResponse - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MessageDefinitionAllowedResponse';
        if (source['message']) {
            this.message = new fhir.FhirCanonical({ value: source.message });
        }
        else {
            this.message = null;
        }
        if (source['situation']) {
            this.situation = new fhir.FhirMarkdown({ value: source.situation });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['message']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property message:fhir.FhirCanonical fhir: MessageDefinition.allowedResponse.message:canonical", }));
        }
        if (this["message"]) {
            outcome.issue.push(...this.message.doModelValidation().issue);
        }
        if (this["situation"]) {
            outcome.issue.push(...this.situation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.
 */
export class MessageDefinition extends fhir.DomainResource {
    /**
     * Default constructor for MessageDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MessageDefinition';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this message definition outside of FHIR, where it is not possible to use the logical URI.
         */
        this.identifier = [];
        /**
         * A MessageDefinition that is superseded by this definition.
         */
        this.replaces = [];
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the message definition to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * It should be possible to use MessageDefinition to describe a message to be used by certain steps in a particular protocol as part of a PlanDefinition or ActivityDefinition.
         */
        this.parent = [];
        this.__eventIsChoice = true;
        /**
         * Identifies the resource (or resources) that are being addressed by the event.  For example, the Encounter for an admit message or two Account records for a merge.
         */
        this.focus = [];
        /**
         * This indicates an application level response to "close" a transaction implicit in a particular request message.  To define a complete workflow scenario, look to the [[PlanDefinition]] resource which allows the definition of complex orchestrations, conditionality, etc.
         */
        this.allowedResponse = [];
        /**
         * Canonical reference to a GraphDefinition. If a URL is provided, it is the canonical reference to a [GraphDefinition](graphdefinition.html) that it controls what resources are to be added to the bundle when building the document. The GraphDefinition can also specify profiles that apply to the various resources.
         */
        this.graph = [];
        this.resourceType = 'MessageDefinition';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['replaces']) {
            this.replaces = source.replaces.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        else {
            this.date = null;
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['base']) {
            this.base = new fhir.FhirCanonical({ value: source.base });
        }
        if (source['parent']) {
            this.parent = source.parent.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['event']) {
            this.event = source.event;
        }
        else if (source['eventCoding']) {
            this.event = new fhir.Coding(source.eventCoding);
        }
        else if (source['eventUri']) {
            this.event = new fhir.FhirUri({ value: source.eventUri });
        }
        else {
            this.event = null;
        }
        if (source['category']) {
            this.category = source.category;
        }
        if (source['focus']) {
            this.focus = source.focus.map((x) => new fhir.MessageDefinitionFocus(x));
        }
        if (source['responseRequired']) {
            this.responseRequired = source.responseRequired;
        }
        if (source['allowedResponse']) {
            this.allowedResponse = source.allowedResponse.map((x) => new fhir.MessageDefinitionAllowedResponse(x));
        }
        if (source['graph']) {
            this.graph = source.graph.map((x) => new fhir.FhirCanonical({ value: x }));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Required-bound Value Set for category
     */
    static categoryRequiredValueSet() {
        return MessageSignificanceCategoryValueSet;
    }
    /**
     * Required-bound Value Set for responseRequired
     */
    static responseRequiredRequiredValueSet() {
        return MessageheaderResponseRequestValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'MessageDefinition' fhir: MessageDefinition.resourceType:'MessageDefinition'", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (this["replaces"]) {
            this.replaces.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: MessageDefinition.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (!this['date']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property date:fhir.FhirDateTime fhir: MessageDefinition.date:dateTime", }));
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["base"]) {
            outcome.issue.push(...this.base.doModelValidation().issue);
        }
        if (this["parent"]) {
            this.parent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['event']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property event: fhir: MessageDefinition.event[x]:", }));
        }
        if (this["focus"]) {
            this.focus.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["allowedResponse"]) {
            this.allowedResponse.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["graph"]) {
            this.graph.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=MessageDefinition.js.map