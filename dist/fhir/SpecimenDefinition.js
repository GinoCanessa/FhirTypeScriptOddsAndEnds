// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: SpecimenDefinition
import * as fhir from '../fhir.js';
import { ContainerMaterialValueSet, } from '../fhirValueSets/ContainerMaterialValueSet.js';
import { SpecimenContainerTypeValueSet, } from '../fhirValueSets/SpecimenContainerTypeValueSet.js';
import { ContainerCapValueSet, } from '../fhirValueSets/ContainerCapValueSet.js';
import { HandlingConditionValueSet, } from '../fhirValueSets/HandlingConditionValueSet.js';
import { V20487ValueSet, } from '../fhirValueSets/V20487ValueSet.js';
import { SpecimenContainedPreferenceValueSet, } from '../fhirValueSets/SpecimenContainedPreferenceValueSet.js';
import { RejectionCriteriaValueSet, } from '../fhirValueSets/RejectionCriteriaValueSet.js';
import { PreparePatientPriorSpecimenCollectionValueSet, } from '../fhirValueSets/PreparePatientPriorSpecimenCollectionValueSet.js';
import { SpecimenCollectionValueSet, } from '../fhirValueSets/SpecimenCollectionValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
 */
export class SpecimenDefinitionTypeTestedContainerAdditive extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedContainerAdditive - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenDefinitionTypeTestedContainerAdditive';
        this.__additiveIsChoice = true;
        if (source['additive']) {
            this.additive = source.additive;
        }
        else if (source['additiveCodeableConcept']) {
            this.additive = new fhir.CodeableConcept(source.additiveCodeableConcept);
        }
        else if (source['additiveReference']) {
            this.additive = new fhir.Reference(source.additiveReference);
        }
        else {
            this.additive = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['additive']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property additive: fhir: SpecimenDefinition.typeTested.container.additive.additive[x]:", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The specimen's container.
 */
export class SpecimenDefinitionTypeTestedContainer extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedContainer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenDefinitionTypeTestedContainer';
        this.__minimumVolumeIsChoice = true;
        /**
         * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
         */
        this.additive = [];
        if (source['material']) {
            this.material = new fhir.CodeableConcept(source.material);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['cap']) {
            this.cap = new fhir.CodeableConcept(source.cap);
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['capacity']) {
            this.capacity = new fhir.Quantity(source.capacity);
        }
        if (source['minimumVolume']) {
            this.minimumVolume = source.minimumVolume;
        }
        else if (source['minimumVolumeQuantity']) {
            this.minimumVolume = new fhir.Quantity(source.minimumVolumeQuantity);
        }
        else if (source['minimumVolumeString']) {
            this.minimumVolume = new fhir.FhirString({ value: source.minimumVolumeString });
        }
        if (source['additive']) {
            this.additive = source.additive.map((x) => new fhir.SpecimenDefinitionTypeTestedContainerAdditive(x));
        }
        if (source['preparation']) {
            this.preparation = new fhir.FhirString({ value: source.preparation });
        }
    }
    /**
     * Example-bound Value Set for material
     */
    static materialExampleValueSet() {
        return ContainerMaterialValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return SpecimenContainerTypeValueSet;
    }
    /**
     * Example-bound Value Set for cap
     */
    static capExampleValueSet() {
        return ContainerCapValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["material"]) {
            outcome.issue.push(...this.material.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["cap"]) {
            outcome.issue.push(...this.cap.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["capacity"]) {
            outcome.issue.push(...this.capacity.doModelValidation().issue);
        }
        if (this["additive"]) {
            this.additive.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["preparation"]) {
            outcome.issue.push(...this.preparation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
 */
export class SpecimenDefinitionTypeTestedHandling extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedHandling - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenDefinitionTypeTestedHandling';
        if (source['temperatureQualifier']) {
            this.temperatureQualifier = new fhir.CodeableConcept(source.temperatureQualifier);
        }
        if (source['temperatureRange']) {
            this.temperatureRange = new fhir.Range(source.temperatureRange);
        }
        if (source['maxDuration']) {
            this.maxDuration = new fhir.Duration(source.maxDuration);
        }
        if (source['instruction']) {
            this.instruction = new fhir.FhirString({ value: source.instruction });
        }
    }
    /**
     * Example-bound Value Set for temperatureQualifier
     */
    static temperatureQualifierExampleValueSet() {
        return HandlingConditionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["temperatureQualifier"]) {
            outcome.issue.push(...this.temperatureQualifier.doModelValidation().issue);
        }
        if (this["temperatureRange"]) {
            outcome.issue.push(...this.temperatureRange.doModelValidation().issue);
        }
        if (this["maxDuration"]) {
            outcome.issue.push(...this.maxDuration.doModelValidation().issue);
        }
        if (this["instruction"]) {
            outcome.issue.push(...this.instruction.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Specimen conditioned in a container as expected by the testing laboratory.
 */
export class SpecimenDefinitionTypeTested extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTested - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenDefinitionTypeTested';
        /**
         * Criterion for rejection of the specimen in its container by the laboratory.
         */
        this.rejectionCriterion = [];
        /**
         * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
         */
        this.handling = [];
        if (source['isDerived']) {
            this.isDerived = new fhir.FhirBoolean({ value: source.isDerived });
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['preference']) {
            this.preference = source.preference;
        }
        else {
            this.preference = null;
        }
        if (source['container']) {
            this.container = new fhir.SpecimenDefinitionTypeTestedContainer(source.container);
        }
        if (source['requirement']) {
            this.requirement = new fhir.FhirString({ value: source.requirement });
        }
        if (source['retentionTime']) {
            this.retentionTime = new fhir.Duration(source.retentionTime);
        }
        if (source['rejectionCriterion']) {
            this.rejectionCriterion = source.rejectionCriterion.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['handling']) {
            this.handling = source.handling.map((x) => new fhir.SpecimenDefinitionTypeTestedHandling(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return V20487ValueSet;
    }
    /**
     * Required-bound Value Set for preference
     */
    static preferenceRequiredValueSet() {
        return SpecimenContainedPreferenceValueSet;
    }
    /**
     * Example-bound Value Set for rejectionCriterion
     */
    static rejectionCriterionExampleValueSet() {
        return RejectionCriteriaValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["isDerived"]) {
            outcome.issue.push(...this.isDerived.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (!this['preference']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property preference:SpecimenContainedPreferenceValueSetEnum fhir: SpecimenDefinition.typeTested.preference:code", }));
        }
        if (this["container"]) {
            outcome.issue.push(...this.container.doModelValidation().issue);
        }
        if (this["requirement"]) {
            outcome.issue.push(...this.requirement.doModelValidation().issue);
        }
        if (this["retentionTime"]) {
            outcome.issue.push(...this.retentionTime.doModelValidation().issue);
        }
        if (this["rejectionCriterion"]) {
            this.rejectionCriterion.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["handling"]) {
            this.handling.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A kind of specimen with associated set of requirements.
 */
export class SpecimenDefinition extends fhir.DomainResource {
    /**
     * Default constructor for SpecimenDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenDefinition';
        /**
         * Preparation of the patient for specimen collection.
         */
        this.patientPreparation = [];
        /**
         * The action to be performed for collecting the specimen.
         */
        this.collection = [];
        /**
         * Specimen conditioned in a container as expected by the testing laboratory.
         */
        this.typeTested = [];
        this.resourceType = 'SpecimenDefinition';
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['typeCollected']) {
            this.typeCollected = new fhir.CodeableConcept(source.typeCollected);
        }
        if (source['patientPreparation']) {
            this.patientPreparation = source.patientPreparation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['timeAspect']) {
            this.timeAspect = new fhir.FhirString({ value: source.timeAspect });
        }
        if (source['collection']) {
            this.collection = source.collection.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['typeTested']) {
            this.typeTested = source.typeTested.map((x) => new fhir.SpecimenDefinitionTypeTested(x));
        }
    }
    /**
     * Example-bound Value Set for typeCollected
     */
    static typeCollectedExampleValueSet() {
        return V20487ValueSet;
    }
    /**
     * Example-bound Value Set for patientPreparation
     */
    static patientPreparationExampleValueSet() {
        return PreparePatientPriorSpecimenCollectionValueSet;
    }
    /**
     * Example-bound Value Set for collection
     */
    static collectionExampleValueSet() {
        return SpecimenCollectionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'SpecimenDefinition' fhir: SpecimenDefinition.resourceType:'SpecimenDefinition'", }));
        }
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (this["typeCollected"]) {
            outcome.issue.push(...this.typeCollected.doModelValidation().issue);
        }
        if (this["patientPreparation"]) {
            this.patientPreparation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["timeAspect"]) {
            outcome.issue.push(...this.timeAspect.doModelValidation().issue);
        }
        if (this["collection"]) {
            this.collection.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["typeTested"]) {
            this.typeTested.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=SpecimenDefinition.js.map