// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: SpecimenDefinition
import * as fhir from '../fhir.js';
import { V20371ValueSet } from '../fhirValueSets/V20371ValueSet.js';
import { ContainerMaterialValueSet } from '../fhirValueSets/ContainerMaterialValueSet.js';
import { SpecimenContainerTypeValueSet } from '../fhirValueSets/SpecimenContainerTypeValueSet.js';
import { ContainerCapValueSet } from '../fhirValueSets/ContainerCapValueSet.js';
import { HandlingConditionValueSet } from '../fhirValueSets/HandlingConditionValueSet.js';
import { V20487ValueSet } from '../fhirValueSets/V20487ValueSet.js';
import { SpecimenContainedPreferenceValueSet } from '../fhirValueSets/SpecimenContainedPreferenceValueSet.js';
import { RejectionCriteriaValueSet } from '../fhirValueSets/RejectionCriteriaValueSet.js';
import { PreparePatientPriorSpecimenCollectionValueSet } from '../fhirValueSets/PreparePatientPriorSpecimenCollectionValueSet.js';
import { SpecimenCollectionValueSet } from '../fhirValueSets/SpecimenCollectionValueSet.js';
/**
 * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
 */
export class SpecimenDefinitionTypeTestedContainerAdditive extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedContainerAdditive - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['additiveCodeableConcept']) {
            this.additiveCodeableConcept = new fhir.CodeableConcept(source.additiveCodeableConcept);
        }
        if (source['additiveReference']) {
            this.additiveReference = new fhir.Reference(source.additiveReference);
        }
    }
    /**
     * Example-bound Value Set for additiveCodeableConcept
     */
    additiveCodeableConceptExampleValueSet() {
        return V20371ValueSet;
    }
    /**
     * Example-bound Value Set for additiveReference
     */
    additiveReferenceExampleValueSet() {
        return V20371ValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["additiveCodeableConcept"]) {
            results.push(...this.additiveCodeableConcept.doModelValidation());
        }
        if (this["additiveReference"]) {
            results.push(...this.additiveReference.doModelValidation());
        }
        return results;
    }
}
/**
 * The specimen's container.
 */
export class SpecimenDefinitionTypeTestedContainer extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedContainer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['material']) {
            this.material = new fhir.CodeableConcept(source.material);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['cap']) {
            this.cap = new fhir.CodeableConcept(source.cap);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['capacity']) {
            this.capacity = new fhir.Quantity(source.capacity);
        }
        if (source['minimumVolumeQuantity']) {
            this.minimumVolumeQuantity = new fhir.Quantity(source.minimumVolumeQuantity);
        }
        if (source['minimumVolumeString']) {
            this.minimumVolumeString = source.minimumVolumeString;
        }
        if (source['_minimumVolumeString']) {
            this._minimumVolumeString = new fhir.FhirElement(source._minimumVolumeString);
        }
        if (source['additive']) {
            this.additive = source.additive.map((x) => new fhir.SpecimenDefinitionTypeTestedContainerAdditive(x));
        }
        if (source['preparation']) {
            this.preparation = source.preparation;
        }
        if (source['_preparation']) {
            this._preparation = new fhir.FhirElement(source._preparation);
        }
    }
    /**
     * Example-bound Value Set for material
     */
    materialExampleValueSet() {
        return ContainerMaterialValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return SpecimenContainerTypeValueSet;
    }
    /**
     * Example-bound Value Set for cap
     */
    capExampleValueSet() {
        return ContainerCapValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["material"]) {
            results.push(...this.material.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["cap"]) {
            results.push(...this.cap.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["capacity"]) {
            results.push(...this.capacity.doModelValidation());
        }
        if (this["minimumVolumeQuantity"]) {
            results.push(...this.minimumVolumeQuantity.doModelValidation());
        }
        if (this["_minimumVolumeString"]) {
            results.push(...this._minimumVolumeString.doModelValidation());
        }
        if (this["additive"]) {
            this.additive.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_preparation"]) {
            results.push(...this._preparation.doModelValidation());
        }
        return results;
    }
}
/**
 * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
 */
export class SpecimenDefinitionTypeTestedHandling extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedHandling - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['temperatureQualifier']) {
            this.temperatureQualifier = new fhir.CodeableConcept(source.temperatureQualifier);
        }
        if (source['temperatureRange']) {
            this.temperatureRange = new fhir.Range(source.temperatureRange);
        }
        if (source['maxDuration']) {
            this.maxDuration = new fhir.Duration(source.maxDuration);
        }
        if (source['instruction']) {
            this.instruction = source.instruction;
        }
        if (source['_instruction']) {
            this._instruction = new fhir.FhirElement(source._instruction);
        }
    }
    /**
     * Example-bound Value Set for temperatureQualifier
     */
    temperatureQualifierExampleValueSet() {
        return HandlingConditionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["temperatureQualifier"]) {
            results.push(...this.temperatureQualifier.doModelValidation());
        }
        if (this["temperatureRange"]) {
            results.push(...this.temperatureRange.doModelValidation());
        }
        if (this["maxDuration"]) {
            results.push(...this.maxDuration.doModelValidation());
        }
        if (this["_instruction"]) {
            results.push(...this._instruction.doModelValidation());
        }
        return results;
    }
}
/**
 * Specimen conditioned in a container as expected by the testing laboratory.
 */
export class SpecimenDefinitionTypeTested extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTested - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['isDerived']) {
            this.isDerived = source.isDerived;
        }
        if (source['_isDerived']) {
            this._isDerived = new fhir.FhirElement(source._isDerived);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['preference']) {
            this.preference = source.preference;
        }
        else {
            this.preference = null;
        }
        if (source['_preference']) {
            this._preference = new fhir.FhirElement(source._preference);
        }
        if (source['container']) {
            this.container = new fhir.SpecimenDefinitionTypeTestedContainer(source.container);
        }
        if (source['requirement']) {
            this.requirement = source.requirement;
        }
        if (source['_requirement']) {
            this._requirement = new fhir.FhirElement(source._requirement);
        }
        if (source['retentionTime']) {
            this.retentionTime = new fhir.Duration(source.retentionTime);
        }
        if (source['rejectionCriterion']) {
            this.rejectionCriterion = source.rejectionCriterion.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['handling']) {
            this.handling = source.handling.map((x) => new fhir.SpecimenDefinitionTypeTestedHandling(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return V20487ValueSet;
    }
    /**
     * Required-bound Value Set for preference
     */
    preferenceRequiredValueSet() {
        return SpecimenContainedPreferenceValueSet;
    }
    /**
     * Example-bound Value Set for rejectionCriterion
     */
    rejectionCriterionExampleValueSet() {
        return RejectionCriteriaValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_isDerived"]) {
            results.push(...this._isDerived.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (!this["preference"]) {
            results.push(["preference", 'Missing required element: SpecimenDefinition.typeTested.preference']);
        }
        if (this["_preference"]) {
            results.push(...this._preference.doModelValidation());
        }
        if (this["container"]) {
            results.push(...this.container.doModelValidation());
        }
        if (this["_requirement"]) {
            results.push(...this._requirement.doModelValidation());
        }
        if (this["retentionTime"]) {
            results.push(...this.retentionTime.doModelValidation());
        }
        if (this["rejectionCriterion"]) {
            this.rejectionCriterion.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["handling"]) {
            this.handling.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * A kind of specimen with associated set of requirements.
 */
export class SpecimenDefinition extends fhir.DomainResource {
    /**
     * Default constructor for SpecimenDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'SpecimenDefinition';
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['typeCollected']) {
            this.typeCollected = new fhir.CodeableConcept(source.typeCollected);
        }
        if (source['patientPreparation']) {
            this.patientPreparation = source.patientPreparation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['timeAspect']) {
            this.timeAspect = source.timeAspect;
        }
        if (source['_timeAspect']) {
            this._timeAspect = new fhir.FhirElement(source._timeAspect);
        }
        if (source['collection']) {
            this.collection = source.collection.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['typeTested']) {
            this.typeTested = source.typeTested.map((x) => new fhir.SpecimenDefinitionTypeTested(x));
        }
    }
    /**
     * Example-bound Value Set for typeCollected
     */
    typeCollectedExampleValueSet() {
        return V20487ValueSet;
    }
    /**
     * Example-bound Value Set for patientPreparation
     */
    patientPreparationExampleValueSet() {
        return PreparePatientPriorSpecimenCollectionValueSet;
    }
    /**
     * Example-bound Value Set for collection
     */
    collectionExampleValueSet() {
        return SpecimenCollectionValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: SpecimenDefinition.resourceType']);
        }
        if (this["identifier"]) {
            results.push(...this.identifier.doModelValidation());
        }
        if (this["typeCollected"]) {
            results.push(...this.typeCollected.doModelValidation());
        }
        if (this["patientPreparation"]) {
            this.patientPreparation.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_timeAspect"]) {
            results.push(...this._timeAspect.doModelValidation());
        }
        if (this["collection"]) {
            this.collection.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["typeTested"]) {
            this.typeTested.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=SpecimenDefinition.js.map