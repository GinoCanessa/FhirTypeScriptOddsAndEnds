// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
 */
export class SpecimenDefinitionTypeTestedContainerAdditive extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedContainerAdditive - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["additiveCodeableConcept"]) {
            this.additiveCodeableConcept = new fhir.CodeableConcept(source.additiveCodeableConcept);
        }
        if (source["additiveReference"]) {
            this.additiveReference = new fhir.Reference(source.additiveReference);
        }
    }
    /**
     * Check if the current SpecimenDefinitionTypeTestedContainerAdditive contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenDefinitionTypeTestedContainerAdditive from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenDefinitionTypeTestedContainerAdditive(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenDefinitionTypeTestedContainerAdditive is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The specimen's container.
 */
export class SpecimenDefinitionTypeTestedContainer extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedContainer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["additive"]) {
            this.additive = source.additive.map((x) => new fhir.SpecimenDefinitionTypeTestedContainerAdditive(x));
        }
        if (source["cap"]) {
            this.cap = new fhir.CodeableConcept(source.cap);
        }
        if (source["capacity"]) {
            this.capacity = new fhir.Quantity(source.capacity);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["material"]) {
            this.material = new fhir.CodeableConcept(source.material);
        }
        if (source["minimumVolumeQuantity"]) {
            this.minimumVolumeQuantity = new fhir.Quantity(source.minimumVolumeQuantity);
        }
        if (source["minimumVolumeString"]) {
            this.minimumVolumeString = source.minimumVolumeString;
        }
        if (source["_minimumVolumeString"]) {
            this._minimumVolumeString = new fhir.FhirElement(source._minimumVolumeString);
        }
        if (source["preparation"]) {
            this.preparation = source.preparation;
        }
        if (source["_preparation"]) {
            this._preparation = new fhir.FhirElement(source._preparation);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current SpecimenDefinitionTypeTestedContainer contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenDefinitionTypeTestedContainer from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenDefinitionTypeTestedContainer(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenDefinitionTypeTestedContainer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
 */
export class SpecimenDefinitionTypeTestedHandling extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTestedHandling - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["instruction"]) {
            this.instruction = source.instruction;
        }
        if (source["_instruction"]) {
            this._instruction = new fhir.FhirElement(source._instruction);
        }
        if (source["maxDuration"]) {
            this.maxDuration = new fhir.Duration(source.maxDuration);
        }
        if (source["temperatureQualifier"]) {
            this.temperatureQualifier = new fhir.CodeableConcept(source.temperatureQualifier);
        }
        if (source["temperatureRange"]) {
            this.temperatureRange = new fhir.Range(source.temperatureRange);
        }
    }
    /**
     * Check if the current SpecimenDefinitionTypeTestedHandling contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenDefinitionTypeTestedHandling from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenDefinitionTypeTestedHandling(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenDefinitionTypeTestedHandling is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Specimen conditioned in a container as expected by the testing laboratory.
 */
export class SpecimenDefinitionTypeTested extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenDefinitionTypeTested - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["container"]) {
            this.container = new fhir.SpecimenDefinitionTypeTestedContainer(source.container);
        }
        if (source["handling"]) {
            this.handling = source.handling.map((x) => new fhir.SpecimenDefinitionTypeTestedHandling(x));
        }
        if (source["isDerived"]) {
            this.isDerived = source.isDerived;
        }
        if (source["_isDerived"]) {
            this._isDerived = new fhir.FhirElement(source._isDerived);
        }
        this.preference = null;
        if (source["preference"]) {
            this.preference = source.preference;
        }
        if (this.preference === undefined) {
            this.preference = null;
        }
        if (source["_preference"]) {
            this._preference = new fhir.FhirElement(source._preference);
        }
        if (source["rejectionCriterion"]) {
            this.rejectionCriterion = source.rejectionCriterion.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["requirement"]) {
            this.requirement = source.requirement;
        }
        if (source["_requirement"]) {
            this._requirement = new fhir.FhirElement(source._requirement);
        }
        if (source["retentionTime"]) {
            this.retentionTime = new fhir.Duration(source.retentionTime);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current SpecimenDefinitionTypeTested contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["preference"] === undefined) {
            missingElements.push("preference");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenDefinitionTypeTested from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenDefinitionTypeTested(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenDefinitionTypeTested is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A kind of specimen with associated set of requirements.
 */
export class SpecimenDefinition extends fhir.DomainResource {
    /**
     * Default constructor for SpecimenDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'SpecimenDefinition';
        if (source["collection"]) {
            this.collection = source.collection.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["identifier"]) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source["patientPreparation"]) {
            this.patientPreparation = source.patientPreparation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["timeAspect"]) {
            this.timeAspect = source.timeAspect;
        }
        if (source["_timeAspect"]) {
            this._timeAspect = new fhir.FhirElement(source._timeAspect);
        }
        if (source["typeCollected"]) {
            this.typeCollected = new fhir.CodeableConcept(source.typeCollected);
        }
        if (source["typeTested"]) {
            this.typeTested = source.typeTested.map((x) => new fhir.SpecimenDefinitionTypeTested(x));
        }
    }
    /**
     * Check if the current SpecimenDefinition contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenDefinition from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenDefinition(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenDefinition is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the SpecimenDefinition.typeTested.preference field
 */
export var SpecimenDefinitionTypeTestedPreferenceEnum;
(function (SpecimenDefinitionTypeTestedPreferenceEnum) {
    SpecimenDefinitionTypeTestedPreferenceEnum["PREFERRED"] = "preferred";
    SpecimenDefinitionTypeTestedPreferenceEnum["ALTERNATE"] = "alternate";
})(SpecimenDefinitionTypeTestedPreferenceEnum || (SpecimenDefinitionTypeTestedPreferenceEnum = {}));
//# sourceMappingURL=SpecimenDefinition.js.map