// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Describes the calibrations that have been performed or that are required to be performed.
 */
export class DeviceMetricCalibration extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceMetricCalibration - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["state"]) {
            this.state = source.state;
        }
        if (source["_state"]) {
            this._state = new fhir.FhirElement(source._state);
        }
        if (source["time"]) {
            this.time = source.time;
        }
        if (source["_time"]) {
            this._time = new fhir.FhirElement(source._time);
        }
        if (source["type"]) {
            this.type = source.type;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Check if the current DeviceMetricCalibration contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a DeviceMetricCalibration from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new DeviceMetricCalibration(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `DeviceMetricCalibration is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Describes a measurement, calculation or setting capability of a medical device.
 */
export class DeviceMetric extends fhir.DomainResource {
    /**
     * Default constructor for DeviceMetric - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'DeviceMetric';
        if (source["calibration"]) {
            this.calibration = source.calibration.map((x) => new fhir.DeviceMetricCalibration(x));
        }
        this.category = null;
        if (source["category"]) {
            this.category = source.category;
        }
        if (this.category === undefined) {
            this.category = null;
        }
        if (source["_category"]) {
            this._category = new fhir.FhirElement(source._category);
        }
        if (source["color"]) {
            this.color = source.color;
        }
        if (source["_color"]) {
            this._color = new fhir.FhirElement(source._color);
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["measurementPeriod"]) {
            this.measurementPeriod = new fhir.Timing(source.measurementPeriod);
        }
        if (source["operationalStatus"]) {
            this.operationalStatus = source.operationalStatus;
        }
        if (source["_operationalStatus"]) {
            this._operationalStatus = new fhir.FhirElement(source._operationalStatus);
        }
        if (source["parent"]) {
            this.parent = new fhir.Reference(source.parent);
        }
        if (source["source"]) {
            this.source = new fhir.Reference(source.source);
        }
        this.type = null;
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (this.type === undefined) {
            this.type = null;
        }
        if (source["unit"]) {
            this.unit = new fhir.CodeableConcept(source.unit);
        }
    }
    /**
     * Check if the current DeviceMetric contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["category"] === undefined) {
            missingElements.push("category");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a DeviceMetric from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new DeviceMetric(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `DeviceMetric is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the DeviceMetric.calibration.state field
 */
export var DeviceMetricCalibrationStateEnum;
(function (DeviceMetricCalibrationStateEnum) {
    DeviceMetricCalibrationStateEnum["NOT_CALIBRATED"] = "not-calibrated";
    DeviceMetricCalibrationStateEnum["CALIBRATION_REQUIRED"] = "calibration-required";
    DeviceMetricCalibrationStateEnum["CALIBRATED"] = "calibrated";
    DeviceMetricCalibrationStateEnum["UNSPECIFIED"] = "unspecified";
})(DeviceMetricCalibrationStateEnum || (DeviceMetricCalibrationStateEnum = {}));
/**
 * Code Values for the DeviceMetric.calibration.type field
 */
export var DeviceMetricCalibrationTypeEnum;
(function (DeviceMetricCalibrationTypeEnum) {
    DeviceMetricCalibrationTypeEnum["UNSPECIFIED"] = "unspecified";
    DeviceMetricCalibrationTypeEnum["OFFSET"] = "offset";
    DeviceMetricCalibrationTypeEnum["GAIN"] = "gain";
    DeviceMetricCalibrationTypeEnum["TWO_POINT"] = "two-point";
})(DeviceMetricCalibrationTypeEnum || (DeviceMetricCalibrationTypeEnum = {}));
/**
 * Code Values for the DeviceMetric.category field
 */
export var DeviceMetricCategoryEnum;
(function (DeviceMetricCategoryEnum) {
    DeviceMetricCategoryEnum["MEASUREMENT"] = "measurement";
    DeviceMetricCategoryEnum["SETTING"] = "setting";
    DeviceMetricCategoryEnum["CALCULATION"] = "calculation";
    DeviceMetricCategoryEnum["UNSPECIFIED"] = "unspecified";
})(DeviceMetricCategoryEnum || (DeviceMetricCategoryEnum = {}));
/**
 * Code Values for the DeviceMetric.color field
 */
export var DeviceMetricColorEnum;
(function (DeviceMetricColorEnum) {
    DeviceMetricColorEnum["BLACK"] = "black";
    DeviceMetricColorEnum["RED"] = "red";
    DeviceMetricColorEnum["GREEN"] = "green";
    DeviceMetricColorEnum["YELLOW"] = "yellow";
    DeviceMetricColorEnum["BLUE"] = "blue";
    DeviceMetricColorEnum["MAGENTA"] = "magenta";
    DeviceMetricColorEnum["CYAN"] = "cyan";
    DeviceMetricColorEnum["WHITE"] = "white";
})(DeviceMetricColorEnum || (DeviceMetricColorEnum = {}));
/**
 * Code Values for the DeviceMetric.operationalStatus field
 */
export var DeviceMetricOperationalStatusEnum;
(function (DeviceMetricOperationalStatusEnum) {
    DeviceMetricOperationalStatusEnum["ON"] = "on";
    DeviceMetricOperationalStatusEnum["OFF"] = "off";
    DeviceMetricOperationalStatusEnum["STANDBY"] = "standby";
    DeviceMetricOperationalStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
})(DeviceMetricOperationalStatusEnum || (DeviceMetricOperationalStatusEnum = {}));
//# sourceMappingURL=DeviceMetric.js.map