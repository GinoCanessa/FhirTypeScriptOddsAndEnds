// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: DeviceMetric
import * as fhir from '../fhir.js';
import { MetricCalibrationTypeValueSet } from '../fhirValueSets/MetricCalibrationTypeValueSet.js';
import { MetricCalibrationStateValueSet } from '../fhirValueSets/MetricCalibrationStateValueSet.js';
import { MetricOperationalStatusValueSet } from '../fhirValueSets/MetricOperationalStatusValueSet.js';
import { MetricColorValueSet } from '../fhirValueSets/MetricColorValueSet.js';
import { MetricCategoryValueSet } from '../fhirValueSets/MetricCategoryValueSet.js';
/**
 * Describes the calibrations that have been performed or that are required to be performed.
 */
export class DeviceMetricCalibration extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceMetricCalibration - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = source.type;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source['state']) {
            this.state = source.state;
        }
        if (source['_state']) {
            this._state = new fhir.FhirElement(source._state);
        }
        if (source['time']) {
            this.time = source.time;
        }
        if (source['_time']) {
            this._time = new fhir.FhirElement(source._time);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    typeRequiredValueSet() {
        return MetricCalibrationTypeValueSet;
    }
    /**
     * Required-bound Value Set for state
     */
    stateRequiredValueSet() {
        return MetricCalibrationStateValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        if (this["_state"]) {
            results.push(...this._state.doModelValidation());
        }
        if (this["_time"]) {
            results.push(...this._time.doModelValidation());
        }
        return results;
    }
}
/**
 * Describes a measurement, calculation or setting capability of a medical device.
 */
export class DeviceMetric extends fhir.DomainResource {
    /**
     * Default constructor for DeviceMetric - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'DeviceMetric';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['unit']) {
            this.unit = new fhir.CodeableConcept(source.unit);
        }
        if (source['source']) {
            this.source = new fhir.Reference(source.source);
        }
        if (source['parent']) {
            this.parent = new fhir.Reference(source.parent);
        }
        if (source['operationalStatus']) {
            this.operationalStatus = source.operationalStatus;
        }
        if (source['_operationalStatus']) {
            this._operationalStatus = new fhir.FhirElement(source._operationalStatus);
        }
        if (source['color']) {
            this.color = source.color;
        }
        if (source['_color']) {
            this._color = new fhir.FhirElement(source._color);
        }
        if (source['category']) {
            this.category = source.category;
        }
        else {
            this.category = null;
        }
        if (source['_category']) {
            this._category = new fhir.FhirElement(source._category);
        }
        if (source['measurementPeriod']) {
            this.measurementPeriod = new fhir.Timing(source.measurementPeriod);
        }
        if (source['calibration']) {
            this.calibration = source.calibration.map((x) => new fhir.DeviceMetricCalibration(x));
        }
    }
    /**
     * Required-bound Value Set for operationalStatus
     */
    operationalStatusRequiredValueSet() {
        return MetricOperationalStatusValueSet;
    }
    /**
     * Required-bound Value Set for color
     */
    colorRequiredValueSet() {
        return MetricColorValueSet;
    }
    /**
     * Required-bound Value Set for category
     */
    categoryRequiredValueSet() {
        return MetricCategoryValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: DeviceMetric.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["type"]) {
            results.push(["type", 'Missing required element: DeviceMetric.type']);
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["unit"]) {
            results.push(...this.unit.doModelValidation());
        }
        if (this["source"]) {
            results.push(...this.source.doModelValidation());
        }
        if (this["parent"]) {
            results.push(...this.parent.doModelValidation());
        }
        if (this["_operationalStatus"]) {
            results.push(...this._operationalStatus.doModelValidation());
        }
        if (this["_color"]) {
            results.push(...this._color.doModelValidation());
        }
        if (!this["category"]) {
            results.push(["category", 'Missing required element: DeviceMetric.category']);
        }
        if (this["_category"]) {
            results.push(...this._category.doModelValidation());
        }
        if (this["measurementPeriod"]) {
            results.push(...this.measurementPeriod.doModelValidation());
        }
        if (this["calibration"]) {
            this.calibration.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=DeviceMetric.js.map