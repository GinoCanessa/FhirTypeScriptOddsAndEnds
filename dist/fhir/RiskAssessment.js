// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: RiskAssessment
import * as fhir from '../fhir.js';
import { RiskProbabilityValueSet } from '../fhirValueSets/RiskProbabilityValueSet.js';
import { ObservationStatusValueSet } from '../fhirValueSets/ObservationStatusValueSet.js';
/**
 * Multiple repetitions can be used to identify the same type of outcome in different timeframes as well as different types of outcomes.
 */
export class RiskAssessmentPrediction extends fhir.BackboneElement {
    /**
     * Default constructor for RiskAssessmentPrediction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['outcome']) {
            this.outcome = new fhir.CodeableConcept(source.outcome);
        }
        if (source['probabilityDecimal']) {
            this.probabilityDecimal = source.probabilityDecimal;
        }
        if (source['_probabilityDecimal']) {
            this._probabilityDecimal = new fhir.FhirElement(source._probabilityDecimal);
        }
        if (source['probabilityRange']) {
            this.probabilityRange = new fhir.Range(source.probabilityRange);
        }
        if (source['qualitativeRisk']) {
            this.qualitativeRisk = new fhir.CodeableConcept(source.qualitativeRisk);
        }
        if (source['relativeRisk']) {
            this.relativeRisk = source.relativeRisk;
        }
        if (source['_relativeRisk']) {
            this._relativeRisk = new fhir.FhirElement(source._relativeRisk);
        }
        if (source['whenPeriod']) {
            this.whenPeriod = new fhir.Period(source.whenPeriod);
        }
        if (source['whenRange']) {
            this.whenRange = new fhir.Range(source.whenRange);
        }
        if (source['rationale']) {
            this.rationale = source.rationale;
        }
        if (source['_rationale']) {
            this._rationale = new fhir.FhirElement(source._rationale);
        }
    }
    /**
     * Example-bound Value Set for qualitativeRisk
     */
    qualitativeRiskExampleValueSet() {
        return RiskProbabilityValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["outcome"]) {
            results.push(...this.outcome.doModelValidation());
        }
        if (this["_probabilityDecimal"]) {
            results.push(...this._probabilityDecimal.doModelValidation());
        }
        if (this["probabilityRange"]) {
            results.push(...this.probabilityRange.doModelValidation());
        }
        if (this["qualitativeRisk"]) {
            results.push(...this.qualitativeRisk.doModelValidation());
        }
        if (this["_relativeRisk"]) {
            results.push(...this._relativeRisk.doModelValidation());
        }
        if (this["whenPeriod"]) {
            results.push(...this.whenPeriod.doModelValidation());
        }
        if (this["whenRange"]) {
            results.push(...this.whenRange.doModelValidation());
        }
        if (this["_rationale"]) {
            results.push(...this._rationale.doModelValidation());
        }
        return results;
    }
}
/**
 * An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
 */
export class RiskAssessment extends fhir.DomainResource {
    /**
     * Default constructor for RiskAssessment - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'RiskAssessment';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['basedOn']) {
            this.basedOn = new fhir.Reference(source.basedOn);
        }
        if (source['parent']) {
            this.parent = new fhir.Reference(source.parent);
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['method']) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        else {
            this.subject = null;
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['occurrenceDateTime']) {
            this.occurrenceDateTime = source.occurrenceDateTime;
        }
        if (source['_occurrenceDateTime']) {
            this._occurrenceDateTime = new fhir.FhirElement(source._occurrenceDateTime);
        }
        if (source['occurrencePeriod']) {
            this.occurrencePeriod = new fhir.Period(source.occurrencePeriod);
        }
        if (source['condition']) {
            this.condition = new fhir.Reference(source.condition);
        }
        if (source['performer']) {
            this.performer = new fhir.Reference(source.performer);
        }
        if (source['reasonCode']) {
            this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['reasonReference']) {
            this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x));
        }
        if (source['basis']) {
            this.basis = source.basis.map((x) => new fhir.Reference(x));
        }
        if (source['prediction']) {
            this.prediction = source.prediction.map((x) => new fhir.RiskAssessmentPrediction(x));
        }
        if (source['mitigation']) {
            this.mitigation = source.mitigation;
        }
        if (source['_mitigation']) {
            this._mitigation = new fhir.FhirElement(source._mitigation);
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    statusRequiredValueSet() {
        return ObservationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: RiskAssessment.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["basedOn"]) {
            results.push(...this.basedOn.doModelValidation());
        }
        if (this["parent"]) {
            results.push(...this.parent.doModelValidation());
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: RiskAssessment.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["method"]) {
            results.push(...this.method.doModelValidation());
        }
        if (this["code"]) {
            results.push(...this.code.doModelValidation());
        }
        if (!this["subject"]) {
            results.push(["subject", 'Missing required element: RiskAssessment.subject']);
        }
        if (this["subject"]) {
            results.push(...this.subject.doModelValidation());
        }
        if (this["encounter"]) {
            results.push(...this.encounter.doModelValidation());
        }
        if (this["_occurrenceDateTime"]) {
            results.push(...this._occurrenceDateTime.doModelValidation());
        }
        if (this["occurrencePeriod"]) {
            results.push(...this.occurrencePeriod.doModelValidation());
        }
        if (this["condition"]) {
            results.push(...this.condition.doModelValidation());
        }
        if (this["performer"]) {
            results.push(...this.performer.doModelValidation());
        }
        if (this["reasonCode"]) {
            this.reasonCode.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["reasonReference"]) {
            this.reasonReference.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["basis"]) {
            this.basis.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["prediction"]) {
            this.prediction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_mitigation"]) {
            results.push(...this._mitigation.doModelValidation());
        }
        if (this["note"]) {
            this.note.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=RiskAssessment.js.map