// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: ParameterDefinition
import * as fhir from '../fhir.js';
import { OperationParameterUseValueSet, } from '../fhirValueSets/OperationParameterUseValueSet.js';
import { AllTypesValueSet, } from '../fhirValueSets/AllTypesValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 */
export class ParameterDefinition extends fhir.FhirElement {
    /**
     * Default constructor for ParameterDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ParameterDefinition';
        if (source['name']) {
            this.name = new fhir.FhirCode({ value: source.name });
        }
        if (source['use']) {
            this.use = source.use;
        }
        else {
            this.use = null;
        }
        if (source['min']) {
            this.min = new fhir.FhirInteger({ value: source.min });
        }
        if (source['max']) {
            this.max = new fhir.FhirString({ value: source.max });
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirString({ value: source.documentation });
        }
        if (source['type']) {
            this.type = new fhir.FhirCode({ value: source.type });
        }
        else {
            this.type = null;
        }
        if (source['profile']) {
            this.profile = new fhir.FhirCanonical({ value: source.profile });
        }
    }
    /**
     * Required-bound Value Set for use
     */
    static useRequiredValueSet() {
        return OperationParameterUseValueSet;
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return AllTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['use']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property use:OperationParameterUseValueSetEnum fhir: ParameterDefinition.use:code", }));
        }
        if (this["min"]) {
            outcome.issue.push(...this.min.doModelValidation().issue);
        }
        if (this["max"]) {
            outcome.issue.push(...this.max.doModelValidation().issue);
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.FhirCode fhir: ParameterDefinition.type:code", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["profile"]) {
            outcome.issue.push(...this.profile.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=ParameterDefinition.js.map