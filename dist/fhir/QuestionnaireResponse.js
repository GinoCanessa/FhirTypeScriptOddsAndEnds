// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * The value is nested because we cannot have a repeating structure that has variable type.
 */
export class QuestionnaireResponseItemAnswer extends fhir.BackboneElement {
    /**
     * Default constructor for QuestionnaireResponseItemAnswer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["item"]) {
            this.item = source.item.map((x) => new fhir.QuestionnaireResponseItem(x));
        }
        if (source["valueBoolean"]) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"]) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source["valueDecimal"]) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"]) {
            this._valueDecimal = new fhir.FhirElement(source._valueDecimal);
        }
        if (source["valueInteger"]) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"]) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source["valueDate"]) {
            this.valueDate = source.valueDate;
        }
        if (source["_valueDate"]) {
            this._valueDate = new fhir.FhirElement(source._valueDate);
        }
        if (source["valueDateTime"]) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source["_valueDateTime"]) {
            this._valueDateTime = new fhir.FhirElement(source._valueDateTime);
        }
        if (source["valueTime"]) {
            this.valueTime = source.valueTime;
        }
        if (source["_valueTime"]) {
            this._valueTime = new fhir.FhirElement(source._valueTime);
        }
        if (source["valueString"]) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"]) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source["valueUri"]) {
            this.valueUri = source.valueUri;
        }
        if (source["_valueUri"]) {
            this._valueUri = new fhir.FhirElement(source._valueUri);
        }
        if (source["valueAttachment"]) {
            this.valueAttachment = new fhir.Attachment(source.valueAttachment);
        }
        if (source["valueCoding"]) {
            this.valueCoding = new fhir.Coding(source.valueCoding);
        }
        if (source["valueQuantity"]) {
            this.valueQuantity = new fhir.Quantity(source.valueQuantity);
        }
        if (source["valueReference"]) {
            this.valueReference = new fhir.Reference(source.valueReference);
        }
    }
    /**
     * Check if the current QuestionnaireResponseItemAnswer contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a QuestionnaireResponseItemAnswer from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new QuestionnaireResponseItemAnswer(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `QuestionnaireResponseItemAnswer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Groups cannot have answers and therefore must nest directly within item. When dealing with questions, nesting must occur within each answer because some questions may have multiple answers (and the nesting occurs for each answer).
 */
export class QuestionnaireResponseItem extends fhir.BackboneElement {
    /**
     * Default constructor for QuestionnaireResponseItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["answer"]) {
            this.answer = source.answer.map((x) => new fhir.QuestionnaireResponseItemAnswer(x));
        }
        if (source["definition"]) {
            this.definition = source.definition;
        }
        if (source["_definition"]) {
            this._definition = new fhir.FhirElement(source._definition);
        }
        if (source["item"]) {
            this.item = source.item.map((x) => new fhir.QuestionnaireResponseItem(x));
        }
        this.linkId = null;
        if (source["linkId"]) {
            this.linkId = source.linkId;
        }
        if (this.linkId === undefined) {
            this.linkId = null;
        }
        if (source["_linkId"]) {
            this._linkId = new fhir.FhirElement(source._linkId);
        }
        if (source["text"]) {
            this.text = source.text;
        }
        if (source["_text"]) {
            this._text = new fhir.FhirElement(source._text);
        }
    }
    /**
     * Check if the current QuestionnaireResponseItem contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["linkId"] === undefined) {
            missingElements.push("linkId");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a QuestionnaireResponseItem from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new QuestionnaireResponseItem(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `QuestionnaireResponseItem is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
 */
export class QuestionnaireResponse extends fhir.DomainResource {
    /**
     * Default constructor for QuestionnaireResponse - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'QuestionnaireResponse';
        if (source["author"]) {
            this.author = new fhir.Reference(source.author);
        }
        if (source["authored"]) {
            this.authored = source.authored;
        }
        if (source["_authored"]) {
            this._authored = new fhir.FhirElement(source._authored);
        }
        if (source["basedOn"]) {
            this.basedOn = source.basedOn.map((x) => new fhir.Reference(x));
        }
        if (source["encounter"]) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source["identifier"]) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source["item"]) {
            this.item = source.item.map((x) => new fhir.QuestionnaireResponseItem(x));
        }
        if (source["partOf"]) {
            this.partOf = source.partOf.map((x) => new fhir.Reference(x));
        }
        if (source["questionnaire"]) {
            this.questionnaire = source.questionnaire;
        }
        if (source["_questionnaire"]) {
            this._questionnaire = new fhir.FhirElement(source._questionnaire);
        }
        if (source["source"]) {
            this.source = new fhir.Reference(source.source);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["subject"]) {
            this.subject = new fhir.Reference(source.subject);
        }
    }
    /**
     * Check if the current QuestionnaireResponse contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a QuestionnaireResponse from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new QuestionnaireResponse(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `QuestionnaireResponse is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the QuestionnaireResponse.status field
 */
export var QuestionnaireResponseStatusEnum;
(function (QuestionnaireResponseStatusEnum) {
    QuestionnaireResponseStatusEnum["IN_PROGRESS"] = "in-progress";
    QuestionnaireResponseStatusEnum["COMPLETED"] = "completed";
    QuestionnaireResponseStatusEnum["AMENDED"] = "amended";
    QuestionnaireResponseStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    QuestionnaireResponseStatusEnum["STOPPED"] = "stopped";
})(QuestionnaireResponseStatusEnum || (QuestionnaireResponseStatusEnum = {}));
//# sourceMappingURL=QuestionnaireResponse.js.map