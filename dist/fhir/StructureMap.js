// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: StructureMap
import * as fhir from '../fhir.js';
import { MapModelModeValueSet, } from '../fhirValueSets/MapModelModeValueSet.js';
import { MapInputModeValueSet, } from '../fhirValueSets/MapInputModeValueSet.js';
import { MapSourceListModeValueSet, } from '../fhirValueSets/MapSourceListModeValueSet.js';
import { MapContextTypeValueSet, } from '../fhirValueSets/MapContextTypeValueSet.js';
import { MapTargetListModeValueSet, } from '../fhirValueSets/MapTargetListModeValueSet.js';
import { MapTransformValueSet, } from '../fhirValueSets/MapTransformValueSet.js';
import { MapGroupTypeModeValueSet, } from '../fhirValueSets/MapGroupTypeModeValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
 */
export class StructureMapStructure extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapStructure - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapStructure';
        if (source['url']) {
            this.url = new fhir.FhirCanonical({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['alias']) {
            this.alias = new fhir.FhirString({ value: source.alias });
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirString({ value: source.documentation });
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return MapModelModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirCanonical fhir: StructureMap.structure.url:canonical", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (!this['mode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property mode:MapModelModeValueSetEnum fhir: StructureMap.structure.mode:code", }));
        }
        if (this["alias"]) {
            outcome.issue.push(...this.alias.doModelValidation().issue);
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * If no inputs are named, then the entry mappings are type based.
 */
export class StructureMapGroupInput extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupInput - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroupInput';
        if (source['name']) {
            this.name = new fhir.FhirId({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['type']) {
            this.type = new fhir.FhirString({ value: source.type });
        }
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirString({ value: source.documentation });
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return MapInputModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirId fhir: StructureMap.group.input.name:id", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (!this['mode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property mode:MapInputModeValueSetEnum fhir: StructureMap.group.input.mode:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Source inputs to the mapping.
 */
export class StructureMapGroupRuleSource extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleSource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroupRuleSource';
        this.__defaultValueIsChoice = true;
        if (source['context']) {
            this.context = new fhir.FhirId({ value: source.context });
        }
        else {
            this.context = null;
        }
        if (source['min']) {
            this.min = new fhir.FhirInteger({ value: source.min });
        }
        if (source['max']) {
            this.max = new fhir.FhirString({ value: source.max });
        }
        if (source['type']) {
            this.type = new fhir.FhirString({ value: source.type });
        }
        if (source['defaultValue']) {
            this.defaultValue = source.defaultValue;
        }
        else if (source['defaultValueBase64Binary']) {
            this.defaultValue = new fhir.FhirBase64Binary({ value: source.defaultValueBase64Binary });
        }
        else if (source['defaultValueBoolean']) {
            this.defaultValue = new fhir.FhirBoolean({ value: source.defaultValueBoolean });
        }
        else if (source['defaultValueCanonical']) {
            this.defaultValue = new fhir.FhirCanonical({ value: source.defaultValueCanonical });
        }
        else if (source['defaultValueCode']) {
            this.defaultValue = new fhir.FhirCode({ value: source.defaultValueCode });
        }
        else if (source['defaultValueDate']) {
            this.defaultValue = new fhir.FhirDate({ value: source.defaultValueDate });
        }
        else if (source['defaultValueDateTime']) {
            this.defaultValue = new fhir.FhirDateTime({ value: source.defaultValueDateTime });
        }
        else if (source['defaultValueDecimal']) {
            this.defaultValue = new fhir.FhirDecimal({ value: source.defaultValueDecimal });
        }
        else if (source['defaultValueId']) {
            this.defaultValue = new fhir.FhirId({ value: source.defaultValueId });
        }
        else if (source['defaultValueInstant']) {
            this.defaultValue = new fhir.FhirInstant({ value: source.defaultValueInstant });
        }
        else if (source['defaultValueInteger']) {
            this.defaultValue = new fhir.FhirInteger({ value: source.defaultValueInteger });
        }
        else if (source['defaultValueMarkdown']) {
            this.defaultValue = new fhir.FhirMarkdown({ value: source.defaultValueMarkdown });
        }
        else if (source['defaultValueOid']) {
            this.defaultValue = new fhir.FhirOid({ value: source.defaultValueOid });
        }
        else if (source['defaultValuePositiveInt']) {
            this.defaultValue = new fhir.FhirPositiveInt({ value: source.defaultValuePositiveInt });
        }
        else if (source['defaultValueString']) {
            this.defaultValue = new fhir.FhirString({ value: source.defaultValueString });
        }
        else if (source['defaultValueTime']) {
            this.defaultValue = new fhir.FhirTime({ value: source.defaultValueTime });
        }
        else if (source['defaultValueUnsignedInt']) {
            this.defaultValue = new fhir.FhirUnsignedInt({ value: source.defaultValueUnsignedInt });
        }
        else if (source['defaultValueUri']) {
            this.defaultValue = new fhir.FhirUri({ value: source.defaultValueUri });
        }
        else if (source['defaultValueUrl']) {
            this.defaultValue = new fhir.FhirUrl({ value: source.defaultValueUrl });
        }
        else if (source['defaultValueUuid']) {
            this.defaultValue = new fhir.FhirUuid({ value: source.defaultValueUuid });
        }
        else if (source['defaultValueAddress']) {
            this.defaultValue = new fhir.Address(source.defaultValueAddress);
        }
        else if (source['defaultValueAge']) {
            this.defaultValue = new fhir.Age(source.defaultValueAge);
        }
        else if (source['defaultValueAnnotation']) {
            this.defaultValue = new fhir.Annotation(source.defaultValueAnnotation);
        }
        else if (source['defaultValueAttachment']) {
            this.defaultValue = new fhir.Attachment(source.defaultValueAttachment);
        }
        else if (source['defaultValueCodeableConcept']) {
            this.defaultValue = new fhir.CodeableConcept(source.defaultValueCodeableConcept);
        }
        else if (source['defaultValueCoding']) {
            this.defaultValue = new fhir.Coding(source.defaultValueCoding);
        }
        else if (source['defaultValueContactPoint']) {
            this.defaultValue = new fhir.ContactPoint(source.defaultValueContactPoint);
        }
        else if (source['defaultValueCount']) {
            this.defaultValue = new fhir.Count(source.defaultValueCount);
        }
        else if (source['defaultValueDistance']) {
            this.defaultValue = new fhir.Distance(source.defaultValueDistance);
        }
        else if (source['defaultValueDuration']) {
            this.defaultValue = new fhir.Duration(source.defaultValueDuration);
        }
        else if (source['defaultValueHumanName']) {
            this.defaultValue = new fhir.HumanName(source.defaultValueHumanName);
        }
        else if (source['defaultValueIdentifier']) {
            this.defaultValue = new fhir.Identifier(source.defaultValueIdentifier);
        }
        else if (source['defaultValueMoney']) {
            this.defaultValue = new fhir.Money(source.defaultValueMoney);
        }
        else if (source['defaultValuePeriod']) {
            this.defaultValue = new fhir.Period(source.defaultValuePeriod);
        }
        else if (source['defaultValueQuantity']) {
            this.defaultValue = new fhir.Quantity(source.defaultValueQuantity);
        }
        else if (source['defaultValueRange']) {
            this.defaultValue = new fhir.Range(source.defaultValueRange);
        }
        else if (source['defaultValueRatio']) {
            this.defaultValue = new fhir.Ratio(source.defaultValueRatio);
        }
        else if (source['defaultValueReference']) {
            this.defaultValue = new fhir.Reference(source.defaultValueReference);
        }
        else if (source['defaultValueSampledData']) {
            this.defaultValue = new fhir.SampledData(source.defaultValueSampledData);
        }
        else if (source['defaultValueSignature']) {
            this.defaultValue = new fhir.Signature(source.defaultValueSignature);
        }
        else if (source['defaultValueTiming']) {
            this.defaultValue = new fhir.Timing(source.defaultValueTiming);
        }
        else if (source['defaultValueContactDetail']) {
            this.defaultValue = new fhir.ContactDetail(source.defaultValueContactDetail);
        }
        else if (source['defaultValueContributor']) {
            this.defaultValue = new fhir.Contributor(source.defaultValueContributor);
        }
        else if (source['defaultValueDataRequirement']) {
            this.defaultValue = new fhir.DataRequirement(source.defaultValueDataRequirement);
        }
        else if (source['defaultValueExpression']) {
            this.defaultValue = new fhir.Expression(source.defaultValueExpression);
        }
        else if (source['defaultValueParameterDefinition']) {
            this.defaultValue = new fhir.ParameterDefinition(source.defaultValueParameterDefinition);
        }
        else if (source['defaultValueRelatedArtifact']) {
            this.defaultValue = new fhir.RelatedArtifact(source.defaultValueRelatedArtifact);
        }
        else if (source['defaultValueTriggerDefinition']) {
            this.defaultValue = new fhir.TriggerDefinition(source.defaultValueTriggerDefinition);
        }
        else if (source['defaultValueUsageContext']) {
            this.defaultValue = new fhir.UsageContext(source.defaultValueUsageContext);
        }
        else if (source['defaultValueDosage']) {
            this.defaultValue = new fhir.Dosage(source.defaultValueDosage);
        }
        else if (source['defaultValueMeta']) {
            this.defaultValue = new fhir.Meta(source.defaultValueMeta);
        }
        if (source['element']) {
            this.element = new fhir.FhirString({ value: source.element });
        }
        if (source['listMode']) {
            this.listMode = source.listMode;
        }
        if (source['variable']) {
            this.variable = new fhir.FhirId({ value: source.variable });
        }
        if (source['condition']) {
            this.condition = new fhir.FhirString({ value: source.condition });
        }
        if (source['check']) {
            this.check = new fhir.FhirString({ value: source.check });
        }
        if (source['logMessage']) {
            this.logMessage = new fhir.FhirString({ value: source.logMessage });
        }
    }
    /**
     * Required-bound Value Set for listMode
     */
    static listModeRequiredValueSet() {
        return MapSourceListModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['context']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property context:fhir.FhirId fhir: StructureMap.group.rule.source.context:id", }));
        }
        if (this["context"]) {
            outcome.issue.push(...this.context.doModelValidation().issue);
        }
        if (this["min"]) {
            outcome.issue.push(...this.min.doModelValidation().issue);
        }
        if (this["max"]) {
            outcome.issue.push(...this.max.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["element"]) {
            outcome.issue.push(...this.element.doModelValidation().issue);
        }
        if (this["variable"]) {
            outcome.issue.push(...this.variable.doModelValidation().issue);
        }
        if (this["condition"]) {
            outcome.issue.push(...this.condition.doModelValidation().issue);
        }
        if (this["check"]) {
            outcome.issue.push(...this.check.doModelValidation().issue);
        }
        if (this["logMessage"]) {
            outcome.issue.push(...this.logMessage.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Parameters to the transform.
 */
export class StructureMapGroupRuleTargetParameter extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleTargetParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroupRuleTargetParameter';
        this.__valueIsChoice = true;
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueId']) {
            this.value = new fhir.FhirId({ value: source.valueId });
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueInteger']) {
            this.value = new fhir.FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueDecimal']) {
            this.value = new fhir.FhirDecimal({ value: source.valueDecimal });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value: fhir: StructureMap.group.rule.target.parameter.value[x]:", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Content to create because of this mapping rule.
 */
export class StructureMapGroupRuleTarget extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleTarget - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroupRuleTarget';
        /**
         * If field is a list, how to manage the list.
         */
        this.listMode = [];
        /**
         * Parameters to the transform.
         */
        this.parameter = [];
        if (source['context']) {
            this.context = new fhir.FhirId({ value: source.context });
        }
        if (source['contextType']) {
            this.contextType = source.contextType;
        }
        if (source['element']) {
            this.element = new fhir.FhirString({ value: source.element });
        }
        if (source['variable']) {
            this.variable = new fhir.FhirId({ value: source.variable });
        }
        if (source['listMode']) {
            this.listMode = source.listMode.map((x) => x);
        }
        if (source['listRuleId']) {
            this.listRuleId = new fhir.FhirId({ value: source.listRuleId });
        }
        if (source['transform']) {
            this.transform = source.transform;
        }
        if (source['parameter']) {
            this.parameter = source.parameter.map((x) => new fhir.StructureMapGroupRuleTargetParameter(x));
        }
    }
    /**
     * Required-bound Value Set for contextType
     */
    static contextTypeRequiredValueSet() {
        return MapContextTypeValueSet;
    }
    /**
     * Required-bound Value Set for listMode
     */
    static listModeRequiredValueSet() {
        return MapTargetListModeValueSet;
    }
    /**
     * Required-bound Value Set for transform
     */
    static transformRequiredValueSet() {
        return MapTransformValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["context"]) {
            outcome.issue.push(...this.context.doModelValidation().issue);
        }
        if (this["element"]) {
            outcome.issue.push(...this.element.doModelValidation().issue);
        }
        if (this["variable"]) {
            outcome.issue.push(...this.variable.doModelValidation().issue);
        }
        if (this["listRuleId"]) {
            outcome.issue.push(...this.listRuleId.doModelValidation().issue);
        }
        if (this["parameter"]) {
            this.parameter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Which other rules to apply in the context of this rule.
 */
export class StructureMapGroupRuleDependent extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleDependent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroupRuleDependent';
        /**
         * Variable to pass to the rule or group.
         */
        this.variable = [];
        if (source['name']) {
            this.name = new fhir.FhirId({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['variable']) {
            this.variable = source.variable.map((x) => new fhir.FhirString({ value: x }));
        }
        else {
            this.variable = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirId fhir: StructureMap.group.rule.dependent.name:id", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['variable']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property variable:fhir.FhirString[] fhir: StructureMap.group.rule.dependent.variable:string", }));
        }
        else if (!Array.isArray(this.variable)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property variable:fhir.FhirString[] fhir: StructureMap.group.rule.dependent.variable:string", }));
        }
        else if (this.variable.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property variable:fhir.FhirString[] fhir: StructureMap.group.rule.dependent.variable:string", }));
        }
        if (this["variable"]) {
            this.variable.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Transform Rule from source to target.
 */
export class StructureMapGroupRule extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRule - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroupRule';
        /**
         * Source inputs to the mapping.
         */
        this.source = [];
        /**
         * Content to create because of this mapping rule.
         */
        this.target = [];
        /**
         * Rules contained in this rule.
         */
        this.rule = [];
        /**
         * Which other rules to apply in the context of this rule.
         */
        this.dependent = [];
        if (source['name']) {
            this.name = new fhir.FhirId({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['source']) {
            this.source = source.source.map((x) => new fhir.StructureMapGroupRuleSource(x));
        }
        else {
            this.source = null;
        }
        if (source['target']) {
            this.target = source.target.map((x) => new fhir.StructureMapGroupRuleTarget(x));
        }
        if (source['rule']) {
            this.rule = source.rule.map((x) => new fhir.StructureMapGroupRule(x));
        }
        if (source['dependent']) {
            this.dependent = source.dependent.map((x) => new fhir.StructureMapGroupRuleDependent(x));
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirString({ value: source.documentation });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirId fhir: StructureMap.group.rule.name:id", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['source']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property source:fhir.StructureMapGroupRuleSource[] fhir: StructureMap.group.rule.source:source", }));
        }
        else if (!Array.isArray(this.source)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property source:fhir.StructureMapGroupRuleSource[] fhir: StructureMap.group.rule.source:source", }));
        }
        else if (this.source.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property source:fhir.StructureMapGroupRuleSource[] fhir: StructureMap.group.rule.source:source", }));
        }
        if (this["source"]) {
            this.source.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["target"]) {
            this.target.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["rule"]) {
            this.rule.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["dependent"]) {
            this.dependent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Organizes the mapping into manageable chunks for human review/ease of maintenance.
 */
export class StructureMapGroup extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMapGroup';
        /**
         * If no inputs are named, then the entry mappings are type based.
         */
        this.input = [];
        /**
         * Transform Rule from source to target.
         */
        this.rule = [];
        if (source['name']) {
            this.name = new fhir.FhirId({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['extends']) {
            this.extends = new fhir.FhirId({ value: source.extends });
        }
        if (source['typeMode']) {
            this.typeMode = source.typeMode;
        }
        else {
            this.typeMode = null;
        }
        if (source['documentation']) {
            this.documentation = new fhir.FhirString({ value: source.documentation });
        }
        if (source['input']) {
            this.input = source.input.map((x) => new fhir.StructureMapGroupInput(x));
        }
        else {
            this.input = null;
        }
        if (source['rule']) {
            this.rule = source.rule.map((x) => new fhir.StructureMapGroupRule(x));
        }
        else {
            this.rule = null;
        }
    }
    /**
     * Required-bound Value Set for typeMode
     */
    static typeModeRequiredValueSet() {
        return MapGroupTypeModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirId fhir: StructureMap.group.name:id", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["extends"]) {
            outcome.issue.push(...this.extends.doModelValidation().issue);
        }
        if (!this['typeMode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property typeMode:MapGroupTypeModeValueSetEnum fhir: StructureMap.group.typeMode:code", }));
        }
        if (this["documentation"]) {
            outcome.issue.push(...this.documentation.doModelValidation().issue);
        }
        if (!this['input']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property input:fhir.StructureMapGroupInput[] fhir: StructureMap.group.input:input", }));
        }
        else if (!Array.isArray(this.input)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property input:fhir.StructureMapGroupInput[] fhir: StructureMap.group.input:input", }));
        }
        else if (this.input.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property input:fhir.StructureMapGroupInput[] fhir: StructureMap.group.input:input", }));
        }
        if (this["input"]) {
            this.input.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['rule']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property rule:fhir.StructureMapGroupRule[] fhir: StructureMap.group.rule:rule", }));
        }
        else if (!Array.isArray(this.rule)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property rule:fhir.StructureMapGroupRule[] fhir: StructureMap.group.rule:rule", }));
        }
        else if (this.rule.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property rule:fhir.StructureMapGroupRule[] fhir: StructureMap.group.rule:rule", }));
        }
        if (this["rule"]) {
            this.rule.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A Map of relationships between 2 structures that can be used to transform data.
 */
export class StructureMap extends fhir.DomainResource {
    /**
     * Default constructor for StructureMap - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'StructureMap';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this structure map outside of FHIR, where it is not possible to use the logical URI.
         */
        this.identifier = [];
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the structure map to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
         */
        this.structure = [];
        /**
         * Other maps used by this map (canonical URLs).
         */
        this.import = [];
        /**
         * Organizes the mapping into manageable chunks for human review/ease of maintenance.
         */
        this.group = [];
        this.resourceType = 'StructureMap';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['structure']) {
            this.structure = source.structure.map((x) => new fhir.StructureMapStructure(x));
        }
        if (source['import']) {
            this.import = source.import.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['group']) {
            this.group = source.group.map((x) => new fhir.StructureMapGroup(x));
        }
        else {
            this.group = null;
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'StructureMap' fhir: StructureMap.resourceType:'StructureMap'", }));
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: StructureMap.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: StructureMap.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: StructureMap.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["structure"]) {
            this.structure.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["import"]) {
            this.import.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['group']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property group:fhir.StructureMapGroup[] fhir: StructureMap.group:group", }));
        }
        else if (!Array.isArray(this.group)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property group:fhir.StructureMapGroup[] fhir: StructureMap.group:group", }));
        }
        else if (this.group.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property group:fhir.StructureMapGroup[] fhir: StructureMap.group:group", }));
        }
        if (this["group"]) {
            this.group.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=StructureMap.js.map