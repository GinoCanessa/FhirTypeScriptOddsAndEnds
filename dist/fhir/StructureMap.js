// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
 */
export class StructureMapStructure extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapStructure - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["alias"]) {
            this.alias = source.alias;
        }
        if (source["_alias"]) {
            this._alias = new fhir.FhirElement(source._alias);
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.mode = null;
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (this.mode === undefined) {
            this.mode = null;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        this.url = null;
        if (source["url"]) {
            this.url = source.url;
        }
        if (this.url === undefined) {
            this.url = null;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Check if the current StructureMapStructure contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["mode"] === undefined) {
            missingElements.push("mode");
        }
        if (this["url"] === undefined) {
            missingElements.push("url");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapStructure from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapStructure(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapStructure is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * If no inputs are named, then the entry mappings are type based.
 */
export class StructureMapGroupInput extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupInput - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.mode = null;
        if (source["mode"]) {
            this.mode = source.mode;
        }
        if (this.mode === undefined) {
            this.mode = null;
        }
        if (source["_mode"]) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["type"]) {
            this.type = source.type;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Check if the current StructureMapGroupInput contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["mode"] === undefined) {
            missingElements.push("mode");
        }
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroupInput from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroupInput(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroupInput is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Source inputs to the mapping.
 */
export class StructureMapGroupRuleSource extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleSource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["check"]) {
            this.check = source.check;
        }
        if (source["_check"]) {
            this._check = new fhir.FhirElement(source._check);
        }
        if (source["condition"]) {
            this.condition = source.condition;
        }
        if (source["_condition"]) {
            this._condition = new fhir.FhirElement(source._condition);
        }
        this.context = null;
        if (source["context"]) {
            this.context = source.context;
        }
        if (this.context === undefined) {
            this.context = null;
        }
        if (source["_context"]) {
            this._context = new fhir.FhirElement(source._context);
        }
        if (source["defaultValueBase64Binary"]) {
            this.defaultValueBase64Binary = source.defaultValueBase64Binary;
        }
        if (source["_defaultValueBase64Binary"]) {
            this._defaultValueBase64Binary = new fhir.FhirElement(source._defaultValueBase64Binary);
        }
        if (source["defaultValueBoolean"]) {
            this.defaultValueBoolean = source.defaultValueBoolean;
        }
        if (source["_defaultValueBoolean"]) {
            this._defaultValueBoolean = new fhir.FhirElement(source._defaultValueBoolean);
        }
        if (source["defaultValueCanonical"]) {
            this.defaultValueCanonical = source.defaultValueCanonical;
        }
        if (source["_defaultValueCanonical"]) {
            this._defaultValueCanonical = new fhir.FhirElement(source._defaultValueCanonical);
        }
        if (source["defaultValueCode"]) {
            this.defaultValueCode = source.defaultValueCode;
        }
        if (source["_defaultValueCode"]) {
            this._defaultValueCode = new fhir.FhirElement(source._defaultValueCode);
        }
        if (source["defaultValueDate"]) {
            this.defaultValueDate = source.defaultValueDate;
        }
        if (source["_defaultValueDate"]) {
            this._defaultValueDate = new fhir.FhirElement(source._defaultValueDate);
        }
        if (source["defaultValueDateTime"]) {
            this.defaultValueDateTime = source.defaultValueDateTime;
        }
        if (source["_defaultValueDateTime"]) {
            this._defaultValueDateTime = new fhir.FhirElement(source._defaultValueDateTime);
        }
        if (source["defaultValueDecimal"]) {
            this.defaultValueDecimal = source.defaultValueDecimal;
        }
        if (source["_defaultValueDecimal"]) {
            this._defaultValueDecimal = new fhir.FhirElement(source._defaultValueDecimal);
        }
        if (source["defaultValueId"]) {
            this.defaultValueId = source.defaultValueId;
        }
        if (source["_defaultValueId"]) {
            this._defaultValueId = new fhir.FhirElement(source._defaultValueId);
        }
        if (source["defaultValueInstant"]) {
            this.defaultValueInstant = source.defaultValueInstant;
        }
        if (source["_defaultValueInstant"]) {
            this._defaultValueInstant = new fhir.FhirElement(source._defaultValueInstant);
        }
        if (source["defaultValueInteger"]) {
            this.defaultValueInteger = source.defaultValueInteger;
        }
        if (source["_defaultValueInteger"]) {
            this._defaultValueInteger = new fhir.FhirElement(source._defaultValueInteger);
        }
        if (source["defaultValueMarkdown"]) {
            this.defaultValueMarkdown = source.defaultValueMarkdown;
        }
        if (source["_defaultValueMarkdown"]) {
            this._defaultValueMarkdown = new fhir.FhirElement(source._defaultValueMarkdown);
        }
        if (source["defaultValueOid"]) {
            this.defaultValueOid = source.defaultValueOid;
        }
        if (source["_defaultValueOid"]) {
            this._defaultValueOid = new fhir.FhirElement(source._defaultValueOid);
        }
        if (source["defaultValuePositiveInt"]) {
            this.defaultValuePositiveInt = source.defaultValuePositiveInt;
        }
        if (source["_defaultValuePositiveInt"]) {
            this._defaultValuePositiveInt = new fhir.FhirElement(source._defaultValuePositiveInt);
        }
        if (source["defaultValueString"]) {
            this.defaultValueString = source.defaultValueString;
        }
        if (source["_defaultValueString"]) {
            this._defaultValueString = new fhir.FhirElement(source._defaultValueString);
        }
        if (source["defaultValueTime"]) {
            this.defaultValueTime = source.defaultValueTime;
        }
        if (source["_defaultValueTime"]) {
            this._defaultValueTime = new fhir.FhirElement(source._defaultValueTime);
        }
        if (source["defaultValueUnsignedInt"]) {
            this.defaultValueUnsignedInt = source.defaultValueUnsignedInt;
        }
        if (source["_defaultValueUnsignedInt"]) {
            this._defaultValueUnsignedInt = new fhir.FhirElement(source._defaultValueUnsignedInt);
        }
        if (source["defaultValueUri"]) {
            this.defaultValueUri = source.defaultValueUri;
        }
        if (source["_defaultValueUri"]) {
            this._defaultValueUri = new fhir.FhirElement(source._defaultValueUri);
        }
        if (source["defaultValueUrl"]) {
            this.defaultValueUrl = source.defaultValueUrl;
        }
        if (source["_defaultValueUrl"]) {
            this._defaultValueUrl = new fhir.FhirElement(source._defaultValueUrl);
        }
        if (source["defaultValueUuid"]) {
            this.defaultValueUuid = source.defaultValueUuid;
        }
        if (source["_defaultValueUuid"]) {
            this._defaultValueUuid = new fhir.FhirElement(source._defaultValueUuid);
        }
        if (source["defaultValueAddress"]) {
            this.defaultValueAddress = new fhir.Address(source.defaultValueAddress);
        }
        if (source["defaultValueAge"]) {
            this.defaultValueAge = new fhir.Age(source.defaultValueAge);
        }
        if (source["defaultValueAnnotation"]) {
            this.defaultValueAnnotation = new fhir.Annotation(source.defaultValueAnnotation);
        }
        if (source["defaultValueAttachment"]) {
            this.defaultValueAttachment = new fhir.Attachment(source.defaultValueAttachment);
        }
        if (source["defaultValueCodeableConcept"]) {
            this.defaultValueCodeableConcept = new fhir.CodeableConcept(source.defaultValueCodeableConcept);
        }
        if (source["defaultValueCoding"]) {
            this.defaultValueCoding = new fhir.Coding(source.defaultValueCoding);
        }
        if (source["defaultValueContactPoint"]) {
            this.defaultValueContactPoint = new fhir.ContactPoint(source.defaultValueContactPoint);
        }
        if (source["defaultValueCount"]) {
            this.defaultValueCount = new fhir.Count(source.defaultValueCount);
        }
        if (source["defaultValueDistance"]) {
            this.defaultValueDistance = new fhir.Distance(source.defaultValueDistance);
        }
        if (source["defaultValueDuration"]) {
            this.defaultValueDuration = new fhir.Duration(source.defaultValueDuration);
        }
        if (source["defaultValueHumanName"]) {
            this.defaultValueHumanName = new fhir.HumanName(source.defaultValueHumanName);
        }
        if (source["defaultValueIdentifier"]) {
            this.defaultValueIdentifier = new fhir.Identifier(source.defaultValueIdentifier);
        }
        if (source["defaultValueMoney"]) {
            this.defaultValueMoney = new fhir.Money(source.defaultValueMoney);
        }
        if (source["defaultValuePeriod"]) {
            this.defaultValuePeriod = new fhir.Period(source.defaultValuePeriod);
        }
        if (source["defaultValueQuantity"]) {
            this.defaultValueQuantity = new fhir.Quantity(source.defaultValueQuantity);
        }
        if (source["defaultValueRange"]) {
            this.defaultValueRange = new fhir.Range(source.defaultValueRange);
        }
        if (source["defaultValueRatio"]) {
            this.defaultValueRatio = new fhir.Ratio(source.defaultValueRatio);
        }
        if (source["defaultValueReference"]) {
            this.defaultValueReference = new fhir.Reference(source.defaultValueReference);
        }
        if (source["defaultValueSampledData"]) {
            this.defaultValueSampledData = new fhir.SampledData(source.defaultValueSampledData);
        }
        if (source["defaultValueSignature"]) {
            this.defaultValueSignature = new fhir.Signature(source.defaultValueSignature);
        }
        if (source["defaultValueTiming"]) {
            this.defaultValueTiming = new fhir.Timing(source.defaultValueTiming);
        }
        if (source["defaultValueContactDetail"]) {
            this.defaultValueContactDetail = new fhir.ContactDetail(source.defaultValueContactDetail);
        }
        if (source["defaultValueContributor"]) {
            this.defaultValueContributor = new fhir.Contributor(source.defaultValueContributor);
        }
        if (source["defaultValueDataRequirement"]) {
            this.defaultValueDataRequirement = new fhir.DataRequirement(source.defaultValueDataRequirement);
        }
        if (source["defaultValueExpression"]) {
            this.defaultValueExpression = new fhir.Expression(source.defaultValueExpression);
        }
        if (source["defaultValueParameterDefinition"]) {
            this.defaultValueParameterDefinition = new fhir.ParameterDefinition(source.defaultValueParameterDefinition);
        }
        if (source["defaultValueRelatedArtifact"]) {
            this.defaultValueRelatedArtifact = new fhir.RelatedArtifact(source.defaultValueRelatedArtifact);
        }
        if (source["defaultValueTriggerDefinition"]) {
            this.defaultValueTriggerDefinition = new fhir.TriggerDefinition(source.defaultValueTriggerDefinition);
        }
        if (source["defaultValueUsageContext"]) {
            this.defaultValueUsageContext = new fhir.UsageContext(source.defaultValueUsageContext);
        }
        if (source["defaultValueDosage"]) {
            this.defaultValueDosage = new fhir.Dosage(source.defaultValueDosage);
        }
        if (source["defaultValueMeta"]) {
            this.defaultValueMeta = new fhir.Meta(source.defaultValueMeta);
        }
        if (source["element"]) {
            this.element = source.element;
        }
        if (source["_element"]) {
            this._element = new fhir.FhirElement(source._element);
        }
        if (source["listMode"]) {
            this.listMode = source.listMode;
        }
        if (source["_listMode"]) {
            this._listMode = new fhir.FhirElement(source._listMode);
        }
        if (source["logMessage"]) {
            this.logMessage = source.logMessage;
        }
        if (source["_logMessage"]) {
            this._logMessage = new fhir.FhirElement(source._logMessage);
        }
        if (source["max"]) {
            this.max = source.max;
        }
        if (source["_max"]) {
            this._max = new fhir.FhirElement(source._max);
        }
        if (source["min"]) {
            this.min = source.min;
        }
        if (source["_min"]) {
            this._min = new fhir.FhirElement(source._min);
        }
        if (source["type"]) {
            this.type = source.type;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source["variable"]) {
            this.variable = source.variable;
        }
        if (source["_variable"]) {
            this._variable = new fhir.FhirElement(source._variable);
        }
    }
    /**
     * Check if the current StructureMapGroupRuleSource contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["context"] === undefined) {
            missingElements.push("context");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroupRuleSource from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroupRuleSource(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroupRuleSource is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Parameters to the transform.
 */
export class StructureMapGroupRuleTargetParameter extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleTargetParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["valueId"]) {
            this.valueId = source.valueId;
        }
        if (source["_valueId"]) {
            this._valueId = new fhir.FhirElement(source._valueId);
        }
        if (source["valueString"]) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"]) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source["valueBoolean"]) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"]) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source["valueInteger"]) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"]) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source["valueDecimal"]) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"]) {
            this._valueDecimal = new fhir.FhirElement(source._valueDecimal);
        }
    }
    /**
     * Check if the current StructureMapGroupRuleTargetParameter contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroupRuleTargetParameter from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroupRuleTargetParameter(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroupRuleTargetParameter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Content to create because of this mapping rule.
 */
export class StructureMapGroupRuleTarget extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleTarget - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["context"]) {
            this.context = source.context;
        }
        if (source["_context"]) {
            this._context = new fhir.FhirElement(source._context);
        }
        if (source["contextType"]) {
            this.contextType = source.contextType;
        }
        if (source["_contextType"]) {
            this._contextType = new fhir.FhirElement(source._contextType);
        }
        if (source["element"]) {
            this.element = source.element;
        }
        if (source["_element"]) {
            this._element = new fhir.FhirElement(source._element);
        }
        if (source["listMode"]) {
            this.listMode = source.listMode.map((x) => (x));
        }
        if (source["_listMode"]) {
            this._listMode = source._listMode.map((x) => new fhir.FhirElement(x));
        }
        if (source["listRuleId"]) {
            this.listRuleId = source.listRuleId;
        }
        if (source["_listRuleId"]) {
            this._listRuleId = new fhir.FhirElement(source._listRuleId);
        }
        if (source["parameter"]) {
            this.parameter = source.parameter.map((x) => new fhir.StructureMapGroupRuleTargetParameter(x));
        }
        if (source["transform"]) {
            this.transform = source.transform;
        }
        if (source["_transform"]) {
            this._transform = new fhir.FhirElement(source._transform);
        }
        if (source["variable"]) {
            this.variable = source.variable;
        }
        if (source["_variable"]) {
            this._variable = new fhir.FhirElement(source._variable);
        }
    }
    /**
     * Check if the current StructureMapGroupRuleTarget contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroupRuleTarget from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroupRuleTarget(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroupRuleTarget is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Which other rules to apply in the context of this rule.
 */
export class StructureMapGroupRuleDependent extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRuleDependent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        this.variable = null;
        if (source["variable"]) {
            this.variable = source.variable.map((x) => (x));
        }
        if (this.variable === undefined) {
            this.variable = null;
        }
        if (source["_variable"]) {
            this._variable = source._variable.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Check if the current StructureMapGroupRuleDependent contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        if ((!this["variable"]) || (this["variable"].length === 0)) {
            missingElements.push("variable");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroupRuleDependent from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroupRuleDependent(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroupRuleDependent is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Transform Rule from source to target.
 */
export class StructureMapGroupRule extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroupRule - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["dependent"]) {
            this.dependent = source.dependent.map((x) => new fhir.StructureMapGroupRuleDependent(x));
        }
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["rule"]) {
            this.rule = source.rule.map((x) => new fhir.StructureMapGroupRule(x));
        }
        this.source = null;
        if (source["source"]) {
            this.source = source.source.map((x) => new fhir.StructureMapGroupRuleSource(x));
        }
        if (this.source === undefined) {
            this.source = null;
        }
        if (source["target"]) {
            this.target = source.target.map((x) => new fhir.StructureMapGroupRuleTarget(x));
        }
    }
    /**
     * Check if the current StructureMapGroupRule contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        if ((!this["source"]) || (this["source"].length === 0)) {
            missingElements.push("source");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroupRule from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroupRule(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroupRule is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Organizes the mapping into manageable chunks for human review/ease of maintenance.
 */
export class StructureMapGroup extends fhir.BackboneElement {
    /**
     * Default constructor for StructureMapGroup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["documentation"]) {
            this.documentation = source.documentation;
        }
        if (source["_documentation"]) {
            this._documentation = new fhir.FhirElement(source._documentation);
        }
        if (source["extends"]) {
            this.extends = source.extends;
        }
        if (source["_extends"]) {
            this._extends = new fhir.FhirElement(source._extends);
        }
        this.input = null;
        if (source["input"]) {
            this.input = source.input.map((x) => new fhir.StructureMapGroupInput(x));
        }
        if (this.input === undefined) {
            this.input = null;
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        this.rule = null;
        if (source["rule"]) {
            this.rule = source.rule.map((x) => new fhir.StructureMapGroupRule(x));
        }
        if (this.rule === undefined) {
            this.rule = null;
        }
        this.typeMode = null;
        if (source["typeMode"]) {
            this.typeMode = source.typeMode;
        }
        if (this.typeMode === undefined) {
            this.typeMode = null;
        }
        if (source["_typeMode"]) {
            this._typeMode = new fhir.FhirElement(source._typeMode);
        }
    }
    /**
     * Check if the current StructureMapGroup contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["input"]) || (this["input"].length === 0)) {
            missingElements.push("input");
        }
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        if ((!this["rule"]) || (this["rule"].length === 0)) {
            missingElements.push("rule");
        }
        if (this["typeMode"] === undefined) {
            missingElements.push("typeMode");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMapGroup from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMapGroup(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMapGroup is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A Map of relationships between 2 structures that can be used to transform data.
 */
export class StructureMap extends fhir.DomainResource {
    /**
     * Default constructor for StructureMap - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'StructureMap';
        if (source["contact"]) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source["copyright"]) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"]) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source["date"]) {
            this.date = source.date;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["experimental"]) {
            this.experimental = source.experimental;
        }
        if (source["_experimental"]) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        this.group = null;
        if (source["group"]) {
            this.group = source.group.map((x) => new fhir.StructureMapGroup(x));
        }
        if (this.group === undefined) {
            this.group = null;
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["import"]) {
            this.import = source.import.map((x) => (x));
        }
        if (source["_import"]) {
            this._import = source._import.map((x) => new fhir.FhirElement(x));
        }
        if (source["jurisdiction"]) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["publisher"]) {
            this.publisher = source.publisher;
        }
        if (source["_publisher"]) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source["purpose"]) {
            this.purpose = source.purpose;
        }
        if (source["_purpose"]) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["structure"]) {
            this.structure = source.structure.map((x) => new fhir.StructureMapStructure(x));
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        this.url = null;
        if (source["url"]) {
            this.url = source.url;
        }
        if (this.url === undefined) {
            this.url = null;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["useContext"]) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current StructureMap contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["group"]) || (this["group"].length === 0)) {
            missingElements.push("group");
        }
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        if (this["url"] === undefined) {
            missingElements.push("url");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a StructureMap from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new StructureMap(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `StructureMap is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the StructureMap.structure.mode field
 */
export var StructureMapStructureModeEnum;
(function (StructureMapStructureModeEnum) {
    StructureMapStructureModeEnum["SOURCE"] = "source";
    StructureMapStructureModeEnum["QUERIED"] = "queried";
    StructureMapStructureModeEnum["TARGET"] = "target";
    StructureMapStructureModeEnum["PRODUCED"] = "produced";
})(StructureMapStructureModeEnum || (StructureMapStructureModeEnum = {}));
/**
 * Code Values for the StructureMap.group.input.mode field
 */
export var StructureMapGroupInputModeEnum;
(function (StructureMapGroupInputModeEnum) {
    StructureMapGroupInputModeEnum["SOURCE"] = "source";
    StructureMapGroupInputModeEnum["TARGET"] = "target";
})(StructureMapGroupInputModeEnum || (StructureMapGroupInputModeEnum = {}));
/**
 * Code Values for the StructureMap.group.rule.source.listMode field
 */
export var StructureMapGroupRuleSourceListModeEnum;
(function (StructureMapGroupRuleSourceListModeEnum) {
    StructureMapGroupRuleSourceListModeEnum["FIRST"] = "first";
    StructureMapGroupRuleSourceListModeEnum["NOT_FIRST"] = "not_first";
    StructureMapGroupRuleSourceListModeEnum["LAST"] = "last";
    StructureMapGroupRuleSourceListModeEnum["NOT_LAST"] = "not_last";
    StructureMapGroupRuleSourceListModeEnum["ONLY_ONE"] = "only_one";
})(StructureMapGroupRuleSourceListModeEnum || (StructureMapGroupRuleSourceListModeEnum = {}));
/**
 * Code Values for the StructureMap.group.rule.target.contextType field
 */
export var StructureMapGroupRuleTargetContextTypeEnum;
(function (StructureMapGroupRuleTargetContextTypeEnum) {
    StructureMapGroupRuleTargetContextTypeEnum["TYPE"] = "type";
    StructureMapGroupRuleTargetContextTypeEnum["VARIABLE"] = "variable";
})(StructureMapGroupRuleTargetContextTypeEnum || (StructureMapGroupRuleTargetContextTypeEnum = {}));
/**
 * Code Values for the StructureMap.group.rule.target.listMode field
 */
export var StructureMapGroupRuleTargetListModeEnum;
(function (StructureMapGroupRuleTargetListModeEnum) {
    StructureMapGroupRuleTargetListModeEnum["FIRST"] = "first";
    StructureMapGroupRuleTargetListModeEnum["SHARE"] = "share";
    StructureMapGroupRuleTargetListModeEnum["LAST"] = "last";
    StructureMapGroupRuleTargetListModeEnum["COLLATE"] = "collate";
})(StructureMapGroupRuleTargetListModeEnum || (StructureMapGroupRuleTargetListModeEnum = {}));
/**
 * Code Values for the StructureMap.group.rule.target.transform field
 */
export var StructureMapGroupRuleTargetTransformEnum;
(function (StructureMapGroupRuleTargetTransformEnum) {
    StructureMapGroupRuleTargetTransformEnum["CREATE"] = "create";
    StructureMapGroupRuleTargetTransformEnum["COPY"] = "copy";
    StructureMapGroupRuleTargetTransformEnum["TRUNCATE"] = "truncate";
    StructureMapGroupRuleTargetTransformEnum["ESCAPE"] = "escape";
    StructureMapGroupRuleTargetTransformEnum["CAST"] = "cast";
    StructureMapGroupRuleTargetTransformEnum["APPEND"] = "append";
    StructureMapGroupRuleTargetTransformEnum["TRANSLATE"] = "translate";
    StructureMapGroupRuleTargetTransformEnum["REFERENCE"] = "reference";
    StructureMapGroupRuleTargetTransformEnum["DATEOP"] = "dateOp";
    StructureMapGroupRuleTargetTransformEnum["UUID"] = "uuid";
    StructureMapGroupRuleTargetTransformEnum["POINTER"] = "pointer";
    StructureMapGroupRuleTargetTransformEnum["EVALUATE"] = "evaluate";
    StructureMapGroupRuleTargetTransformEnum["CC"] = "cc";
    StructureMapGroupRuleTargetTransformEnum["C"] = "c";
    StructureMapGroupRuleTargetTransformEnum["QTY"] = "qty";
    StructureMapGroupRuleTargetTransformEnum["ID"] = "id";
    StructureMapGroupRuleTargetTransformEnum["CP"] = "cp";
})(StructureMapGroupRuleTargetTransformEnum || (StructureMapGroupRuleTargetTransformEnum = {}));
/**
 * Code Values for the StructureMap.group.typeMode field
 */
export var StructureMapGroupTypeModeEnum;
(function (StructureMapGroupTypeModeEnum) {
    StructureMapGroupTypeModeEnum["NONE"] = "none";
    StructureMapGroupTypeModeEnum["TYPES"] = "types";
    StructureMapGroupTypeModeEnum["TYPE_AND_TYPES"] = "type-and-types";
})(StructureMapGroupTypeModeEnum || (StructureMapGroupTypeModeEnum = {}));
/**
 * Code Values for the StructureMap.status field
 */
export var StructureMapStatusEnum;
(function (StructureMapStatusEnum) {
    StructureMapStatusEnum["DRAFT"] = "draft";
    StructureMapStatusEnum["ACTIVE"] = "active";
    StructureMapStatusEnum["RETIRED"] = "retired";
    StructureMapStatusEnum["UNKNOWN"] = "unknown";
})(StructureMapStatusEnum || (StructureMapStatusEnum = {}));
//# sourceMappingURL=StructureMap.js.map