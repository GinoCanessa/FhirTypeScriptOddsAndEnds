// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: MedicinalProductPackaged
import * as fhir from '../fhir.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Batch numbering.
 */
export class MedicinalProductPackagedBatchIdentifier extends fhir.BackboneElement {
    /**
     * Default constructor for MedicinalProductPackagedBatchIdentifier - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MedicinalProductPackagedBatchIdentifier';
        if (source['outerPackaging']) {
            this.outerPackaging = new fhir.Identifier(source.outerPackaging);
        }
        else {
            this.outerPackaging = null;
        }
        if (source['immediatePackaging']) {
            this.immediatePackaging = new fhir.Identifier(source.immediatePackaging);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['outerPackaging']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property outerPackaging:fhir.Identifier fhir: MedicinalProductPackaged.batchIdentifier.outerPackaging:Identifier", }));
        }
        if (this["outerPackaging"]) {
            outcome.issue.push(...this.outerPackaging.doModelValidation().issue);
        }
        if (this["immediatePackaging"]) {
            outcome.issue.push(...this.immediatePackaging.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A packaging item, as a contained for medicine, possibly with other packaging items within.
 */
export class MedicinalProductPackagedPackageItem extends fhir.BackboneElement {
    /**
     * Default constructor for MedicinalProductPackagedPackageItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MedicinalProductPackagedPackageItem';
        /**
         * Including possibly Data Carrier Identifier.
         */
        this.identifier = [];
        /**
         * Material type of the package item.
         */
        this.material = [];
        /**
         * A possible alternate material for the packaging.
         */
        this.alternateMaterial = [];
        /**
         * A device accompanying a medicinal product.
         */
        this.device = [];
        /**
         * The manufactured item as contained in the packaged medicinal product.
         */
        this.manufacturedItem = [];
        /**
         * Allows containers within containers.
         */
        this.packageItem = [];
        /**
         * Other codeable characteristics.
         */
        this.otherCharacteristics = [];
        /**
         * Shelf Life and storage information.
         */
        this.shelfLifeStorage = [];
        /**
         * Manufacturer of this Package Item.
         */
        this.manufacturer = [];
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        else {
            this.quantity = null;
        }
        if (source['material']) {
            this.material = source.material.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['alternateMaterial']) {
            this.alternateMaterial = source.alternateMaterial.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['device']) {
            this.device = source.device.map((x) => new fhir.Reference(x));
        }
        if (source['manufacturedItem']) {
            this.manufacturedItem = source.manufacturedItem.map((x) => new fhir.Reference(x));
        }
        if (source['packageItem']) {
            this.packageItem = source.packageItem.map((x) => new fhir.MedicinalProductPackagedPackageItem(x));
        }
        if (source['physicalCharacteristics']) {
            this.physicalCharacteristics = new fhir.ProdCharacteristic(source.physicalCharacteristics);
        }
        if (source['otherCharacteristics']) {
            this.otherCharacteristics = source.otherCharacteristics.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['shelfLifeStorage']) {
            this.shelfLifeStorage = source.shelfLifeStorage.map((x) => new fhir.ProductShelfLife(x));
        }
        if (source['manufacturer']) {
            this.manufacturer = source.manufacturer.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: MedicinalProductPackaged.packageItem.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (!this['quantity']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property quantity:fhir.Quantity fhir: MedicinalProductPackaged.packageItem.quantity:Quantity", }));
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["material"]) {
            this.material.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["alternateMaterial"]) {
            this.alternateMaterial.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["device"]) {
            this.device.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["manufacturedItem"]) {
            this.manufacturedItem.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["packageItem"]) {
            this.packageItem.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["physicalCharacteristics"]) {
            outcome.issue.push(...this.physicalCharacteristics.doModelValidation().issue);
        }
        if (this["otherCharacteristics"]) {
            this.otherCharacteristics.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["shelfLifeStorage"]) {
            this.shelfLifeStorage.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["manufacturer"]) {
            this.manufacturer.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A medicinal product in a container or package.
 */
export class MedicinalProductPackaged extends fhir.DomainResource {
    /**
     * Default constructor for MedicinalProductPackaged - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MedicinalProductPackaged';
        /**
         * Unique identifier.
         */
        this.identifier = [];
        /**
         * The product with this is a pack for.
         */
        this.subject = [];
        /**
         * Marketing information.
         */
        this.marketingStatus = [];
        /**
         * Manufacturer of this Package Item.
         */
        this.manufacturer = [];
        /**
         * Batch numbering.
         */
        this.batchIdentifier = [];
        /**
         * A packaging item, as a contained for medicine, possibly with other packaging items within.
         */
        this.packageItem = [];
        this.resourceType = 'MedicinalProductPackaged';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['subject']) {
            this.subject = source.subject.map((x) => new fhir.Reference(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['legalStatusOfSupply']) {
            this.legalStatusOfSupply = new fhir.CodeableConcept(source.legalStatusOfSupply);
        }
        if (source['marketingStatus']) {
            this.marketingStatus = source.marketingStatus.map((x) => new fhir.MarketingStatus(x));
        }
        if (source['marketingAuthorization']) {
            this.marketingAuthorization = new fhir.Reference(source.marketingAuthorization);
        }
        if (source['manufacturer']) {
            this.manufacturer = source.manufacturer.map((x) => new fhir.Reference(x));
        }
        if (source['batchIdentifier']) {
            this.batchIdentifier = source.batchIdentifier.map((x) => new fhir.MedicinalProductPackagedBatchIdentifier(x));
        }
        if (source['packageItem']) {
            this.packageItem = source.packageItem.map((x) => new fhir.MedicinalProductPackagedPackageItem(x));
        }
        else {
            this.packageItem = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'MedicinalProductPackaged' fhir: MedicinalProductPackaged.resourceType:'MedicinalProductPackaged'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["subject"]) {
            this.subject.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["legalStatusOfSupply"]) {
            outcome.issue.push(...this.legalStatusOfSupply.doModelValidation().issue);
        }
        if (this["marketingStatus"]) {
            this.marketingStatus.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["marketingAuthorization"]) {
            outcome.issue.push(...this.marketingAuthorization.doModelValidation().issue);
        }
        if (this["manufacturer"]) {
            this.manufacturer.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["batchIdentifier"]) {
            this.batchIdentifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['packageItem']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property packageItem:fhir.MedicinalProductPackagedPackageItem[] fhir: MedicinalProductPackaged.packageItem:packageItem", }));
        }
        else if (!Array.isArray(this.packageItem)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property packageItem:fhir.MedicinalProductPackagedPackageItem[] fhir: MedicinalProductPackaged.packageItem:packageItem", }));
        }
        else if (this.packageItem.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property packageItem:fhir.MedicinalProductPackagedPackageItem[] fhir: MedicinalProductPackaged.packageItem:packageItem", }));
        }
        if (this["packageItem"]) {
            this.packageItem.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=MedicinalProductPackaged.js.map