// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * The current status is always found in the current version of the resource, not the status history.
 */
export class EncounterStatusHistory extends fhir.BackboneElement {
    /**
     * Default constructor for EncounterStatusHistory - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.period = null;
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (this.period === undefined) {
            this.period = null;
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
    }
    /**
     * Check if the current EncounterStatusHistory contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["period"] === undefined) {
            missingElements.push("period");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a EncounterStatusHistory from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new EncounterStatusHistory(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `EncounterStatusHistory is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
 */
export class EncounterClassHistory extends fhir.BackboneElement {
    /**
     * Default constructor for EncounterClassHistory - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.class = null;
        if (source["class"]) {
            this.class = new fhir.Coding(source.class);
        }
        if (this.class === undefined) {
            this.class = null;
        }
        this.period = null;
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (this.period === undefined) {
            this.period = null;
        }
    }
    /**
     * Check if the current EncounterClassHistory contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["class"] === undefined) {
            missingElements.push("class");
        }
        if (this["period"] === undefined) {
            missingElements.push("period");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a EncounterClassHistory from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new EncounterClassHistory(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `EncounterClassHistory is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The list of people responsible for providing the service.
 */
export class EncounterParticipant extends fhir.BackboneElement {
    /**
     * Default constructor for EncounterParticipant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["individual"]) {
            this.individual = new fhir.Reference(source.individual);
        }
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (source["type"]) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Check if the current EncounterParticipant contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a EncounterParticipant from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new EncounterParticipant(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `EncounterParticipant is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The list of diagnosis relevant to this encounter.
 */
export class EncounterDiagnosis extends fhir.BackboneElement {
    /**
     * Default constructor for EncounterDiagnosis - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.condition = null;
        if (source["condition"]) {
            this.condition = new fhir.Reference(source.condition);
        }
        if (this.condition === undefined) {
            this.condition = null;
        }
        if (source["rank"]) {
            this.rank = source.rank;
        }
        if (source["_rank"]) {
            this._rank = new fhir.FhirElement(source._rank);
        }
        if (source["use"]) {
            this.use = new fhir.CodeableConcept(source.use);
        }
    }
    /**
     * Check if the current EncounterDiagnosis contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["condition"] === undefined) {
            missingElements.push("condition");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a EncounterDiagnosis from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new EncounterDiagnosis(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `EncounterDiagnosis is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An Encounter may cover more than just the inpatient stay. Contexts such as outpatients, community clinics, and aged care facilities are also included.
 * The duration recorded in the period of this encounter covers the entire scope of this hospitalization record.
 */
export class EncounterHospitalization extends fhir.BackboneElement {
    /**
     * Default constructor for EncounterHospitalization - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["admitSource"]) {
            this.admitSource = new fhir.CodeableConcept(source.admitSource);
        }
        if (source["destination"]) {
            this.destination = new fhir.Reference(source.destination);
        }
        if (source["dietPreference"]) {
            this.dietPreference = source.dietPreference.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["dischargeDisposition"]) {
            this.dischargeDisposition = new fhir.CodeableConcept(source.dischargeDisposition);
        }
        if (source["origin"]) {
            this.origin = new fhir.Reference(source.origin);
        }
        if (source["preAdmissionIdentifier"]) {
            this.preAdmissionIdentifier = new fhir.Identifier(source.preAdmissionIdentifier);
        }
        if (source["reAdmission"]) {
            this.reAdmission = new fhir.CodeableConcept(source.reAdmission);
        }
        if (source["specialArrangement"]) {
            this.specialArrangement = source.specialArrangement.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["specialCourtesy"]) {
            this.specialCourtesy = source.specialCourtesy.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Check if the current EncounterHospitalization contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a EncounterHospitalization from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new EncounterHospitalization(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `EncounterHospitalization is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Virtual encounters can be recorded in the Encounter by specifying a location reference to a location of type "kind" such as "client's home" and an encounter.class = "virtual".
 */
export class EncounterLocation extends fhir.BackboneElement {
    /**
     * Default constructor for EncounterLocation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.location = null;
        if (source["location"]) {
            this.location = new fhir.Reference(source.location);
        }
        if (this.location === undefined) {
            this.location = null;
        }
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (source["physicalType"]) {
            this.physicalType = new fhir.CodeableConcept(source.physicalType);
        }
        if (source["status"]) {
            this.status = source.status;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
    }
    /**
     * Check if the current EncounterLocation contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["location"] === undefined) {
            missingElements.push("location");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a EncounterLocation from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new EncounterLocation(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `EncounterLocation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
 */
export class Encounter extends fhir.DomainResource {
    /**
     * Default constructor for Encounter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Encounter';
        if (source["account"]) {
            this.account = source.account.map((x) => new fhir.Reference(x));
        }
        if (source["appointment"]) {
            this.appointment = source.appointment.map((x) => new fhir.Reference(x));
        }
        if (source["basedOn"]) {
            this.basedOn = source.basedOn.map((x) => new fhir.Reference(x));
        }
        this.class = null;
        if (source["class"]) {
            this.class = new fhir.Coding(source.class);
        }
        if (this.class === undefined) {
            this.class = null;
        }
        if (source["classHistory"]) {
            this.classHistory = source.classHistory.map((x) => new fhir.EncounterClassHistory(x));
        }
        if (source["diagnosis"]) {
            this.diagnosis = source.diagnosis.map((x) => new fhir.EncounterDiagnosis(x));
        }
        if (source["episodeOfCare"]) {
            this.episodeOfCare = source.episodeOfCare.map((x) => new fhir.Reference(x));
        }
        if (source["hospitalization"]) {
            this.hospitalization = new fhir.EncounterHospitalization(source.hospitalization);
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["length"]) {
            this.length = new fhir.Duration(source.length);
        }
        if (source["location"]) {
            this.location = source.location.map((x) => new fhir.EncounterLocation(x));
        }
        if (source["participant"]) {
            this.participant = source.participant.map((x) => new fhir.EncounterParticipant(x));
        }
        if (source["partOf"]) {
            this.partOf = new fhir.Reference(source.partOf);
        }
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (source["priority"]) {
            this.priority = new fhir.CodeableConcept(source.priority);
        }
        if (source["reasonCode"]) {
            this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["reasonReference"]) {
            this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x));
        }
        if (source["serviceProvider"]) {
            this.serviceProvider = new fhir.Reference(source.serviceProvider);
        }
        if (source["serviceType"]) {
            this.serviceType = new fhir.CodeableConcept(source.serviceType);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["statusHistory"]) {
            this.statusHistory = source.statusHistory.map((x) => new fhir.EncounterStatusHistory(x));
        }
        if (source["subject"]) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source["type"]) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Check if the current Encounter contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["class"] === undefined) {
            missingElements.push("class");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Encounter from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new Encounter(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `Encounter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the Encounter.statusHistory.status field
 */
export var EncounterStatusHistoryStatusEnum;
(function (EncounterStatusHistoryStatusEnum) {
    EncounterStatusHistoryStatusEnum["PLANNED"] = "planned";
    EncounterStatusHistoryStatusEnum["ARRIVED"] = "arrived";
    EncounterStatusHistoryStatusEnum["TRIAGED"] = "triaged";
    EncounterStatusHistoryStatusEnum["IN_PROGRESS"] = "in-progress";
    EncounterStatusHistoryStatusEnum["ONLEAVE"] = "onleave";
    EncounterStatusHistoryStatusEnum["FINISHED"] = "finished";
    EncounterStatusHistoryStatusEnum["CANCELLED"] = "cancelled";
    EncounterStatusHistoryStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    EncounterStatusHistoryStatusEnum["UNKNOWN"] = "unknown";
})(EncounterStatusHistoryStatusEnum || (EncounterStatusHistoryStatusEnum = {}));
/**
 * Code Values for the Encounter.location.status field
 */
export var EncounterLocationStatusEnum;
(function (EncounterLocationStatusEnum) {
    EncounterLocationStatusEnum["PLANNED"] = "planned";
    EncounterLocationStatusEnum["ACTIVE"] = "active";
    EncounterLocationStatusEnum["RESERVED"] = "reserved";
    EncounterLocationStatusEnum["COMPLETED"] = "completed";
})(EncounterLocationStatusEnum || (EncounterLocationStatusEnum = {}));
/**
 * Code Values for the Encounter.status field
 */
export var EncounterStatusEnum;
(function (EncounterStatusEnum) {
    EncounterStatusEnum["PLANNED"] = "planned";
    EncounterStatusEnum["ARRIVED"] = "arrived";
    EncounterStatusEnum["TRIAGED"] = "triaged";
    EncounterStatusEnum["IN_PROGRESS"] = "in-progress";
    EncounterStatusEnum["ONLEAVE"] = "onleave";
    EncounterStatusEnum["FINISHED"] = "finished";
    EncounterStatusEnum["CANCELLED"] = "cancelled";
    EncounterStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    EncounterStatusEnum["UNKNOWN"] = "unknown";
})(EncounterStatusEnum || (EncounterStatusEnum = {}));
//# sourceMappingURL=Encounter.js.map