// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ConceptMap
import * as fhir from '../fhir.js';
import { ConceptMapEquivalenceValueSet, } from '../fhirValueSets/ConceptMapEquivalenceValueSet.js';
import { ConceptmapUnmappedModeValueSet, } from '../fhirValueSets/ConceptmapUnmappedModeValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
 */
export class ConceptMapGroupElementTargetDependsOn extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupElementTargetDependsOn - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConceptMapGroupElementTargetDependsOn';
        if (source['property']) {
            this.property = new fhir.FhirUri({ value: source.property });
        }
        else {
            this.property = null;
        }
        if (source['system']) {
            this.system = new fhir.FhirCanonical({ value: source.system });
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        else {
            this.value = null;
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['property']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property property:fhir.FhirUri fhir: ConceptMap.group.element.target.dependsOn.property:uri", }));
        }
        if (this["property"]) {
            outcome.issue.push(...this.property.doModelValidation().issue);
        }
        if (this["system"]) {
            outcome.issue.push(...this.system.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value:fhir.FhirString fhir: ConceptMap.group.element.target.dependsOn.value:string", }));
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
 */
export class ConceptMapGroupElementTarget extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupElementTarget - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConceptMapGroupElementTarget';
        /**
         * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
         */
        this.dependsOn = [];
        /**
         * A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
         */
        this.product = [];
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
        if (source['equivalence']) {
            this.equivalence = source.equivalence;
        }
        else {
            this.equivalence = null;
        }
        if (source['comment']) {
            this.comment = new fhir.FhirString({ value: source.comment });
        }
        if (source['dependsOn']) {
            this.dependsOn = source.dependsOn.map((x) => new fhir.ConceptMapGroupElementTargetDependsOn(x));
        }
        if (source['product']) {
            this.product = source.product.map((x) => new fhir.ConceptMapGroupElementTargetDependsOn(x));
        }
    }
    /**
     * Required-bound Value Set for equivalence
     */
    static equivalenceRequiredValueSet() {
        return ConceptMapEquivalenceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        if (!this['equivalence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property equivalence:ConceptMapEquivalenceValueSetEnum fhir: ConceptMap.group.element.target.equivalence:code", }));
        }
        if (this["comment"]) {
            outcome.issue.push(...this.comment.doModelValidation().issue);
        }
        if (this["dependsOn"]) {
            this.dependsOn.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["product"]) {
            this.product.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
 */
export class ConceptMapGroupElement extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupElement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConceptMapGroupElement';
        /**
         * Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
         */
        this.target = [];
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
        if (source['target']) {
            this.target = source.target.map((x) => new fhir.ConceptMapGroupElementTarget(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        if (this["target"]) {
            this.target.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This only applies if the source code has a system value that matches the system defined for the group.
 */
export class ConceptMapGroupUnmapped extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupUnmapped - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConceptMapGroupUnmapped';
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
        if (source['url']) {
            this.url = new fhir.FhirCanonical({ value: source.url });
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return ConceptmapUnmappedModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['mode']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property mode:ConceptmapUnmappedModeValueSetEnum fhir: ConceptMap.group.unmapped.mode:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A group of mappings that all have the same source and target system.
 */
export class ConceptMapGroup extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConceptMapGroup';
        /**
         * Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
         */
        this.element = [];
        if (source['source']) {
            this.source = new fhir.FhirUri({ value: source.source });
        }
        if (source['sourceVersion']) {
            this.sourceVersion = new fhir.FhirString({ value: source.sourceVersion });
        }
        if (source['target']) {
            this.target = new fhir.FhirUri({ value: source.target });
        }
        if (source['targetVersion']) {
            this.targetVersion = new fhir.FhirString({ value: source.targetVersion });
        }
        if (source['element']) {
            this.element = source.element.map((x) => new fhir.ConceptMapGroupElement(x));
        }
        else {
            this.element = null;
        }
        if (source['unmapped']) {
            this.unmapped = new fhir.ConceptMapGroupUnmapped(source.unmapped);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["source"]) {
            outcome.issue.push(...this.source.doModelValidation().issue);
        }
        if (this["sourceVersion"]) {
            outcome.issue.push(...this.sourceVersion.doModelValidation().issue);
        }
        if (this["target"]) {
            outcome.issue.push(...this.target.doModelValidation().issue);
        }
        if (this["targetVersion"]) {
            outcome.issue.push(...this.targetVersion.doModelValidation().issue);
        }
        if (!this['element']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property element:fhir.ConceptMapGroupElement[] fhir: ConceptMap.group.element:element", }));
        }
        else if (!Array.isArray(this.element)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property element:fhir.ConceptMapGroupElement[] fhir: ConceptMap.group.element:element", }));
        }
        else if (this.element.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property element:fhir.ConceptMapGroupElement[] fhir: ConceptMap.group.element:element", }));
        }
        if (this["element"]) {
            this.element.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["unmapped"]) {
            outcome.issue.push(...this.unmapped.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.
 */
export class ConceptMap extends fhir.DomainResource {
    /**
     * Default constructor for ConceptMap - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConceptMap';
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the concept map to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        this.__sourceIsChoice = true;
        this.__targetIsChoice = true;
        /**
         * A group of mappings that all have the same source and target system.
         */
        this.group = [];
        this.resourceType = 'ConceptMap';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['source']) {
            this.source = source.source;
        }
        else if (source['sourceUri']) {
            this.source = new fhir.FhirUri({ value: source.sourceUri });
        }
        else if (source['sourceCanonical']) {
            this.source = new fhir.FhirCanonical({ value: source.sourceCanonical });
        }
        if (source['target']) {
            this.target = source.target;
        }
        else if (source['targetUri']) {
            this.target = new fhir.FhirUri({ value: source.targetUri });
        }
        else if (source['targetCanonical']) {
            this.target = new fhir.FhirCanonical({ value: source.targetCanonical });
        }
        if (source['group']) {
            this.group = source.group.map((x) => new fhir.ConceptMapGroup(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'ConceptMap' fhir: ConceptMap.resourceType:'ConceptMap'", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: ConceptMap.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["group"]) {
            this.group.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=ConceptMap.js.map