// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ConceptMap
import * as fhir from '../fhir.js';
import { ConceptMapEquivalenceValueSet } from '../fhirValueSets/ConceptMapEquivalenceValueSet.js';
import { ConceptmapUnmappedModeValueSet } from '../fhirValueSets/ConceptmapUnmappedModeValueSet.js';
import { PublicationStatusValueSet } from '../fhirValueSets/PublicationStatusValueSet.js';
/**
 * A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
 */
export class ConceptMapGroupElementTargetDependsOn extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupElementTargetDependsOn - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['property']) {
            this.property = source.property;
        }
        else {
            this.property = null;
        }
        if (source['_property']) {
            this._property = new fhir.FhirElement(source._property);
        }
        if (source['system']) {
            this.system = source.system;
        }
        if (source['_system']) {
            this._system = new fhir.FhirElement(source._system);
        }
        if (source['value']) {
            this.value = source.value;
        }
        else {
            this.value = null;
        }
        if (source['_value']) {
            this._value = new fhir.FhirElement(source._value);
        }
        if (source['display']) {
            this.display = source.display;
        }
        if (source['_display']) {
            this._display = new fhir.FhirElement(source._display);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["property"]) {
            results.push(["property", 'Missing required element: ConceptMap.group.element.target.dependsOn.property']);
        }
        if (this["_property"]) {
            results.push(...this._property.doModelValidation());
        }
        if (this["_system"]) {
            results.push(...this._system.doModelValidation());
        }
        if (!this["value"]) {
            results.push(["value", 'Missing required element: ConceptMap.group.element.target.dependsOn.value']);
        }
        if (this["_value"]) {
            results.push(...this._value.doModelValidation());
        }
        if (this["_display"]) {
            results.push(...this._display.doModelValidation());
        }
        return results;
    }
}
/**
 * Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
 */
export class ConceptMapGroupElementTarget extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupElementTarget - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['code']) {
            this.code = source.code;
        }
        if (source['_code']) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source['display']) {
            this.display = source.display;
        }
        if (source['_display']) {
            this._display = new fhir.FhirElement(source._display);
        }
        if (source['equivalence']) {
            this.equivalence = source.equivalence;
        }
        else {
            this.equivalence = null;
        }
        if (source['_equivalence']) {
            this._equivalence = new fhir.FhirElement(source._equivalence);
        }
        if (source['comment']) {
            this.comment = source.comment;
        }
        if (source['_comment']) {
            this._comment = new fhir.FhirElement(source._comment);
        }
        if (source['dependsOn']) {
            this.dependsOn = source.dependsOn.map((x) => new fhir.ConceptMapGroupElementTargetDependsOn(x));
        }
        if (source['product']) {
            this.product = source.product.map((x) => new fhir.ConceptMapGroupElementTargetDependsOn(x));
        }
    }
    /**
     * Required-bound Value Set for equivalence
     */
    static equivalenceRequiredValueSet() {
        return ConceptMapEquivalenceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_code"]) {
            results.push(...this._code.doModelValidation());
        }
        if (this["_display"]) {
            results.push(...this._display.doModelValidation());
        }
        if (!this["equivalence"]) {
            results.push(["equivalence", 'Missing required element: ConceptMap.group.element.target.equivalence']);
        }
        if (this["_equivalence"]) {
            results.push(...this._equivalence.doModelValidation());
        }
        if (this["_comment"]) {
            results.push(...this._comment.doModelValidation());
        }
        if (this["dependsOn"]) {
            this.dependsOn.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["product"]) {
            this.product.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
 */
export class ConceptMapGroupElement extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupElement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['code']) {
            this.code = source.code;
        }
        if (source['_code']) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source['display']) {
            this.display = source.display;
        }
        if (source['_display']) {
            this._display = new fhir.FhirElement(source._display);
        }
        if (source['target']) {
            this.target = source.target.map((x) => new fhir.ConceptMapGroupElementTarget(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_code"]) {
            results.push(...this._code.doModelValidation());
        }
        if (this["_display"]) {
            results.push(...this._display.doModelValidation());
        }
        if (this["target"]) {
            this.target.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * This only applies if the source code has a system value that matches the system defined for the group.
 */
export class ConceptMapGroupUnmapped extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroupUnmapped - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['mode']) {
            this.mode = source.mode;
        }
        else {
            this.mode = null;
        }
        if (source['_mode']) {
            this._mode = new fhir.FhirElement(source._mode);
        }
        if (source['code']) {
            this.code = source.code;
        }
        if (source['_code']) {
            this._code = new fhir.FhirElement(source._code);
        }
        if (source['display']) {
            this.display = source.display;
        }
        if (source['_display']) {
            this._display = new fhir.FhirElement(source._display);
        }
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return ConceptmapUnmappedModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["mode"]) {
            results.push(["mode", 'Missing required element: ConceptMap.group.unmapped.mode']);
        }
        if (this["_mode"]) {
            results.push(...this._mode.doModelValidation());
        }
        if (this["_code"]) {
            results.push(...this._code.doModelValidation());
        }
        if (this["_display"]) {
            results.push(...this._display.doModelValidation());
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        return results;
    }
}
/**
 * A group of mappings that all have the same source and target system.
 */
export class ConceptMapGroup extends fhir.BackboneElement {
    /**
     * Default constructor for ConceptMapGroup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['source']) {
            this.source = source.source;
        }
        if (source['_source']) {
            this._source = new fhir.FhirElement(source._source);
        }
        if (source['sourceVersion']) {
            this.sourceVersion = source.sourceVersion;
        }
        if (source['_sourceVersion']) {
            this._sourceVersion = new fhir.FhirElement(source._sourceVersion);
        }
        if (source['target']) {
            this.target = source.target;
        }
        if (source['_target']) {
            this._target = new fhir.FhirElement(source._target);
        }
        if (source['targetVersion']) {
            this.targetVersion = source.targetVersion;
        }
        if (source['_targetVersion']) {
            this._targetVersion = new fhir.FhirElement(source._targetVersion);
        }
        if (source['element']) {
            this.element = source.element.map((x) => new fhir.ConceptMapGroupElement(x));
        }
        else {
            this.element = null;
        }
        if (source['unmapped']) {
            this.unmapped = new fhir.ConceptMapGroupUnmapped(source.unmapped);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_source"]) {
            results.push(...this._source.doModelValidation());
        }
        if (this["_sourceVersion"]) {
            results.push(...this._sourceVersion.doModelValidation());
        }
        if (this["_target"]) {
            results.push(...this._target.doModelValidation());
        }
        if (this["_targetVersion"]) {
            results.push(...this._targetVersion.doModelValidation());
        }
        if ((!this["element"]) || (this["element"].length === 0)) {
            results.push(["element", 'Missing required element: ConceptMap.group.element']);
        }
        if (this["element"]) {
            this.element.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["unmapped"]) {
            results.push(...this.unmapped.doModelValidation());
        }
        return results;
    }
}
/**
 * A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.
 */
export class ConceptMap extends fhir.DomainResource {
    /**
     * Default constructor for ConceptMap - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'ConceptMap';
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
        if (source['name']) {
            this.name = source.name;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['title']) {
            this.title = source.title;
        }
        if (source['_title']) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['experimental']) {
            this.experimental = source.experimental;
        }
        if (source['_experimental']) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source['date']) {
            this.date = source.date;
        }
        if (source['_date']) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source['publisher']) {
            this.publisher = source.publisher;
        }
        if (source['_publisher']) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = source.purpose;
        }
        if (source['_purpose']) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source['copyright']) {
            this.copyright = source.copyright;
        }
        if (source['_copyright']) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source['sourceUri']) {
            this.sourceUri = source.sourceUri;
        }
        if (source['_sourceUri']) {
            this._sourceUri = new fhir.FhirElement(source._sourceUri);
        }
        if (source['sourceCanonical']) {
            this.sourceCanonical = source.sourceCanonical;
        }
        if (source['_sourceCanonical']) {
            this._sourceCanonical = new fhir.FhirElement(source._sourceCanonical);
        }
        if (source['targetUri']) {
            this.targetUri = source.targetUri;
        }
        if (source['_targetUri']) {
            this._targetUri = new fhir.FhirElement(source._targetUri);
        }
        if (source['targetCanonical']) {
            this.targetCanonical = source.targetCanonical;
        }
        if (source['_targetCanonical']) {
            this._targetCanonical = new fhir.FhirElement(source._targetCanonical);
        }
        if (source['group']) {
            this.group = source.group.map((x) => new fhir.ConceptMapGroup(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: ConceptMap.resourceType']);
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["identifier"]) {
            results.push(...this.identifier.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_title"]) {
            results.push(...this._title.doModelValidation());
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: ConceptMap.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["_experimental"]) {
            results.push(...this._experimental.doModelValidation());
        }
        if (this["_date"]) {
            results.push(...this._date.doModelValidation());
        }
        if (this["_publisher"]) {
            results.push(...this._publisher.doModelValidation());
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_purpose"]) {
            results.push(...this._purpose.doModelValidation());
        }
        if (this["_copyright"]) {
            results.push(...this._copyright.doModelValidation());
        }
        if (this["_sourceUri"]) {
            results.push(...this._sourceUri.doModelValidation());
        }
        if (this["_sourceCanonical"]) {
            results.push(...this._sourceCanonical.doModelValidation());
        }
        if (this["_targetUri"]) {
            results.push(...this._targetUri.doModelValidation());
        }
        if (this["_targetCanonical"]) {
            results.push(...this._targetCanonical.doModelValidation());
        }
        if (this["group"]) {
            this.group.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=ConceptMap.js.map