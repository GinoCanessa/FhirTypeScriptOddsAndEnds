// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ChargeItemDefinition
import * as fhir from '../fhir.js';
import { InvoicePriceComponentTypeValueSet, } from '../fhirValueSets/InvoicePriceComponentTypeValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { ChargeitemBillingcodesValueSet, } from '../fhirValueSets/ChargeitemBillingcodesValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * The applicability conditions can be used to ascertain whether a billing item is allowed in a specific context. E.g. some billing codes may only be applicable in out-patient settings, only to male/female patients or only to children.
 */
export class ChargeItemDefinitionApplicability extends fhir.BackboneElement {
    /**
     * Default constructor for ChargeItemDefinitionApplicability - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ChargeItemDefinitionApplicability';
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['language']) {
            this.language = new fhir.FhirString({ value: source.language });
        }
        if (source['expression']) {
            this.expression = new fhir.FhirString({ value: source.expression });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["language"]) {
            outcome.issue.push(...this.language.doModelValidation().issue);
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
 */
export class ChargeItemDefinitionPropertyGroupPriceComponent extends fhir.BackboneElement {
    /**
     * Default constructor for ChargeItemDefinitionPropertyGroupPriceComponent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ChargeItemDefinitionPropertyGroupPriceComponent';
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['amount']) {
            this.amount = new fhir.Money(source.amount);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return InvoicePriceComponentTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:InvoicePriceComponentTypeValueSetEnum fhir: ChargeItemDefinition.propertyGroup.priceComponent.type:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
 */
export class ChargeItemDefinitionPropertyGroup extends fhir.BackboneElement {
    /**
     * Default constructor for ChargeItemDefinitionPropertyGroup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ChargeItemDefinitionPropertyGroup';
        /**
         * The applicability conditions can be used to ascertain whether a billing item is allowed in a specific context. E.g. some billing codes may only be applicable in out-patient settings, only to male/female patients or only to children.
         */
        this.applicability = [];
        /**
         * The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
         */
        this.priceComponent = [];
        if (source['applicability']) {
            this.applicability = source.applicability.map((x) => new fhir.ChargeItemDefinitionApplicability(x));
        }
        if (source['priceComponent']) {
            this.priceComponent = source.priceComponent.map((x) => new fhir.ChargeItemDefinitionPropertyGroupPriceComponent(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["applicability"]) {
            this.applicability.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["priceComponent"]) {
            this.priceComponent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system.
 */
export class ChargeItemDefinition extends fhir.DomainResource {
    /**
     * Default constructor for ChargeItemDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ChargeItemDefinition';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this charge item definition outside of FHIR, where it is not possible to use the logical URI.
         */
        this.identifier = [];
        /**
         * The URL pointing to an externally-defined charge item definition that is adhered to in whole or in part by this definition.
         */
        this.derivedFromUri = [];
        /**
         * A larger definition of which this particular definition is a component or step.
         */
        this.partOf = [];
        /**
         * As new versions of a protocol or guideline are defined, allows identification of what versions are replaced by a new instance.
         */
        this.replaces = [];
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the charge item definition to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * In case of highly customized, individually produced or fitted devices/substances, the pricing information may be different for each instance of the product. This reference links pricing details to specific product instances.
         */
        this.instance = [];
        /**
         * The applicability conditions can be used to ascertain whether a billing item is allowed in a specific context. E.g. some billing codes may only be applicable in out-patient settings, only to male/female patients or only to children.
         */
        this.applicability = [];
        /**
         * Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
         */
        this.propertyGroup = [];
        this.resourceType = 'ChargeItemDefinition';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['derivedFromUri']) {
            this.derivedFromUri = source.derivedFromUri.map((x) => new fhir.FhirUri({ value: x }));
        }
        if (source['partOf']) {
            this.partOf = source.partOf.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['replaces']) {
            this.replaces = source.replaces.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['approvalDate']) {
            this.approvalDate = new fhir.FhirDate({ value: source.approvalDate });
        }
        if (source['lastReviewDate']) {
            this.lastReviewDate = new fhir.FhirDate({ value: source.lastReviewDate });
        }
        if (source['effectivePeriod']) {
            this.effectivePeriod = new fhir.Period(source.effectivePeriod);
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['instance']) {
            this.instance = source.instance.map((x) => new fhir.Reference(x));
        }
        if (source['applicability']) {
            this.applicability = source.applicability.map((x) => new fhir.ChargeItemDefinitionApplicability(x));
        }
        if (source['propertyGroup']) {
            this.propertyGroup = source.propertyGroup.map((x) => new fhir.ChargeItemDefinitionPropertyGroup(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ChargeitemBillingcodesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'ChargeItemDefinition' fhir: ChargeItemDefinition.resourceType:'ChargeItemDefinition'", }));
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: ChargeItemDefinition.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (this["derivedFromUri"]) {
            this.derivedFromUri.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["partOf"]) {
            this.partOf.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["replaces"]) {
            this.replaces.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: ChargeItemDefinition.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["approvalDate"]) {
            outcome.issue.push(...this.approvalDate.doModelValidation().issue);
        }
        if (this["lastReviewDate"]) {
            outcome.issue.push(...this.lastReviewDate.doModelValidation().issue);
        }
        if (this["effectivePeriod"]) {
            outcome.issue.push(...this.effectivePeriod.doModelValidation().issue);
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["instance"]) {
            this.instance.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["applicability"]) {
            this.applicability.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["propertyGroup"]) {
            this.propertyGroup.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=ChargeItemDefinition.js.map