// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Invoice
import * as fhir from '../fhir.js';
import { InvoicePriceComponentTypeValueSet, } from '../fhirValueSets/InvoicePriceComponentTypeValueSet.js';
import { InvoiceStatusValueSet, } from '../fhirValueSets/InvoiceStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Indicates who or what performed or participated in the charged service.
 */
export class InvoiceParticipant extends fhir.BackboneElement {
    /**
     * Default constructor for InvoiceParticipant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'InvoiceParticipant';
        if (source['role']) {
            this.role = new fhir.CodeableConcept(source.role);
        }
        if (source['actor']) {
            this.actor = new fhir.Reference(source.actor);
        }
        else {
            this.actor = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["role"]) {
            outcome.issue.push(...this.role.doModelValidation().issue);
        }
        if (!this['actor']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property actor:fhir.Reference fhir: Invoice.participant.actor:Reference", }));
        }
        if (this["actor"]) {
            outcome.issue.push(...this.actor.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
 */
export class InvoiceLineItemPriceComponent extends fhir.BackboneElement {
    /**
     * Default constructor for InvoiceLineItemPriceComponent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'InvoiceLineItemPriceComponent';
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['amount']) {
            this.amount = new fhir.Money(source.amount);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return InvoicePriceComponentTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:InvoicePriceComponentTypeValueSetEnum fhir: Invoice.lineItem.priceComponent.type:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
 */
export class InvoiceLineItem extends fhir.BackboneElement {
    /**
     * Default constructor for InvoiceLineItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'InvoiceLineItem';
        this.__chargeItemIsChoice = true;
        /**
         * The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
         */
        this.priceComponent = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        if (source['chargeItem']) {
            this.chargeItem = source.chargeItem;
        }
        else if (source['chargeItemReference']) {
            this.chargeItem = new fhir.Reference(source.chargeItemReference);
        }
        else if (source['chargeItemCodeableConcept']) {
            this.chargeItem = new fhir.CodeableConcept(source.chargeItemCodeableConcept);
        }
        else {
            this.chargeItem = null;
        }
        if (source['priceComponent']) {
            this.priceComponent = source.priceComponent.map((x) => new fhir.InvoiceLineItemPriceComponent(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['chargeItem']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property chargeItem: fhir: Invoice.lineItem.chargeItem[x]:", }));
        }
        if (this["priceComponent"]) {
            this.priceComponent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.
 */
export class Invoice extends fhir.DomainResource {
    /**
     * Default constructor for Invoice - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Invoice';
        /**
         * Identifier of this Invoice, often used for reference in correspondence about this invoice or for tracking of payments.
         */
        this.identifier = [];
        /**
         * Indicates who or what performed or participated in the charged service.
         */
        this.participant = [];
        /**
         * Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
         */
        this.lineItem = [];
        /**
         * The total amount for the Invoice may be calculated as the sum of the line items with surcharges/deductions that apply in certain conditions.  The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the total price was calculated.
         */
        this.totalPriceComponent = [];
        /**
         * Comments made about the invoice by the issuer, subject, or other participants.
         */
        this.note = [];
        this.resourceType = 'Invoice';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['cancelledReason']) {
            this.cancelledReason = new fhir.FhirString({ value: source.cancelledReason });
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source['recipient']) {
            this.recipient = new fhir.Reference(source.recipient);
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['participant']) {
            this.participant = source.participant.map((x) => new fhir.InvoiceParticipant(x));
        }
        if (source['issuer']) {
            this.issuer = new fhir.Reference(source.issuer);
        }
        if (source['account']) {
            this.account = new fhir.Reference(source.account);
        }
        if (source['lineItem']) {
            this.lineItem = source.lineItem.map((x) => new fhir.InvoiceLineItem(x));
        }
        if (source['totalPriceComponent']) {
            this.totalPriceComponent = source.totalPriceComponent.map((x) => new fhir.InvoiceLineItemPriceComponent(x));
        }
        if (source['totalNet']) {
            this.totalNet = new fhir.Money(source.totalNet);
        }
        if (source['totalGross']) {
            this.totalGross = new fhir.Money(source.totalGross);
        }
        if (source['paymentTerms']) {
            this.paymentTerms = new fhir.FhirMarkdown({ value: source.paymentTerms });
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return InvoiceStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Invoice' fhir: Invoice.resourceType:'Invoice'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:InvoiceStatusValueSetEnum fhir: Invoice.status:code", }));
        }
        if (this["cancelledReason"]) {
            outcome.issue.push(...this.cancelledReason.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["subject"]) {
            outcome.issue.push(...this.subject.doModelValidation().issue);
        }
        if (this["recipient"]) {
            outcome.issue.push(...this.recipient.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["participant"]) {
            this.participant.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["issuer"]) {
            outcome.issue.push(...this.issuer.doModelValidation().issue);
        }
        if (this["account"]) {
            outcome.issue.push(...this.account.doModelValidation().issue);
        }
        if (this["lineItem"]) {
            this.lineItem.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["totalPriceComponent"]) {
            this.totalPriceComponent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["totalNet"]) {
            outcome.issue.push(...this.totalNet.doModelValidation().issue);
        }
        if (this["totalGross"]) {
            outcome.issue.push(...this.totalGross.doModelValidation().issue);
        }
        if (this["paymentTerms"]) {
            outcome.issue.push(...this.paymentTerms.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Invoice.js.map