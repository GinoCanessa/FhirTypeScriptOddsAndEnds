// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Location
import * as fhir from '../fhir.js';
import { DaysOfWeekValueSet, } from '../fhirValueSets/DaysOfWeekValueSet.js';
import { LocationStatusValueSet, } from '../fhirValueSets/LocationStatusValueSet.js';
import { V20116ValueSet, } from '../fhirValueSets/V20116ValueSet.js';
import { LocationModeValueSet, } from '../fhirValueSets/LocationModeValueSet.js';
import { V3ServiceDeliveryLocationRoleTypeValueSet, } from '../fhirValueSets/V3ServiceDeliveryLocationRoleTypeValueSet.js';
import { LocationPhysicalTypeValueSet, } from '../fhirValueSets/LocationPhysicalTypeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
 */
export class LocationPosition extends fhir.BackboneElement {
    /**
     * Default constructor for LocationPosition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'LocationPosition';
        if (source['longitude']) {
            this.longitude = new fhir.FhirDecimal({ value: source.longitude });
        }
        else {
            this.longitude = null;
        }
        if (source['latitude']) {
            this.latitude = new fhir.FhirDecimal({ value: source.latitude });
        }
        else {
            this.latitude = null;
        }
        if (source['altitude']) {
            this.altitude = new fhir.FhirDecimal({ value: source.altitude });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['longitude']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property longitude:fhir.FhirDecimal fhir: Location.position.longitude:decimal", }));
        }
        if (this["longitude"]) {
            outcome.issue.push(...this.longitude.doModelValidation().issue);
        }
        if (!this['latitude']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property latitude:fhir.FhirDecimal fhir: Location.position.latitude:decimal", }));
        }
        if (this["latitude"]) {
            outcome.issue.push(...this.latitude.doModelValidation().issue);
        }
        if (this["altitude"]) {
            outcome.issue.push(...this.altitude.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This type of information is commonly found published in directories and on websites informing customers when the facility is available.
 * Specific services within the location may have their own hours which could be shorter (or longer) than the locations hours.
 */
export class LocationHoursOfOperation extends fhir.BackboneElement {
    /**
     * Default constructor for LocationHoursOfOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'LocationHoursOfOperation';
        /**
         * Indicates which days of the week are available between the start and end Times.
         */
        this.daysOfWeek = [];
        if (source['daysOfWeek']) {
            this.daysOfWeek = source.daysOfWeek.map((x) => x);
        }
        if (source['allDay']) {
            this.allDay = new fhir.FhirBoolean({ value: source.allDay });
        }
        if (source['openingTime']) {
            this.openingTime = new fhir.FhirTime({ value: source.openingTime });
        }
        if (source['closingTime']) {
            this.closingTime = new fhir.FhirTime({ value: source.closingTime });
        }
    }
    /**
     * Required-bound Value Set for daysOfWeek
     */
    static daysOfWeekRequiredValueSet() {
        return DaysOfWeekValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["allDay"]) {
            outcome.issue.push(...this.allDay.doModelValidation().issue);
        }
        if (this["openingTime"]) {
            outcome.issue.push(...this.openingTime.doModelValidation().issue);
        }
        if (this["closingTime"]) {
            outcome.issue.push(...this.closingTime.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
 */
export class Location extends fhir.DomainResource {
    /**
     * Default constructor for Location - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Location';
        /**
         * Unique code or number identifying the location to its users.
         */
        this.identifier = [];
        /**
         * There are no dates associated with the alias/historic names, as this is not intended to track when names were used, but to assist in searching so that older names can still result in identifying the location.
         */
        this.alias = [];
        /**
         * Indicates the type of function performed at the location.
         */
        this.type = [];
        /**
         * The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
         */
        this.telecom = [];
        /**
         * This type of information is commonly found published in directories and on websites informing customers when the facility is available.
         * Specific services within the location may have their own hours which could be shorter (or longer) than the locations hours.
         */
        this.hoursOfOperation = [];
        /**
         * Technical endpoints providing access to services operated for the location.
         */
        this.endpoint = [];
        this.resourceType = 'Location';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        if (source['operationalStatus']) {
            this.operationalStatus = new fhir.Coding(source.operationalStatus);
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['alias']) {
            this.alias = source.alias.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['mode']) {
            this.mode = source.mode;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['telecom']) {
            this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x));
        }
        if (source['address']) {
            this.address = new fhir.Address(source.address);
        }
        if (source['physicalType']) {
            this.physicalType = new fhir.CodeableConcept(source.physicalType);
        }
        if (source['position']) {
            this.position = new fhir.LocationPosition(source.position);
        }
        if (source['managingOrganization']) {
            this.managingOrganization = new fhir.Reference(source.managingOrganization);
        }
        if (source['partOf']) {
            this.partOf = new fhir.Reference(source.partOf);
        }
        if (source['hoursOfOperation']) {
            this.hoursOfOperation = source.hoursOfOperation.map((x) => new fhir.LocationHoursOfOperation(x));
        }
        if (source['availabilityExceptions']) {
            this.availabilityExceptions = new fhir.FhirString({ value: source.availabilityExceptions });
        }
        if (source['endpoint']) {
            this.endpoint = source.endpoint.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return LocationStatusValueSet;
    }
    /**
     * Preferred-bound Value Set for operationalStatus
     */
    static operationalStatusPreferredValueSet() {
        return V20116ValueSet;
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return LocationModeValueSet;
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return V3ServiceDeliveryLocationRoleTypeValueSet;
    }
    /**
     * Example-bound Value Set for physicalType
     */
    static physicalTypeExampleValueSet() {
        return LocationPhysicalTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Location' fhir: Location.resourceType:'Location'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["operationalStatus"]) {
            outcome.issue.push(...this.operationalStatus.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["alias"]) {
            this.alias.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["telecom"]) {
            this.telecom.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["address"]) {
            outcome.issue.push(...this.address.doModelValidation().issue);
        }
        if (this["physicalType"]) {
            outcome.issue.push(...this.physicalType.doModelValidation().issue);
        }
        if (this["position"]) {
            outcome.issue.push(...this.position.doModelValidation().issue);
        }
        if (this["managingOrganization"]) {
            outcome.issue.push(...this.managingOrganization.doModelValidation().issue);
        }
        if (this["partOf"]) {
            outcome.issue.push(...this.partOf.doModelValidation().issue);
        }
        if (this["hoursOfOperation"]) {
            this.hoursOfOperation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["availabilityExceptions"]) {
            outcome.issue.push(...this.availabilityExceptions.doModelValidation().issue);
        }
        if (this["endpoint"]) {
            this.endpoint.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Location.js.map