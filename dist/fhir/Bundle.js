// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Bundle
import * as fhir from '../fhir.js';
import { SearchEntryModeValueSet, } from '../fhirValueSets/SearchEntryModeValueSet.js';
import { HttpVerbValueSet, } from '../fhirValueSets/HttpVerbValueSet.js';
import { BundleTypeValueSet, } from '../fhirValueSets/BundleTypeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).
 * Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](http.html#read) directly.
 * This specification defines some specific uses of Bundle.link for [searching](search.html#conformance) and [paging](http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
 */
export class BundleLink extends fhir.BackboneElement {
    /**
     * Default constructor for BundleLink - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'BundleLink';
        if (source['relation']) {
            this.relation = new fhir.FhirString({ value: source.relation });
        }
        else {
            this.relation = null;
        }
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['relation']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property relation:fhir.FhirString fhir: Bundle.link.relation:string", }));
        }
        if (this["relation"]) {
            outcome.issue.push(...this.relation.doModelValidation().issue);
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: Bundle.link.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Information about the search process that lead to the creation of this entry.
 */
export class BundleEntrySearch extends fhir.BackboneElement {
    /**
     * Default constructor for BundleEntrySearch - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'BundleEntrySearch';
        if (source['mode']) {
            this.mode = source.mode;
        }
        if (source['score']) {
            this.score = new fhir.FhirDecimal({ value: source.score });
        }
    }
    /**
     * Required-bound Value Set for mode
     */
    static modeRequiredValueSet() {
        return SearchEntryModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["score"]) {
            outcome.issue.push(...this.score.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
 */
export class BundleEntryRequest extends fhir.BackboneElement {
    /**
     * Default constructor for BundleEntryRequest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'BundleEntryRequest';
        if (source['method']) {
            this.method = source.method;
        }
        else {
            this.method = null;
        }
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['ifNoneMatch']) {
            this.ifNoneMatch = new fhir.FhirString({ value: source.ifNoneMatch });
        }
        if (source['ifModifiedSince']) {
            this.ifModifiedSince = new fhir.FhirInstant({ value: source.ifModifiedSince });
        }
        if (source['ifMatch']) {
            this.ifMatch = new fhir.FhirString({ value: source.ifMatch });
        }
        if (source['ifNoneExist']) {
            this.ifNoneExist = new fhir.FhirString({ value: source.ifNoneExist });
        }
    }
    /**
     * Required-bound Value Set for method
     */
    static methodRequiredValueSet() {
        return HttpVerbValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['method']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property method:HttpVerbValueSetEnum fhir: Bundle.entry.request.method:code", }));
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: Bundle.entry.request.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["ifNoneMatch"]) {
            outcome.issue.push(...this.ifNoneMatch.doModelValidation().issue);
        }
        if (this["ifModifiedSince"]) {
            outcome.issue.push(...this.ifModifiedSince.doModelValidation().issue);
        }
        if (this["ifMatch"]) {
            outcome.issue.push(...this.ifMatch.doModelValidation().issue);
        }
        if (this["ifNoneExist"]) {
            outcome.issue.push(...this.ifNoneExist.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
 */
export class BundleEntryResponse extends fhir.BackboneElement {
    /**
     * Default constructor for BundleEntryResponse - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        var _a;
        super(source, options);
        this.__dataType = 'BundleEntryResponse';
        if (source['status']) {
            this.status = new fhir.FhirString({ value: source.status });
        }
        else {
            this.status = null;
        }
        if (source['location']) {
            this.location = new fhir.FhirUri({ value: source.location });
        }
        if (source['etag']) {
            this.etag = new fhir.FhirString({ value: source.etag });
        }
        if (source['lastModified']) {
            this.lastModified = new fhir.FhirInstant({ value: source.lastModified });
        }
        if (source['outcome']) {
            this.outcome = ((_a = fhir.resourceFactory(source.outcome)) !== null && _a !== void 0 ? _a : undefined);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:fhir.FhirString fhir: Bundle.entry.response.status:string", }));
        }
        if (this["status"]) {
            outcome.issue.push(...this.status.doModelValidation().issue);
        }
        if (this["location"]) {
            outcome.issue.push(...this.location.doModelValidation().issue);
        }
        if (this["etag"]) {
            outcome.issue.push(...this.etag.doModelValidation().issue);
        }
        if (this["lastModified"]) {
            outcome.issue.push(...this.lastModified.doModelValidation().issue);
        }
        if (this["outcome"]) {
            outcome.issue.push(...this.outcome.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
 */
export class BundleEntry extends fhir.BackboneElement {
    /**
     * Default constructor for BundleEntry - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        var _a;
        super(source, options);
        this.__dataType = 'BundleEntry';
        /**
         * A series of links that provide context to this entry.
         */
        this.link = [];
        if (source['link']) {
            this.link = source.link.map((x) => new fhir.BundleLink(x));
        }
        if (source['fullUrl']) {
            this.fullUrl = new fhir.FhirUri({ value: source.fullUrl });
        }
        if (source['resource']) {
            this.resource = ((_a = fhir.resourceFactory(source.resource)) !== null && _a !== void 0 ? _a : undefined);
        }
        if (source['search']) {
            this.search = new fhir.BundleEntrySearch(source.search);
        }
        if (source['request']) {
            this.request = new fhir.BundleEntryRequest(source.request);
        }
        if (source['response']) {
            this.response = new fhir.BundleEntryResponse(source.response);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["link"]) {
            this.link.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["fullUrl"]) {
            outcome.issue.push(...this.fullUrl.doModelValidation().issue);
        }
        if (this["resource"]) {
            outcome.issue.push(...this.resource.doModelValidation().issue);
        }
        if (this["search"]) {
            outcome.issue.push(...this.search.doModelValidation().issue);
        }
        if (this["request"]) {
            outcome.issue.push(...this.request.doModelValidation().issue);
        }
        if (this["response"]) {
            outcome.issue.push(...this.response.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
    /**
     * Access a bundle.entry[].resource as a typed resource
     */
    resourceAs() {
        return this.resource;
    }
}
/**
 * A container for a collection of resources.
 */
export class Bundle extends fhir.Resource {
    /**
     * Default constructor for Bundle - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Bundle';
        /**
         * Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).
         * Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](http.html#read) directly.
         * This specification defines some specific uses of Bundle.link for [searching](search.html#conformance) and [paging](http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
         */
        this.link = [];
        /**
         * An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
         */
        this.entry = [];
        this.resourceType = 'Bundle';
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['timestamp']) {
            this.timestamp = new fhir.FhirInstant({ value: source.timestamp });
        }
        if (source['total']) {
            this.total = new fhir.FhirUnsignedInt({ value: source.total });
        }
        if (source['link']) {
            this.link = source.link.map((x) => new fhir.BundleLink(x));
        }
        if (source['entry']) {
            this.entry = source.entry.map((x) => new fhir.BundleEntry(x));
        }
        if (source['signature']) {
            this.signature = new fhir.Signature(source.signature);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return BundleTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Bundle' fhir: Bundle.resourceType:'Bundle'", }));
        }
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:BundleTypeValueSetEnum fhir: Bundle.type:code", }));
        }
        if (this["timestamp"]) {
            outcome.issue.push(...this.timestamp.doModelValidation().issue);
        }
        if (this["total"]) {
            outcome.issue.push(...this.total.doModelValidation().issue);
        }
        if (this["link"]) {
            this.link.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["entry"]) {
            this.entry.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["signature"]) {
            outcome.issue.push(...this.signature.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Bundle.js.map