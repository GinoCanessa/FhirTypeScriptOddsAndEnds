// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Observation
import * as fhir from '../fhir.js';
import { ReferencerangeMeaningValueSet, } from '../fhirValueSets/ReferencerangeMeaningValueSet.js';
import { ReferencerangeAppliestoValueSet, } from '../fhirValueSets/ReferencerangeAppliestoValueSet.js';
import { ObservationCodesValueSet, } from '../fhirValueSets/ObservationCodesValueSet.js';
import { DataAbsentReasonValueSet, } from '../fhirValueSets/DataAbsentReasonValueSet.js';
import { ObservationInterpretationValueSet, } from '../fhirValueSets/ObservationInterpretationValueSet.js';
import { ObservationStatusValueSet, } from '../fhirValueSets/ObservationStatusValueSet.js';
import { ObservationCategoryValueSet, } from '../fhirValueSets/ObservationCategoryValueSet.js';
import { BodySiteValueSet, } from '../fhirValueSets/BodySiteValueSet.js';
import { ObservationMethodsValueSet, } from '../fhirValueSets/ObservationMethodsValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Most observations only have one generic reference range. Systems MAY choose to restrict to only supplying the relevant reference range based on knowledge about the patient (e.g., specific to the patient's age, gender, weight and other factors), but this might not be possible or appropriate. Whenever more than one reference range is supplied, the differences between them SHOULD be provided in the reference range and/or age properties.
 */
export class ObservationReferenceRange extends fhir.BackboneElement {
    /**
     * Default constructor for ObservationReferenceRange - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ObservationReferenceRange';
        /**
         * This SHOULD be populated if there is more than one range.  If this element is not present then the normal population is assumed.
         */
        this.appliesTo = [];
        if (source['low']) {
            this.low = new fhir.Quantity(source.low);
        }
        if (source['high']) {
            this.high = new fhir.Quantity(source.high);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['appliesTo']) {
            this.appliesTo = source.appliesTo.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['age']) {
            this.age = new fhir.Range(source.age);
        }
        if (source['text']) {
            this.text = new fhir.FhirString({ value: source.text });
        }
    }
    /**
     * Preferred-bound Value Set for type
     */
    static typePreferredValueSet() {
        return ReferencerangeMeaningValueSet;
    }
    /**
     * Example-bound Value Set for appliesTo
     */
    static appliesToExampleValueSet() {
        return ReferencerangeAppliestoValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["low"]) {
            outcome.issue.push(...this.low.doModelValidation().issue);
        }
        if (this["high"]) {
            outcome.issue.push(...this.high.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["appliesTo"]) {
            this.appliesTo.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["age"]) {
            outcome.issue.push(...this.age.doModelValidation().issue);
        }
        if (this["text"]) {
            outcome.issue.push(...this.text.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * For a discussion on the ways Observations can be assembled in groups together see [Notes](observation.html#notes) below.
 */
export class ObservationComponent extends fhir.BackboneElement {
    /**
     * Default constructor for ObservationComponent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ObservationComponent';
        this.__valueIsChoice = true;
        /**
         * Historically used for laboratory results (known as 'abnormal flag' ),  its use extends to other use cases where coded interpretations  are relevant.  Often reported as one or more simple compact codes this element is often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result.
         */
        this.interpretation = [];
        /**
         * Most observations only have one generic reference range. Systems MAY choose to restrict to only supplying the relevant reference range based on knowledge about the patient (e.g., specific to the patient's age, gender, weight and other factors), but this might not be possible or appropriate. Whenever more than one reference range is supplied, the differences between them SHOULD be provided in the reference range and/or age properties.
         */
        this.referenceRange = [];
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueQuantity']) {
            this.value = new fhir.Quantity(source.valueQuantity);
        }
        else if (source['valueCodeableConcept']) {
            this.value = new fhir.CodeableConcept(source.valueCodeableConcept);
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueInteger']) {
            this.value = new fhir.FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueRange']) {
            this.value = new fhir.Range(source.valueRange);
        }
        else if (source['valueRatio']) {
            this.value = new fhir.Ratio(source.valueRatio);
        }
        else if (source['valueSampledData']) {
            this.value = new fhir.SampledData(source.valueSampledData);
        }
        else if (source['valueTime']) {
            this.value = new fhir.FhirTime({ value: source.valueTime });
        }
        else if (source['valueDateTime']) {
            this.value = new fhir.FhirDateTime({ value: source.valueDateTime });
        }
        else if (source['valuePeriod']) {
            this.value = new fhir.Period(source.valuePeriod);
        }
        if (source['dataAbsentReason']) {
            this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason);
        }
        if (source['interpretation']) {
            this.interpretation = source.interpretation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['referenceRange']) {
            this.referenceRange = source.referenceRange.map((x) => new fhir.ObservationReferenceRange(x));
        }
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ObservationCodesValueSet;
    }
    /**
     * Extensible-bound Value Set for dataAbsentReason
     */
    static dataAbsentReasonExtensibleValueSet() {
        return DataAbsentReasonValueSet;
    }
    /**
     * Extensible-bound Value Set for interpretation
     */
    static interpretationExtensibleValueSet() {
        return ObservationInterpretationValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.CodeableConcept fhir: Observation.component.code:CodeableConcept", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["dataAbsentReason"]) {
            outcome.issue.push(...this.dataAbsentReason.doModelValidation().issue);
        }
        if (this["interpretation"]) {
            this.interpretation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["referenceRange"]) {
            this.referenceRange.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Measurements and simple assertions made about a patient, device or other subject.
 */
export class Observation extends fhir.DomainResource {
    /**
     * Default constructor for Observation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Observation';
        /**
         * A unique identifier assigned to this observation.
         */
        this.identifier = [];
        /**
         * A plan, proposal or order that is fulfilled in whole or in part by this event.  For example, a MedicationRequest may require a patient to have laboratory test performed before  it is dispensed.
         */
        this.basedOn = [];
        /**
         * To link an Observation to an Encounter use `encounter`.  See the  [Notes](observation.html#obsgrouping) below for guidance on referencing another Observation.
         */
        this.partOf = [];
        /**
         * In addition to the required category valueset, this element allows various categorization schemes based on the ownerâ€™s definition of the category and effectively multiple categories can be used at once.  The level of granularity is defined by the category concepts in the value set.
         */
        this.category = [];
        /**
         * Typically, an observation is made about the subject - a patient, or group of patients, location, or device - and the distinction between the subject and what is directly measured for an observation is specified in the observation code itself ( e.g., "Blood Glucose") and does not need to be represented separately using this element.  Use `specimen` if a reference to a specimen is required.  If a code is required instead of a resource use either  `bodysite` for bodysites or the standard extension [focusCode](extension-observation-focuscode.html).
         */
        this.focus = [];
        this.__effectiveIsChoice = true;
        /**
         * Who was responsible for asserting the observed value as "true".
         */
        this.performer = [];
        this.__valueIsChoice = true;
        /**
         * Historically used for laboratory results (known as 'abnormal flag' ),  its use extends to other use cases where coded interpretations  are relevant.  Often reported as one or more simple compact codes this element is often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result.
         */
        this.interpretation = [];
        /**
         * May include general statements about the observation, or statements about significant, unexpected or unreliable results values, or information about its source when relevant to its interpretation.
         */
        this.note = [];
        /**
         * Most observations only have one generic reference range. Systems MAY choose to restrict to only supplying the relevant reference range based on knowledge about the patient (e.g., specific to the patient's age, gender, weight and other factors), but this might not be possible or appropriate. Whenever more than one reference range is supplied, the differences between them SHOULD be provided in the reference range and/or age properties.
         */
        this.referenceRange = [];
        /**
         * When using this element, an observation will typically have either a value or a set of related resources, although both may be present in some cases.  For a discussion on the ways Observations can assembled in groups together, see [Notes](observation.html#obsgrouping) below.  Note that a system may calculate results from [QuestionnaireResponse](questionnaireresponse.html)  into a final score and represent the score as an Observation.
         */
        this.hasMember = [];
        /**
         * All the reference choices that are listed in this element can represent clinical observations and other measurements that may be the source for a derived value.  The most common reference will be another Observation.  For a discussion on the ways Observations can assembled in groups together, see [Notes](observation.html#obsgrouping) below.
         */
        this.derivedFrom = [];
        /**
         * For a discussion on the ways Observations can be assembled in groups together see [Notes](observation.html#notes) below.
         */
        this.component = [];
        this.resourceType = 'Observation';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['basedOn']) {
            this.basedOn = source.basedOn.map((x) => new fhir.Reference(x));
        }
        if (source['partOf']) {
            this.partOf = source.partOf.map((x) => new fhir.Reference(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['category']) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source['focus']) {
            this.focus = source.focus.map((x) => new fhir.Reference(x));
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['effective']) {
            this.effective = source.effective;
        }
        else if (source['effectiveDateTime']) {
            this.effective = new fhir.FhirDateTime({ value: source.effectiveDateTime });
        }
        else if (source['effectivePeriod']) {
            this.effective = new fhir.Period(source.effectivePeriod);
        }
        else if (source['effectiveTiming']) {
            this.effective = new fhir.Timing(source.effectiveTiming);
        }
        else if (source['effectiveInstant']) {
            this.effective = new fhir.FhirInstant({ value: source.effectiveInstant });
        }
        if (source['issued']) {
            this.issued = new fhir.FhirInstant({ value: source.issued });
        }
        if (source['performer']) {
            this.performer = source.performer.map((x) => new fhir.Reference(x));
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueQuantity']) {
            this.value = new fhir.Quantity(source.valueQuantity);
        }
        else if (source['valueCodeableConcept']) {
            this.value = new fhir.CodeableConcept(source.valueCodeableConcept);
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueInteger']) {
            this.value = new fhir.FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueRange']) {
            this.value = new fhir.Range(source.valueRange);
        }
        else if (source['valueRatio']) {
            this.value = new fhir.Ratio(source.valueRatio);
        }
        else if (source['valueSampledData']) {
            this.value = new fhir.SampledData(source.valueSampledData);
        }
        else if (source['valueTime']) {
            this.value = new fhir.FhirTime({ value: source.valueTime });
        }
        else if (source['valueDateTime']) {
            this.value = new fhir.FhirDateTime({ value: source.valueDateTime });
        }
        else if (source['valuePeriod']) {
            this.value = new fhir.Period(source.valuePeriod);
        }
        if (source['dataAbsentReason']) {
            this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason);
        }
        if (source['interpretation']) {
            this.interpretation = source.interpretation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source['bodySite']) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source['method']) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source['specimen']) {
            this.specimen = new fhir.Reference(source.specimen);
        }
        if (source['device']) {
            this.device = new fhir.Reference(source.device);
        }
        if (source['referenceRange']) {
            this.referenceRange = source.referenceRange.map((x) => new fhir.ObservationReferenceRange(x));
        }
        if (source['hasMember']) {
            this.hasMember = source.hasMember.map((x) => new fhir.Reference(x));
        }
        if (source['derivedFrom']) {
            this.derivedFrom = source.derivedFrom.map((x) => new fhir.Reference(x));
        }
        if (source['component']) {
            this.component = source.component.map((x) => new fhir.ObservationComponent(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return ObservationStatusValueSet;
    }
    /**
     * Preferred-bound Value Set for category
     */
    static categoryPreferredValueSet() {
        return ObservationCategoryValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ObservationCodesValueSet;
    }
    /**
     * Extensible-bound Value Set for dataAbsentReason
     */
    static dataAbsentReasonExtensibleValueSet() {
        return DataAbsentReasonValueSet;
    }
    /**
     * Extensible-bound Value Set for interpretation
     */
    static interpretationExtensibleValueSet() {
        return ObservationInterpretationValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return BodySiteValueSet;
    }
    /**
     * Example-bound Value Set for method
     */
    static methodExampleValueSet() {
        return ObservationMethodsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Observation' fhir: Observation.resourceType:'Observation'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["basedOn"]) {
            this.basedOn.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["partOf"]) {
            this.partOf.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:ObservationStatusValueSetEnum fhir: Observation.status:code", }));
        }
        if (this["category"]) {
            this.category.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.CodeableConcept fhir: Observation.code:CodeableConcept", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["subject"]) {
            outcome.issue.push(...this.subject.doModelValidation().issue);
        }
        if (this["focus"]) {
            this.focus.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["encounter"]) {
            outcome.issue.push(...this.encounter.doModelValidation().issue);
        }
        if (this["issued"]) {
            outcome.issue.push(...this.issued.doModelValidation().issue);
        }
        if (this["performer"]) {
            this.performer.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["dataAbsentReason"]) {
            outcome.issue.push(...this.dataAbsentReason.doModelValidation().issue);
        }
        if (this["interpretation"]) {
            this.interpretation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["bodySite"]) {
            outcome.issue.push(...this.bodySite.doModelValidation().issue);
        }
        if (this["method"]) {
            outcome.issue.push(...this.method.doModelValidation().issue);
        }
        if (this["specimen"]) {
            outcome.issue.push(...this.specimen.doModelValidation().issue);
        }
        if (this["device"]) {
            outcome.issue.push(...this.device.doModelValidation().issue);
        }
        if (this["referenceRange"]) {
            this.referenceRange.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["hasMember"]) {
            this.hasMember.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["derivedFrom"]) {
            this.derivedFrom.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["component"]) {
            this.component.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Observation.js.map