// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Observation
import * as fhir from '../fhir.js';
import { ReferencerangeMeaningValueSet } from '../fhirValueSets/ReferencerangeMeaningValueSet.js';
import { ReferencerangeAppliestoValueSet } from '../fhirValueSets/ReferencerangeAppliestoValueSet.js';
import { ObservationCodesValueSet } from '../fhirValueSets/ObservationCodesValueSet.js';
import { DataAbsentReasonValueSet } from '../fhirValueSets/DataAbsentReasonValueSet.js';
import { ObservationInterpretationValueSet } from '../fhirValueSets/ObservationInterpretationValueSet.js';
import { ObservationStatusValueSet } from '../fhirValueSets/ObservationStatusValueSet.js';
import { ObservationCategoryValueSet } from '../fhirValueSets/ObservationCategoryValueSet.js';
import { BodySiteValueSet } from '../fhirValueSets/BodySiteValueSet.js';
import { ObservationMethodsValueSet } from '../fhirValueSets/ObservationMethodsValueSet.js';
/**
 * Most observations only have one generic reference range. Systems MAY choose to restrict to only supplying the relevant reference range based on knowledge about the patient (e.g., specific to the patient's age, gender, weight and other factors), but this might not be possible or appropriate. Whenever more than one reference range is supplied, the differences between them SHOULD be provided in the reference range and/or age properties.
 */
export class ObservationReferenceRange extends fhir.BackboneElement {
    /**
     * Default constructor for ObservationReferenceRange - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['low']) {
            this.low = new fhir.Quantity(source.low);
        }
        if (source['high']) {
            this.high = new fhir.Quantity(source.high);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['appliesTo']) {
            this.appliesTo = source.appliesTo.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['age']) {
            this.age = new fhir.Range(source.age);
        }
        if (source['text']) {
            this.text = source.text;
        }
        if (source['_text']) {
            this._text = new fhir.FhirElement(source._text);
        }
    }
    /**
     * Preferred-bound Value Set for type
     */
    static typePreferredValueSet() {
        return ReferencerangeMeaningValueSet;
    }
    /**
     * Example-bound Value Set for appliesTo
     */
    static appliesToExampleValueSet() {
        return ReferencerangeAppliestoValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["low"]) {
            results.push(...this.low.doModelValidation());
        }
        if (this["high"]) {
            results.push(...this.high.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["appliesTo"]) {
            this.appliesTo.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["age"]) {
            results.push(...this.age.doModelValidation());
        }
        if (this["_text"]) {
            results.push(...this._text.doModelValidation());
        }
        return results;
    }
}
/**
 * For a discussion on the ways Observations can be assembled in groups together see [Notes](observation.html#notes) below.
 */
export class ObservationComponent extends fhir.BackboneElement {
    /**
     * Default constructor for ObservationComponent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['valueQuantity']) {
            this.valueQuantity = new fhir.Quantity(source.valueQuantity);
        }
        if (source['valueCodeableConcept']) {
            this.valueCodeableConcept = new fhir.CodeableConcept(source.valueCodeableConcept);
        }
        if (source['valueString']) {
            this.valueString = source.valueString;
        }
        if (source['_valueString']) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source['valueBoolean']) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source['_valueBoolean']) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source['valueInteger']) {
            this.valueInteger = source.valueInteger;
        }
        if (source['_valueInteger']) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source['valueRange']) {
            this.valueRange = new fhir.Range(source.valueRange);
        }
        if (source['valueRatio']) {
            this.valueRatio = new fhir.Ratio(source.valueRatio);
        }
        if (source['valueSampledData']) {
            this.valueSampledData = new fhir.SampledData(source.valueSampledData);
        }
        if (source['valueTime']) {
            this.valueTime = source.valueTime;
        }
        if (source['_valueTime']) {
            this._valueTime = new fhir.FhirElement(source._valueTime);
        }
        if (source['valueDateTime']) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source['_valueDateTime']) {
            this._valueDateTime = new fhir.FhirElement(source._valueDateTime);
        }
        if (source['valuePeriod']) {
            this.valuePeriod = new fhir.Period(source.valuePeriod);
        }
        if (source['dataAbsentReason']) {
            this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason);
        }
        if (source['interpretation']) {
            this.interpretation = source.interpretation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['referenceRange']) {
            this.referenceRange = source.referenceRange.map((x) => new fhir.ObservationReferenceRange(x));
        }
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ObservationCodesValueSet;
    }
    /**
     * Extensible-bound Value Set for dataAbsentReason
     */
    static dataAbsentReasonExtensibleValueSet() {
        return DataAbsentReasonValueSet;
    }
    /**
     * Extensible-bound Value Set for interpretation
     */
    static interpretationExtensibleValueSet() {
        return ObservationInterpretationValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["code"]) {
            results.push(["code", 'Missing required element: Observation.component.code']);
        }
        if (this["code"]) {
            results.push(...this.code.doModelValidation());
        }
        if (this["valueQuantity"]) {
            results.push(...this.valueQuantity.doModelValidation());
        }
        if (this["valueCodeableConcept"]) {
            results.push(...this.valueCodeableConcept.doModelValidation());
        }
        if (this["_valueString"]) {
            results.push(...this._valueString.doModelValidation());
        }
        if (this["_valueBoolean"]) {
            results.push(...this._valueBoolean.doModelValidation());
        }
        if (this["_valueInteger"]) {
            results.push(...this._valueInteger.doModelValidation());
        }
        if (this["valueRange"]) {
            results.push(...this.valueRange.doModelValidation());
        }
        if (this["valueRatio"]) {
            results.push(...this.valueRatio.doModelValidation());
        }
        if (this["valueSampledData"]) {
            results.push(...this.valueSampledData.doModelValidation());
        }
        if (this["_valueTime"]) {
            results.push(...this._valueTime.doModelValidation());
        }
        if (this["_valueDateTime"]) {
            results.push(...this._valueDateTime.doModelValidation());
        }
        if (this["valuePeriod"]) {
            results.push(...this.valuePeriod.doModelValidation());
        }
        if (this["dataAbsentReason"]) {
            results.push(...this.dataAbsentReason.doModelValidation());
        }
        if (this["interpretation"]) {
            this.interpretation.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["referenceRange"]) {
            this.referenceRange.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Measurements and simple assertions made about a patient, device or other subject.
 */
export class Observation extends fhir.DomainResource {
    /**
     * Default constructor for Observation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Observation';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['basedOn']) {
            this.basedOn = source.basedOn.map((x) => new fhir.Reference(x));
        }
        if (source['partOf']) {
            this.partOf = source.partOf.map((x) => new fhir.Reference(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['category']) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source['focus']) {
            this.focus = source.focus.map((x) => new fhir.Reference(x));
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['effectiveDateTime']) {
            this.effectiveDateTime = source.effectiveDateTime;
        }
        if (source['_effectiveDateTime']) {
            this._effectiveDateTime = new fhir.FhirElement(source._effectiveDateTime);
        }
        if (source['effectivePeriod']) {
            this.effectivePeriod = new fhir.Period(source.effectivePeriod);
        }
        if (source['effectiveTiming']) {
            this.effectiveTiming = new fhir.Timing(source.effectiveTiming);
        }
        if (source['effectiveInstant']) {
            this.effectiveInstant = source.effectiveInstant;
        }
        if (source['_effectiveInstant']) {
            this._effectiveInstant = new fhir.FhirElement(source._effectiveInstant);
        }
        if (source['issued']) {
            this.issued = source.issued;
        }
        if (source['_issued']) {
            this._issued = new fhir.FhirElement(source._issued);
        }
        if (source['performer']) {
            this.performer = source.performer.map((x) => new fhir.Reference(x));
        }
        if (source['valueQuantity']) {
            this.valueQuantity = new fhir.Quantity(source.valueQuantity);
        }
        if (source['valueCodeableConcept']) {
            this.valueCodeableConcept = new fhir.CodeableConcept(source.valueCodeableConcept);
        }
        if (source['valueString']) {
            this.valueString = source.valueString;
        }
        if (source['_valueString']) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source['valueBoolean']) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source['_valueBoolean']) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source['valueInteger']) {
            this.valueInteger = source.valueInteger;
        }
        if (source['_valueInteger']) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source['valueRange']) {
            this.valueRange = new fhir.Range(source.valueRange);
        }
        if (source['valueRatio']) {
            this.valueRatio = new fhir.Ratio(source.valueRatio);
        }
        if (source['valueSampledData']) {
            this.valueSampledData = new fhir.SampledData(source.valueSampledData);
        }
        if (source['valueTime']) {
            this.valueTime = source.valueTime;
        }
        if (source['_valueTime']) {
            this._valueTime = new fhir.FhirElement(source._valueTime);
        }
        if (source['valueDateTime']) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source['_valueDateTime']) {
            this._valueDateTime = new fhir.FhirElement(source._valueDateTime);
        }
        if (source['valuePeriod']) {
            this.valuePeriod = new fhir.Period(source.valuePeriod);
        }
        if (source['dataAbsentReason']) {
            this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason);
        }
        if (source['interpretation']) {
            this.interpretation = source.interpretation.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source['bodySite']) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source['method']) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source['specimen']) {
            this.specimen = new fhir.Reference(source.specimen);
        }
        if (source['device']) {
            this.device = new fhir.Reference(source.device);
        }
        if (source['referenceRange']) {
            this.referenceRange = source.referenceRange.map((x) => new fhir.ObservationReferenceRange(x));
        }
        if (source['hasMember']) {
            this.hasMember = source.hasMember.map((x) => new fhir.Reference(x));
        }
        if (source['derivedFrom']) {
            this.derivedFrom = source.derivedFrom.map((x) => new fhir.Reference(x));
        }
        if (source['component']) {
            this.component = source.component.map((x) => new fhir.ObservationComponent(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return ObservationStatusValueSet;
    }
    /**
     * Preferred-bound Value Set for category
     */
    static categoryPreferredValueSet() {
        return ObservationCategoryValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ObservationCodesValueSet;
    }
    /**
     * Extensible-bound Value Set for dataAbsentReason
     */
    static dataAbsentReasonExtensibleValueSet() {
        return DataAbsentReasonValueSet;
    }
    /**
     * Extensible-bound Value Set for interpretation
     */
    static interpretationExtensibleValueSet() {
        return ObservationInterpretationValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return BodySiteValueSet;
    }
    /**
     * Example-bound Value Set for method
     */
    static methodExampleValueSet() {
        return ObservationMethodsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: Observation.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["basedOn"]) {
            this.basedOn.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["partOf"]) {
            this.partOf.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: Observation.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["category"]) {
            this.category.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["code"]) {
            results.push(["code", 'Missing required element: Observation.code']);
        }
        if (this["code"]) {
            results.push(...this.code.doModelValidation());
        }
        if (this["subject"]) {
            results.push(...this.subject.doModelValidation());
        }
        if (this["focus"]) {
            this.focus.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["encounter"]) {
            results.push(...this.encounter.doModelValidation());
        }
        if (this["_effectiveDateTime"]) {
            results.push(...this._effectiveDateTime.doModelValidation());
        }
        if (this["effectivePeriod"]) {
            results.push(...this.effectivePeriod.doModelValidation());
        }
        if (this["effectiveTiming"]) {
            results.push(...this.effectiveTiming.doModelValidation());
        }
        if (this["_effectiveInstant"]) {
            results.push(...this._effectiveInstant.doModelValidation());
        }
        if (this["_issued"]) {
            results.push(...this._issued.doModelValidation());
        }
        if (this["performer"]) {
            this.performer.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["valueQuantity"]) {
            results.push(...this.valueQuantity.doModelValidation());
        }
        if (this["valueCodeableConcept"]) {
            results.push(...this.valueCodeableConcept.doModelValidation());
        }
        if (this["_valueString"]) {
            results.push(...this._valueString.doModelValidation());
        }
        if (this["_valueBoolean"]) {
            results.push(...this._valueBoolean.doModelValidation());
        }
        if (this["_valueInteger"]) {
            results.push(...this._valueInteger.doModelValidation());
        }
        if (this["valueRange"]) {
            results.push(...this.valueRange.doModelValidation());
        }
        if (this["valueRatio"]) {
            results.push(...this.valueRatio.doModelValidation());
        }
        if (this["valueSampledData"]) {
            results.push(...this.valueSampledData.doModelValidation());
        }
        if (this["_valueTime"]) {
            results.push(...this._valueTime.doModelValidation());
        }
        if (this["_valueDateTime"]) {
            results.push(...this._valueDateTime.doModelValidation());
        }
        if (this["valuePeriod"]) {
            results.push(...this.valuePeriod.doModelValidation());
        }
        if (this["dataAbsentReason"]) {
            results.push(...this.dataAbsentReason.doModelValidation());
        }
        if (this["interpretation"]) {
            this.interpretation.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["note"]) {
            this.note.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["bodySite"]) {
            results.push(...this.bodySite.doModelValidation());
        }
        if (this["method"]) {
            results.push(...this.method.doModelValidation());
        }
        if (this["specimen"]) {
            results.push(...this.specimen.doModelValidation());
        }
        if (this["device"]) {
            results.push(...this.device.doModelValidation());
        }
        if (this["referenceRange"]) {
            this.referenceRange.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["hasMember"]) {
            this.hasMember.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["derivedFrom"]) {
            this.derivedFrom.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["component"]) {
            this.component.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=Observation.js.map