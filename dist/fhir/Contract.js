// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Contract
import * as fhir from '../fhir.js';
import { ContractDefinitionTypeValueSet } from '../fhirValueSets/ContractDefinitionTypeValueSet.js';
import { ContractDefinitionSubtypeValueSet } from '../fhirValueSets/ContractDefinitionSubtypeValueSet.js';
import { ContractPublicationstatusValueSet } from '../fhirValueSets/ContractPublicationstatusValueSet.js';
import { ContractSecurityClassificationValueSet } from '../fhirValueSets/ContractSecurityClassificationValueSet.js';
import { ContractSecurityCategoryValueSet } from '../fhirValueSets/ContractSecurityCategoryValueSet.js';
import { ContractSecurityControlValueSet } from '../fhirValueSets/ContractSecurityControlValueSet.js';
import { ContractPartyRoleValueSet } from '../fhirValueSets/ContractPartyRoleValueSet.js';
import { ContractTermTypeValueSet } from '../fhirValueSets/ContractTermTypeValueSet.js';
import { V3ActConsentDirectiveValueSet } from '../fhirValueSets/V3ActConsentDirectiveValueSet.js';
import { ContractDecisionModeValueSet } from '../fhirValueSets/ContractDecisionModeValueSet.js';
import { ContractAssetcontextValueSet } from '../fhirValueSets/ContractAssetcontextValueSet.js';
import { ContractAssetscopeValueSet } from '../fhirValueSets/ContractAssetscopeValueSet.js';
import { ContractAssettypeValueSet } from '../fhirValueSets/ContractAssettypeValueSet.js';
import { ContractAssetsubtypeValueSet } from '../fhirValueSets/ContractAssetsubtypeValueSet.js';
import { ConsentContentClassValueSet } from '../fhirValueSets/ConsentContentClassValueSet.js';
import { AssetAvailabilityValueSet } from '../fhirValueSets/AssetAvailabilityValueSet.js';
import { ContractActorroleValueSet } from '../fhirValueSets/ContractActorroleValueSet.js';
import { ContractActionValueSet } from '../fhirValueSets/ContractActionValueSet.js';
import { V3PurposeOfUseValueSet } from '../fhirValueSets/V3PurposeOfUseValueSet.js';
import { ContractActionstatusValueSet } from '../fhirValueSets/ContractActionstatusValueSet.js';
import { ProvenanceAgentTypeValueSet } from '../fhirValueSets/ProvenanceAgentTypeValueSet.js';
import { ProvenanceAgentRoleValueSet } from '../fhirValueSets/ProvenanceAgentRoleValueSet.js';
import { ContractTermSubtypeValueSet } from '../fhirValueSets/ContractTermSubtypeValueSet.js';
import { ContractSignerTypeValueSet } from '../fhirValueSets/ContractSignerTypeValueSet.js';
import { ContractStatusValueSet } from '../fhirValueSets/ContractStatusValueSet.js';
import { ContractLegalstateValueSet } from '../fhirValueSets/ContractLegalstateValueSet.js';
import { ContractContentDerivativeValueSet } from '../fhirValueSets/ContractContentDerivativeValueSet.js';
import { ContractExpirationTypeValueSet } from '../fhirValueSets/ContractExpirationTypeValueSet.js';
import { ContractScopeValueSet } from '../fhirValueSets/ContractScopeValueSet.js';
import { ContractTypeValueSet } from '../fhirValueSets/ContractTypeValueSet.js';
import { ContractSubtypeValueSet } from '../fhirValueSets/ContractSubtypeValueSet.js';
/**
 * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
 */
export class ContractContentDefinition extends fhir.BackboneElement {
    /**
     * Default constructor for ContractContentDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['subType']) {
            this.subType = new fhir.CodeableConcept(source.subType);
        }
        if (source['publisher']) {
            this.publisher = new fhir.Reference(source.publisher);
        }
        if (source['publicationDate']) {
            this.publicationDate = source.publicationDate;
        }
        if (source['_publicationDate']) {
            this._publicationDate = new fhir.FhirElement(source._publicationDate);
        }
        if (source['publicationStatus']) {
            this.publicationStatus = source.publicationStatus;
        }
        else {
            this.publicationStatus = null;
        }
        if (source['_publicationStatus']) {
            this._publicationStatus = new fhir.FhirElement(source._publicationStatus);
        }
        if (source['copyright']) {
            this.copyright = source.copyright;
        }
        if (source['_copyright']) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return ContractDefinitionTypeValueSet;
    }
    /**
     * Example-bound Value Set for subType
     */
    subTypeExampleValueSet() {
        return ContractDefinitionSubtypeValueSet;
    }
    /**
     * Required-bound Value Set for publicationStatus
     */
    publicationStatusRequiredValueSet() {
        return ContractPublicationstatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["type"]) {
            results.push(["type", 'Missing required element: Contract.contentDefinition.type']);
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["subType"]) {
            results.push(...this.subType.doModelValidation());
        }
        if (this["publisher"]) {
            results.push(...this.publisher.doModelValidation());
        }
        if (this["_publicationDate"]) {
            results.push(...this._publicationDate.doModelValidation());
        }
        if (!this["publicationStatus"]) {
            results.push(["publicationStatus", 'Missing required element: Contract.contentDefinition.publicationStatus']);
        }
        if (this["_publicationStatus"]) {
            results.push(...this._publicationStatus.doModelValidation());
        }
        if (this["_copyright"]) {
            results.push(...this._copyright.doModelValidation());
        }
        return results;
    }
}
/**
 * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
 */
export class ContractTermSecurityLabel extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermSecurityLabel - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['number']) {
            this.number = source.number.map((x) => (x));
        }
        if (source['_number']) {
            this._number = source._number.map((x) => new fhir.FhirElement(x));
        }
        if (source['classification']) {
            this.classification = new fhir.Coding(source.classification);
        }
        else {
            this.classification = null;
        }
        if (source['category']) {
            this.category = source.category.map((x) => new fhir.Coding(x));
        }
        if (source['control']) {
            this.control = source.control.map((x) => new fhir.Coding(x));
        }
    }
    /**
     * Example-bound Value Set for classification
     */
    classificationExampleValueSet() {
        return ContractSecurityClassificationValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    categoryExampleValueSet() {
        return ContractSecurityCategoryValueSet;
    }
    /**
     * Example-bound Value Set for control
     */
    controlExampleValueSet() {
        return ContractSecurityControlValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_number"]) {
            this._number.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["classification"]) {
            results.push(["classification", 'Missing required element: Contract.term.securityLabel.classification']);
        }
        if (this["classification"]) {
            results.push(...this.classification.doModelValidation());
        }
        if (this["category"]) {
            this.category.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["control"]) {
            this.control.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Offer Recipient.
 */
export class ContractTermOfferParty extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermOfferParty - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['reference']) {
            this.reference = source.reference.map((x) => new fhir.Reference(x));
        }
        else {
            this.reference = null;
        }
        if (source['role']) {
            this.role = new fhir.CodeableConcept(source.role);
        }
        else {
            this.role = null;
        }
    }
    /**
     * Example-bound Value Set for role
     */
    roleExampleValueSet() {
        return ContractPartyRoleValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if ((!this["reference"]) || (this["reference"].length === 0)) {
            results.push(["reference", 'Missing required element: Contract.term.offer.party.reference']);
        }
        if (this["reference"]) {
            this.reference.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["role"]) {
            results.push(["role", 'Missing required element: Contract.term.offer.party.role']);
        }
        if (this["role"]) {
            results.push(...this.role.doModelValidation());
        }
        return results;
    }
}
/**
 * Response to offer text.
 */
export class ContractTermOfferAnswer extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermOfferAnswer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['valueBoolean']) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source['_valueBoolean']) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source['valueDecimal']) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source['_valueDecimal']) {
            this._valueDecimal = new fhir.FhirElement(source._valueDecimal);
        }
        if (source['valueInteger']) {
            this.valueInteger = source.valueInteger;
        }
        if (source['_valueInteger']) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source['valueDate']) {
            this.valueDate = source.valueDate;
        }
        if (source['_valueDate']) {
            this._valueDate = new fhir.FhirElement(source._valueDate);
        }
        if (source['valueDateTime']) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source['_valueDateTime']) {
            this._valueDateTime = new fhir.FhirElement(source._valueDateTime);
        }
        if (source['valueTime']) {
            this.valueTime = source.valueTime;
        }
        if (source['_valueTime']) {
            this._valueTime = new fhir.FhirElement(source._valueTime);
        }
        if (source['valueString']) {
            this.valueString = source.valueString;
        }
        if (source['_valueString']) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source['valueUri']) {
            this.valueUri = source.valueUri;
        }
        if (source['_valueUri']) {
            this._valueUri = new fhir.FhirElement(source._valueUri);
        }
        if (source['valueAttachment']) {
            this.valueAttachment = new fhir.Attachment(source.valueAttachment);
        }
        if (source['valueCoding']) {
            this.valueCoding = new fhir.Coding(source.valueCoding);
        }
        if (source['valueQuantity']) {
            this.valueQuantity = new fhir.Quantity(source.valueQuantity);
        }
        if (source['valueReference']) {
            this.valueReference = new fhir.Reference(source.valueReference);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_valueBoolean"]) {
            results.push(...this._valueBoolean.doModelValidation());
        }
        if (this["_valueDecimal"]) {
            results.push(...this._valueDecimal.doModelValidation());
        }
        if (this["_valueInteger"]) {
            results.push(...this._valueInteger.doModelValidation());
        }
        if (this["_valueDate"]) {
            results.push(...this._valueDate.doModelValidation());
        }
        if (this["_valueDateTime"]) {
            results.push(...this._valueDateTime.doModelValidation());
        }
        if (this["_valueTime"]) {
            results.push(...this._valueTime.doModelValidation());
        }
        if (this["_valueString"]) {
            results.push(...this._valueString.doModelValidation());
        }
        if (this["_valueUri"]) {
            results.push(...this._valueUri.doModelValidation());
        }
        if (this["valueAttachment"]) {
            results.push(...this.valueAttachment.doModelValidation());
        }
        if (this["valueCoding"]) {
            results.push(...this.valueCoding.doModelValidation());
        }
        if (this["valueQuantity"]) {
            results.push(...this.valueQuantity.doModelValidation());
        }
        if (this["valueReference"]) {
            results.push(...this.valueReference.doModelValidation());
        }
        return results;
    }
}
/**
 * The matter of concern in the context of this provision of the agrement.
 */
export class ContractTermOffer extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermOffer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['party']) {
            this.party = source.party.map((x) => new fhir.ContractTermOfferParty(x));
        }
        if (source['topic']) {
            this.topic = new fhir.Reference(source.topic);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['decision']) {
            this.decision = new fhir.CodeableConcept(source.decision);
        }
        if (source['decisionMode']) {
            this.decisionMode = source.decisionMode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['answer']) {
            this.answer = source.answer.map((x) => new fhir.ContractTermOfferAnswer(x));
        }
        if (source['text']) {
            this.text = source.text;
        }
        if (source['_text']) {
            this._text = new fhir.FhirElement(source._text);
        }
        if (source['linkId']) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source['_linkId']) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['securityLabelNumber']) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source['_securityLabelNumber']) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return ContractTermTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for decision
     */
    decisionExtensibleValueSet() {
        return V3ActConsentDirectiveValueSet;
    }
    /**
     * Example-bound Value Set for decisionMode
     */
    decisionModeExampleValueSet() {
        return ContractDecisionModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["party"]) {
            this.party.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["topic"]) {
            results.push(...this.topic.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["decision"]) {
            results.push(...this.decision.doModelValidation());
        }
        if (this["decisionMode"]) {
            this.decisionMode.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["answer"]) {
            this.answer.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_text"]) {
            results.push(...this._text.doModelValidation());
        }
        if (this["_linkId"]) {
            this._linkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_securityLabelNumber"]) {
            this._securityLabelNumber.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Circumstance of the asset.
 */
export class ContractTermAssetContext extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAssetContext - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['reference']) {
            this.reference = new fhir.Reference(source.reference);
        }
        if (source['code']) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['text']) {
            this.text = source.text;
        }
        if (source['_text']) {
            this._text = new fhir.FhirElement(source._text);
        }
    }
    /**
     * Example-bound Value Set for code
     */
    codeExampleValueSet() {
        return ContractAssetcontextValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["reference"]) {
            results.push(...this.reference.doModelValidation());
        }
        if (this["code"]) {
            this.code.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_text"]) {
            results.push(...this._text.doModelValidation());
        }
        return results;
    }
}
/**
 * Contract Valued Item List.
 */
export class ContractTermAssetValuedItem extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAssetValuedItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['entityCodeableConcept']) {
            this.entityCodeableConcept = new fhir.CodeableConcept(source.entityCodeableConcept);
        }
        if (source['entityReference']) {
            this.entityReference = new fhir.Reference(source.entityReference);
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['effectiveTime']) {
            this.effectiveTime = source.effectiveTime;
        }
        if (source['_effectiveTime']) {
            this._effectiveTime = new fhir.FhirElement(source._effectiveTime);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = source.factor;
        }
        if (source['_factor']) {
            this._factor = new fhir.FhirElement(source._factor);
        }
        if (source['points']) {
            this.points = source.points;
        }
        if (source['_points']) {
            this._points = new fhir.FhirElement(source._points);
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['payment']) {
            this.payment = source.payment;
        }
        if (source['_payment']) {
            this._payment = new fhir.FhirElement(source._payment);
        }
        if (source['paymentDate']) {
            this.paymentDate = source.paymentDate;
        }
        if (source['_paymentDate']) {
            this._paymentDate = new fhir.FhirElement(source._paymentDate);
        }
        if (source['responsible']) {
            this.responsible = new fhir.Reference(source.responsible);
        }
        if (source['recipient']) {
            this.recipient = new fhir.Reference(source.recipient);
        }
        if (source['linkId']) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source['_linkId']) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['securityLabelNumber']) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source['_securityLabelNumber']) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["entityCodeableConcept"]) {
            results.push(...this.entityCodeableConcept.doModelValidation());
        }
        if (this["entityReference"]) {
            results.push(...this.entityReference.doModelValidation());
        }
        if (this["identifier"]) {
            results.push(...this.identifier.doModelValidation());
        }
        if (this["_effectiveTime"]) {
            results.push(...this._effectiveTime.doModelValidation());
        }
        if (this["quantity"]) {
            results.push(...this.quantity.doModelValidation());
        }
        if (this["unitPrice"]) {
            results.push(...this.unitPrice.doModelValidation());
        }
        if (this["_factor"]) {
            results.push(...this._factor.doModelValidation());
        }
        if (this["_points"]) {
            results.push(...this._points.doModelValidation());
        }
        if (this["net"]) {
            results.push(...this.net.doModelValidation());
        }
        if (this["_payment"]) {
            results.push(...this._payment.doModelValidation());
        }
        if (this["_paymentDate"]) {
            results.push(...this._paymentDate.doModelValidation());
        }
        if (this["responsible"]) {
            results.push(...this.responsible.doModelValidation());
        }
        if (this["recipient"]) {
            results.push(...this.recipient.doModelValidation());
        }
        if (this["_linkId"]) {
            this._linkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_securityLabelNumber"]) {
            this._securityLabelNumber.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Contract Term Asset List.
 */
export class ContractTermAsset extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAsset - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['scope']) {
            this.scope = new fhir.CodeableConcept(source.scope);
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['typeReference']) {
            this.typeReference = source.typeReference.map((x) => new fhir.Reference(x));
        }
        if (source['subtype']) {
            this.subtype = source.subtype.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['relationship']) {
            this.relationship = new fhir.Coding(source.relationship);
        }
        if (source['context']) {
            this.context = source.context.map((x) => new fhir.ContractTermAssetContext(x));
        }
        if (source['condition']) {
            this.condition = source.condition;
        }
        if (source['_condition']) {
            this._condition = new fhir.FhirElement(source._condition);
        }
        if (source['periodType']) {
            this.periodType = source.periodType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['period']) {
            this.period = source.period.map((x) => new fhir.Period(x));
        }
        if (source['usePeriod']) {
            this.usePeriod = source.usePeriod.map((x) => new fhir.Period(x));
        }
        if (source['text']) {
            this.text = source.text;
        }
        if (source['_text']) {
            this._text = new fhir.FhirElement(source._text);
        }
        if (source['linkId']) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source['_linkId']) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['answer']) {
            this.answer = source.answer.map((x) => new fhir.ContractTermOfferAnswer(x));
        }
        if (source['securityLabelNumber']) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source['_securityLabelNumber']) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
        if (source['valuedItem']) {
            this.valuedItem = source.valuedItem.map((x) => new fhir.ContractTermAssetValuedItem(x));
        }
    }
    /**
     * Example-bound Value Set for scope
     */
    scopeExampleValueSet() {
        return ContractAssetscopeValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return ContractAssettypeValueSet;
    }
    /**
     * Example-bound Value Set for subtype
     */
    subtypeExampleValueSet() {
        return ContractAssetsubtypeValueSet;
    }
    /**
     * Extensible-bound Value Set for relationship
     */
    relationshipExtensibleValueSet() {
        return ConsentContentClassValueSet;
    }
    /**
     * Example-bound Value Set for periodType
     */
    periodTypeExampleValueSet() {
        return AssetAvailabilityValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["scope"]) {
            results.push(...this.scope.doModelValidation());
        }
        if (this["type"]) {
            this.type.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["typeReference"]) {
            this.typeReference.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["subtype"]) {
            this.subtype.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["relationship"]) {
            results.push(...this.relationship.doModelValidation());
        }
        if (this["context"]) {
            this.context.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_condition"]) {
            results.push(...this._condition.doModelValidation());
        }
        if (this["periodType"]) {
            this.periodType.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["period"]) {
            this.period.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["usePeriod"]) {
            this.usePeriod.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_text"]) {
            results.push(...this._text.doModelValidation());
        }
        if (this["_linkId"]) {
            this._linkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["answer"]) {
            this.answer.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_securityLabelNumber"]) {
            this._securityLabelNumber.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["valuedItem"]) {
            this.valuedItem.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Entity of the action.
 */
export class ContractTermActionSubject extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermActionSubject - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['reference']) {
            this.reference = source.reference.map((x) => new fhir.Reference(x));
        }
        else {
            this.reference = null;
        }
        if (source['role']) {
            this.role = new fhir.CodeableConcept(source.role);
        }
    }
    /**
     * Example-bound Value Set for role
     */
    roleExampleValueSet() {
        return ContractActorroleValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if ((!this["reference"]) || (this["reference"].length === 0)) {
            results.push(["reference", 'Missing required element: Contract.term.action.subject.reference']);
        }
        if (this["reference"]) {
            this.reference.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["role"]) {
            results.push(...this.role.doModelValidation());
        }
        return results;
    }
}
/**
 * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
 * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
 */
export class ContractTermAction extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['doNotPerform']) {
            this.doNotPerform = source.doNotPerform;
        }
        if (source['_doNotPerform']) {
            this._doNotPerform = new fhir.FhirElement(source._doNotPerform);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['subject']) {
            this.subject = source.subject.map((x) => new fhir.ContractTermActionSubject(x));
        }
        if (source['intent']) {
            this.intent = new fhir.CodeableConcept(source.intent);
        }
        else {
            this.intent = null;
        }
        if (source['linkId']) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source['_linkId']) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['status']) {
            this.status = new fhir.CodeableConcept(source.status);
        }
        else {
            this.status = null;
        }
        if (source['context']) {
            this.context = new fhir.Reference(source.context);
        }
        if (source['contextLinkId']) {
            this.contextLinkId = source.contextLinkId.map((x) => (x));
        }
        if (source['_contextLinkId']) {
            this._contextLinkId = source._contextLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['occurrenceDateTime']) {
            this.occurrenceDateTime = source.occurrenceDateTime;
        }
        if (source['_occurrenceDateTime']) {
            this._occurrenceDateTime = new fhir.FhirElement(source._occurrenceDateTime);
        }
        if (source['occurrencePeriod']) {
            this.occurrencePeriod = new fhir.Period(source.occurrencePeriod);
        }
        if (source['occurrenceTiming']) {
            this.occurrenceTiming = new fhir.Timing(source.occurrenceTiming);
        }
        if (source['requester']) {
            this.requester = source.requester.map((x) => new fhir.Reference(x));
        }
        if (source['requesterLinkId']) {
            this.requesterLinkId = source.requesterLinkId.map((x) => (x));
        }
        if (source['_requesterLinkId']) {
            this._requesterLinkId = source._requesterLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['performerType']) {
            this.performerType = source.performerType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['performerRole']) {
            this.performerRole = new fhir.CodeableConcept(source.performerRole);
        }
        if (source['performer']) {
            this.performer = new fhir.Reference(source.performer);
        }
        if (source['performerLinkId']) {
            this.performerLinkId = source.performerLinkId.map((x) => (x));
        }
        if (source['_performerLinkId']) {
            this._performerLinkId = source._performerLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['reasonCode']) {
            this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['reasonReference']) {
            this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x));
        }
        if (source['reason']) {
            this.reason = source.reason.map((x) => (x));
        }
        if (source['_reason']) {
            this._reason = source._reason.map((x) => new fhir.FhirElement(x));
        }
        if (source['reasonLinkId']) {
            this.reasonLinkId = source.reasonLinkId.map((x) => (x));
        }
        if (source['_reasonLinkId']) {
            this._reasonLinkId = source._reasonLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source['securityLabelNumber']) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source['_securityLabelNumber']) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return ContractActionValueSet;
    }
    /**
     * Example-bound Value Set for intent
     */
    intentExampleValueSet() {
        return V3PurposeOfUseValueSet;
    }
    /**
     * Example-bound Value Set for status
     */
    statusExampleValueSet() {
        return ContractActionstatusValueSet;
    }
    /**
     * Example-bound Value Set for performerType
     */
    performerTypeExampleValueSet() {
        return ProvenanceAgentTypeValueSet;
    }
    /**
     * Example-bound Value Set for performerRole
     */
    performerRoleExampleValueSet() {
        return ProvenanceAgentRoleValueSet;
    }
    /**
     * Example-bound Value Set for reasonCode
     */
    reasonCodeExampleValueSet() {
        return V3PurposeOfUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_doNotPerform"]) {
            results.push(...this._doNotPerform.doModelValidation());
        }
        if (!this["type"]) {
            results.push(["type", 'Missing required element: Contract.term.action.type']);
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["subject"]) {
            this.subject.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["intent"]) {
            results.push(["intent", 'Missing required element: Contract.term.action.intent']);
        }
        if (this["intent"]) {
            results.push(...this.intent.doModelValidation());
        }
        if (this["_linkId"]) {
            this._linkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: Contract.term.action.status']);
        }
        if (this["status"]) {
            results.push(...this.status.doModelValidation());
        }
        if (this["context"]) {
            results.push(...this.context.doModelValidation());
        }
        if (this["_contextLinkId"]) {
            this._contextLinkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_occurrenceDateTime"]) {
            results.push(...this._occurrenceDateTime.doModelValidation());
        }
        if (this["occurrencePeriod"]) {
            results.push(...this.occurrencePeriod.doModelValidation());
        }
        if (this["occurrenceTiming"]) {
            results.push(...this.occurrenceTiming.doModelValidation());
        }
        if (this["requester"]) {
            this.requester.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_requesterLinkId"]) {
            this._requesterLinkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["performerType"]) {
            this.performerType.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["performerRole"]) {
            results.push(...this.performerRole.doModelValidation());
        }
        if (this["performer"]) {
            results.push(...this.performer.doModelValidation());
        }
        if (this["_performerLinkId"]) {
            this._performerLinkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["reasonCode"]) {
            this.reasonCode.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["reasonReference"]) {
            this.reasonReference.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_reason"]) {
            this._reason.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_reasonLinkId"]) {
            this._reasonLinkId.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["note"]) {
            this.note.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_securityLabelNumber"]) {
            this._securityLabelNumber.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
 */
export class ContractTerm extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTerm - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['issued']) {
            this.issued = source.issued;
        }
        if (source['_issued']) {
            this._issued = new fhir.FhirElement(source._issued);
        }
        if (source['applies']) {
            this.applies = new fhir.Period(source.applies);
        }
        if (source['topicCodeableConcept']) {
            this.topicCodeableConcept = new fhir.CodeableConcept(source.topicCodeableConcept);
        }
        if (source['topicReference']) {
            this.topicReference = new fhir.Reference(source.topicReference);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['subType']) {
            this.subType = new fhir.CodeableConcept(source.subType);
        }
        if (source['text']) {
            this.text = source.text;
        }
        if (source['_text']) {
            this._text = new fhir.FhirElement(source._text);
        }
        if (source['securityLabel']) {
            this.securityLabel = source.securityLabel.map((x) => new fhir.ContractTermSecurityLabel(x));
        }
        if (source['offer']) {
            this.offer = new fhir.ContractTermOffer(source.offer);
        }
        else {
            this.offer = null;
        }
        if (source['asset']) {
            this.asset = source.asset.map((x) => new fhir.ContractTermAsset(x));
        }
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.ContractTermAction(x));
        }
        if (source['group']) {
            this.group = source.group.map((x) => new fhir.ContractTerm(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return ContractTermTypeValueSet;
    }
    /**
     * Example-bound Value Set for subType
     */
    subTypeExampleValueSet() {
        return ContractTermSubtypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["identifier"]) {
            results.push(...this.identifier.doModelValidation());
        }
        if (this["_issued"]) {
            results.push(...this._issued.doModelValidation());
        }
        if (this["applies"]) {
            results.push(...this.applies.doModelValidation());
        }
        if (this["topicCodeableConcept"]) {
            results.push(...this.topicCodeableConcept.doModelValidation());
        }
        if (this["topicReference"]) {
            results.push(...this.topicReference.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["subType"]) {
            results.push(...this.subType.doModelValidation());
        }
        if (this["_text"]) {
            results.push(...this._text.doModelValidation());
        }
        if (this["securityLabel"]) {
            this.securityLabel.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["offer"]) {
            results.push(["offer", 'Missing required element: Contract.term.offer']);
        }
        if (this["offer"]) {
            results.push(...this.offer.doModelValidation());
        }
        if (this["asset"]) {
            this.asset.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["action"]) {
            this.action.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["group"]) {
            this.group.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
 * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
 */
export class ContractSigner extends fhir.BackboneElement {
    /**
     * Default constructor for ContractSigner - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        else {
            this.type = null;
        }
        if (source['party']) {
            this.party = new fhir.Reference(source.party);
        }
        else {
            this.party = null;
        }
        if (source['signature']) {
            this.signature = source.signature.map((x) => new fhir.Signature(x));
        }
        else {
            this.signature = null;
        }
    }
    /**
     * Preferred-bound Value Set for type
     */
    typePreferredValueSet() {
        return ContractSignerTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["type"]) {
            results.push(["type", 'Missing required element: Contract.signer.type']);
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (!this["party"]) {
            results.push(["party", 'Missing required element: Contract.signer.party']);
        }
        if (this["party"]) {
            results.push(...this.party.doModelValidation());
        }
        if ((!this["signature"]) || (this["signature"].length === 0)) {
            results.push(["signature", 'Missing required element: Contract.signer.signature']);
        }
        if (this["signature"]) {
            this.signature.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
 */
export class ContractFriendly extends fhir.BackboneElement {
    /**
     * Default constructor for ContractFriendly - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['contentAttachment']) {
            this.contentAttachment = new fhir.Attachment(source.contentAttachment);
        }
        if (source['contentReference']) {
            this.contentReference = new fhir.Reference(source.contentReference);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["contentAttachment"]) {
            results.push(...this.contentAttachment.doModelValidation());
        }
        if (this["contentReference"]) {
            results.push(...this.contentReference.doModelValidation());
        }
        return results;
    }
}
/**
 * List of Legal expressions or representations of this Contract.
 */
export class ContractLegal extends fhir.BackboneElement {
    /**
     * Default constructor for ContractLegal - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['contentAttachment']) {
            this.contentAttachment = new fhir.Attachment(source.contentAttachment);
        }
        if (source['contentReference']) {
            this.contentReference = new fhir.Reference(source.contentReference);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["contentAttachment"]) {
            results.push(...this.contentAttachment.doModelValidation());
        }
        if (this["contentReference"]) {
            results.push(...this.contentReference.doModelValidation());
        }
        return results;
    }
}
/**
 * List of Computable Policy Rule Language Representations of this Contract.
 */
export class ContractRule extends fhir.BackboneElement {
    /**
     * Default constructor for ContractRule - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['contentAttachment']) {
            this.contentAttachment = new fhir.Attachment(source.contentAttachment);
        }
        if (source['contentReference']) {
            this.contentReference = new fhir.Reference(source.contentReference);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["contentAttachment"]) {
            results.push(...this.contentAttachment.doModelValidation());
        }
        if (this["contentReference"]) {
            results.push(...this.contentReference.doModelValidation());
        }
        return results;
    }
}
/**
 * Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
 */
export class Contract extends fhir.DomainResource {
    /**
     * Default constructor for Contract - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Contract';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
        if (source['status']) {
            this.status = source.status;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['legalState']) {
            this.legalState = new fhir.CodeableConcept(source.legalState);
        }
        if (source['instantiatesCanonical']) {
            this.instantiatesCanonical = new fhir.Reference(source.instantiatesCanonical);
        }
        if (source['instantiatesUri']) {
            this.instantiatesUri = source.instantiatesUri;
        }
        if (source['_instantiatesUri']) {
            this._instantiatesUri = new fhir.FhirElement(source._instantiatesUri);
        }
        if (source['contentDerivative']) {
            this.contentDerivative = new fhir.CodeableConcept(source.contentDerivative);
        }
        if (source['issued']) {
            this.issued = source.issued;
        }
        if (source['_issued']) {
            this._issued = new fhir.FhirElement(source._issued);
        }
        if (source['applies']) {
            this.applies = new fhir.Period(source.applies);
        }
        if (source['expirationType']) {
            this.expirationType = new fhir.CodeableConcept(source.expirationType);
        }
        if (source['subject']) {
            this.subject = source.subject.map((x) => new fhir.Reference(x));
        }
        if (source['authority']) {
            this.authority = source.authority.map((x) => new fhir.Reference(x));
        }
        if (source['domain']) {
            this.domain = source.domain.map((x) => new fhir.Reference(x));
        }
        if (source['site']) {
            this.site = source.site.map((x) => new fhir.Reference(x));
        }
        if (source['name']) {
            this.name = source.name;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['title']) {
            this.title = source.title;
        }
        if (source['_title']) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source['subtitle']) {
            this.subtitle = source.subtitle;
        }
        if (source['_subtitle']) {
            this._subtitle = new fhir.FhirElement(source._subtitle);
        }
        if (source['alias']) {
            this.alias = source.alias.map((x) => (x));
        }
        if (source['_alias']) {
            this._alias = source._alias.map((x) => new fhir.FhirElement(x));
        }
        if (source['author']) {
            this.author = new fhir.Reference(source.author);
        }
        if (source['scope']) {
            this.scope = new fhir.CodeableConcept(source.scope);
        }
        if (source['topicCodeableConcept']) {
            this.topicCodeableConcept = new fhir.CodeableConcept(source.topicCodeableConcept);
        }
        if (source['topicReference']) {
            this.topicReference = new fhir.Reference(source.topicReference);
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['subType']) {
            this.subType = source.subType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['contentDefinition']) {
            this.contentDefinition = new fhir.ContractContentDefinition(source.contentDefinition);
        }
        if (source['term']) {
            this.term = source.term.map((x) => new fhir.ContractTerm(x));
        }
        if (source['supportingInfo']) {
            this.supportingInfo = source.supportingInfo.map((x) => new fhir.Reference(x));
        }
        if (source['relevantHistory']) {
            this.relevantHistory = source.relevantHistory.map((x) => new fhir.Reference(x));
        }
        if (source['signer']) {
            this.signer = source.signer.map((x) => new fhir.ContractSigner(x));
        }
        if (source['friendly']) {
            this.friendly = source.friendly.map((x) => new fhir.ContractFriendly(x));
        }
        if (source['legal']) {
            this.legal = source.legal.map((x) => new fhir.ContractLegal(x));
        }
        if (source['rule']) {
            this.rule = source.rule.map((x) => new fhir.ContractRule(x));
        }
        if (source['legallyBindingAttachment']) {
            this.legallyBindingAttachment = new fhir.Attachment(source.legallyBindingAttachment);
        }
        if (source['legallyBindingReference']) {
            this.legallyBindingReference = new fhir.Reference(source.legallyBindingReference);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    statusRequiredValueSet() {
        return ContractStatusValueSet;
    }
    /**
     * Extensible-bound Value Set for legalState
     */
    legalStateExtensibleValueSet() {
        return ContractLegalstateValueSet;
    }
    /**
     * Example-bound Value Set for contentDerivative
     */
    contentDerivativeExampleValueSet() {
        return ContractContentDerivativeValueSet;
    }
    /**
     * Example-bound Value Set for expirationType
     */
    expirationTypeExampleValueSet() {
        return ContractExpirationTypeValueSet;
    }
    /**
     * Example-bound Value Set for scope
     */
    scopeExampleValueSet() {
        return ContractScopeValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    typeExampleValueSet() {
        return ContractTypeValueSet;
    }
    /**
     * Example-bound Value Set for subType
     */
    subTypeExampleValueSet() {
        return ContractSubtypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: Contract.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["legalState"]) {
            results.push(...this.legalState.doModelValidation());
        }
        if (this["instantiatesCanonical"]) {
            results.push(...this.instantiatesCanonical.doModelValidation());
        }
        if (this["_instantiatesUri"]) {
            results.push(...this._instantiatesUri.doModelValidation());
        }
        if (this["contentDerivative"]) {
            results.push(...this.contentDerivative.doModelValidation());
        }
        if (this["_issued"]) {
            results.push(...this._issued.doModelValidation());
        }
        if (this["applies"]) {
            results.push(...this.applies.doModelValidation());
        }
        if (this["expirationType"]) {
            results.push(...this.expirationType.doModelValidation());
        }
        if (this["subject"]) {
            this.subject.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["authority"]) {
            this.authority.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["domain"]) {
            this.domain.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["site"]) {
            this.site.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_title"]) {
            results.push(...this._title.doModelValidation());
        }
        if (this["_subtitle"]) {
            results.push(...this._subtitle.doModelValidation());
        }
        if (this["_alias"]) {
            this._alias.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["author"]) {
            results.push(...this.author.doModelValidation());
        }
        if (this["scope"]) {
            results.push(...this.scope.doModelValidation());
        }
        if (this["topicCodeableConcept"]) {
            results.push(...this.topicCodeableConcept.doModelValidation());
        }
        if (this["topicReference"]) {
            results.push(...this.topicReference.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["subType"]) {
            this.subType.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["contentDefinition"]) {
            results.push(...this.contentDefinition.doModelValidation());
        }
        if (this["term"]) {
            this.term.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["supportingInfo"]) {
            this.supportingInfo.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["relevantHistory"]) {
            this.relevantHistory.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["signer"]) {
            this.signer.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["friendly"]) {
            this.friendly.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["legal"]) {
            this.legal.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["rule"]) {
            this.rule.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["legallyBindingAttachment"]) {
            results.push(...this.legallyBindingAttachment.doModelValidation());
        }
        if (this["legallyBindingReference"]) {
            results.push(...this.legallyBindingReference.doModelValidation());
        }
        return results;
    }
}
//# sourceMappingURL=Contract.js.map