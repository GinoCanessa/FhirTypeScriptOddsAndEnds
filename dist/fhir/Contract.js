// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
 */
export class ContractContentDefinition extends fhir.BackboneElement {
    /**
     * Default constructor for ContractContentDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["copyright"]) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"]) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source["publicationDate"]) {
            this.publicationDate = source.publicationDate;
        }
        if (source["_publicationDate"]) {
            this._publicationDate = new fhir.FhirElement(source._publicationDate);
        }
        this.publicationStatus = null;
        if (source["publicationStatus"]) {
            this.publicationStatus = source.publicationStatus;
        }
        if (this.publicationStatus === undefined) {
            this.publicationStatus = null;
        }
        if (source["_publicationStatus"]) {
            this._publicationStatus = new fhir.FhirElement(source._publicationStatus);
        }
        if (source["publisher"]) {
            this.publisher = new fhir.Reference(source.publisher);
        }
        if (source["subType"]) {
            this.subType = new fhir.CodeableConcept(source.subType);
        }
        this.type = null;
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (this.type === undefined) {
            this.type = null;
        }
    }
    /**
     * Check if the current ContractContentDefinition contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["publicationStatus"] === undefined) {
            missingElements.push("publicationStatus");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractContentDefinition from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractContentDefinition(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractContentDefinition is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
 */
export class ContractTermSecurityLabel extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermSecurityLabel - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["category"]) {
            this.category = source.category.map((x) => new fhir.Coding(x));
        }
        this.classification = null;
        if (source["classification"]) {
            this.classification = new fhir.Coding(source.classification);
        }
        if (this.classification === undefined) {
            this.classification = null;
        }
        if (source["control"]) {
            this.control = source.control.map((x) => new fhir.Coding(x));
        }
        if (source["number"]) {
            this.number = source.number.map((x) => (x));
        }
        if (source["_number"]) {
            this._number = source._number.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Check if the current ContractTermSecurityLabel contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["classification"] === undefined) {
            missingElements.push("classification");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermSecurityLabel from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermSecurityLabel(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermSecurityLabel is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Offer Recipient.
 */
export class ContractTermOfferParty extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermOfferParty - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.reference = null;
        if (source["reference"]) {
            this.reference = source.reference.map((x) => new fhir.Reference(x));
        }
        if (this.reference === undefined) {
            this.reference = null;
        }
        this.role = null;
        if (source["role"]) {
            this.role = new fhir.CodeableConcept(source.role);
        }
        if (this.role === undefined) {
            this.role = null;
        }
    }
    /**
     * Check if the current ContractTermOfferParty contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["reference"]) || (this["reference"].length === 0)) {
            missingElements.push("reference");
        }
        if (this["role"] === undefined) {
            missingElements.push("role");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermOfferParty from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermOfferParty(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermOfferParty is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Response to offer text.
 */
export class ContractTermOfferAnswer extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermOfferAnswer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["valueBoolean"]) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"]) {
            this._valueBoolean = new fhir.FhirElement(source._valueBoolean);
        }
        if (source["valueDecimal"]) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"]) {
            this._valueDecimal = new fhir.FhirElement(source._valueDecimal);
        }
        if (source["valueInteger"]) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"]) {
            this._valueInteger = new fhir.FhirElement(source._valueInteger);
        }
        if (source["valueDate"]) {
            this.valueDate = source.valueDate;
        }
        if (source["_valueDate"]) {
            this._valueDate = new fhir.FhirElement(source._valueDate);
        }
        if (source["valueDateTime"]) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source["_valueDateTime"]) {
            this._valueDateTime = new fhir.FhirElement(source._valueDateTime);
        }
        if (source["valueTime"]) {
            this.valueTime = source.valueTime;
        }
        if (source["_valueTime"]) {
            this._valueTime = new fhir.FhirElement(source._valueTime);
        }
        if (source["valueString"]) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"]) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source["valueUri"]) {
            this.valueUri = source.valueUri;
        }
        if (source["_valueUri"]) {
            this._valueUri = new fhir.FhirElement(source._valueUri);
        }
        if (source["valueAttachment"]) {
            this.valueAttachment = new fhir.Attachment(source.valueAttachment);
        }
        if (source["valueCoding"]) {
            this.valueCoding = new fhir.Coding(source.valueCoding);
        }
        if (source["valueQuantity"]) {
            this.valueQuantity = new fhir.Quantity(source.valueQuantity);
        }
        if (source["valueReference"]) {
            this.valueReference = new fhir.Reference(source.valueReference);
        }
    }
    /**
     * Check if the current ContractTermOfferAnswer contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermOfferAnswer from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermOfferAnswer(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermOfferAnswer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The matter of concern in the context of this provision of the agrement.
 */
export class ContractTermOffer extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermOffer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["answer"]) {
            this.answer = source.answer.map((x) => new fhir.ContractTermOfferAnswer(x));
        }
        if (source["decision"]) {
            this.decision = new fhir.CodeableConcept(source.decision);
        }
        if (source["decisionMode"]) {
            this.decisionMode = source.decisionMode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["linkId"]) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"]) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["party"]) {
            this.party = source.party.map((x) => new fhir.ContractTermOfferParty(x));
        }
        if (source["securityLabelNumber"]) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"]) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
        if (source["text"]) {
            this.text = source.text;
        }
        if (source["_text"]) {
            this._text = new fhir.FhirElement(source._text);
        }
        if (source["topic"]) {
            this.topic = new fhir.Reference(source.topic);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current ContractTermOffer contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermOffer from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermOffer(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermOffer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Circumstance of the asset.
 */
export class ContractTermAssetContext extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAssetContext - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["reference"]) {
            this.reference = new fhir.Reference(source.reference);
        }
        if (source["text"]) {
            this.text = source.text;
        }
        if (source["_text"]) {
            this._text = new fhir.FhirElement(source._text);
        }
    }
    /**
     * Check if the current ContractTermAssetContext contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermAssetContext from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermAssetContext(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAssetContext is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Contract Valued Item List.
 */
export class ContractTermAssetValuedItem extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAssetValuedItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["effectiveTime"]) {
            this.effectiveTime = source.effectiveTime;
        }
        if (source["_effectiveTime"]) {
            this._effectiveTime = new fhir.FhirElement(source._effectiveTime);
        }
        if (source["entityCodeableConcept"]) {
            this.entityCodeableConcept = new fhir.CodeableConcept(source.entityCodeableConcept);
        }
        if (source["entityReference"]) {
            this.entityReference = new fhir.Reference(source.entityReference);
        }
        if (source["factor"]) {
            this.factor = source.factor;
        }
        if (source["_factor"]) {
            this._factor = new fhir.FhirElement(source._factor);
        }
        if (source["identifier"]) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source["linkId"]) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"]) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["net"]) {
            this.net = new fhir.Money(source.net);
        }
        if (source["payment"]) {
            this.payment = source.payment;
        }
        if (source["_payment"]) {
            this._payment = new fhir.FhirElement(source._payment);
        }
        if (source["paymentDate"]) {
            this.paymentDate = source.paymentDate;
        }
        if (source["_paymentDate"]) {
            this._paymentDate = new fhir.FhirElement(source._paymentDate);
        }
        if (source["points"]) {
            this.points = source.points;
        }
        if (source["_points"]) {
            this._points = new fhir.FhirElement(source._points);
        }
        if (source["quantity"]) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source["recipient"]) {
            this.recipient = new fhir.Reference(source.recipient);
        }
        if (source["responsible"]) {
            this.responsible = new fhir.Reference(source.responsible);
        }
        if (source["securityLabelNumber"]) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"]) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
        if (source["unitPrice"]) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
    }
    /**
     * Check if the current ContractTermAssetValuedItem contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermAssetValuedItem from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermAssetValuedItem(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAssetValuedItem is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Contract Term Asset List.
 */
export class ContractTermAsset extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAsset - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["answer"]) {
            this.answer = source.answer.map((x) => new fhir.ContractTermOfferAnswer(x));
        }
        if (source["condition"]) {
            this.condition = source.condition;
        }
        if (source["_condition"]) {
            this._condition = new fhir.FhirElement(source._condition);
        }
        if (source["context"]) {
            this.context = source.context.map((x) => new fhir.ContractTermAssetContext(x));
        }
        if (source["linkId"]) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"]) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["period"]) {
            this.period = source.period.map((x) => new fhir.Period(x));
        }
        if (source["periodType"]) {
            this.periodType = source.periodType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["relationship"]) {
            this.relationship = new fhir.Coding(source.relationship);
        }
        if (source["scope"]) {
            this.scope = new fhir.CodeableConcept(source.scope);
        }
        if (source["securityLabelNumber"]) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"]) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
        if (source["subtype"]) {
            this.subtype = source.subtype.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["text"]) {
            this.text = source.text;
        }
        if (source["_text"]) {
            this._text = new fhir.FhirElement(source._text);
        }
        if (source["type"]) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["typeReference"]) {
            this.typeReference = source.typeReference.map((x) => new fhir.Reference(x));
        }
        if (source["usePeriod"]) {
            this.usePeriod = source.usePeriod.map((x) => new fhir.Period(x));
        }
        if (source["valuedItem"]) {
            this.valuedItem = source.valuedItem.map((x) => new fhir.ContractTermAssetValuedItem(x));
        }
    }
    /**
     * Check if the current ContractTermAsset contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermAsset from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermAsset(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAsset is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Entity of the action.
 */
export class ContractTermActionSubject extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermActionSubject - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.reference = null;
        if (source["reference"]) {
            this.reference = source.reference.map((x) => new fhir.Reference(x));
        }
        if (this.reference === undefined) {
            this.reference = null;
        }
        if (source["role"]) {
            this.role = new fhir.CodeableConcept(source.role);
        }
    }
    /**
     * Check if the current ContractTermActionSubject contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["reference"]) || (this["reference"].length === 0)) {
            missingElements.push("reference");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermActionSubject from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermActionSubject(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermActionSubject is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
 * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
 */
export class ContractTermAction extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTermAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["context"]) {
            this.context = new fhir.Reference(source.context);
        }
        if (source["contextLinkId"]) {
            this.contextLinkId = source.contextLinkId.map((x) => (x));
        }
        if (source["_contextLinkId"]) {
            this._contextLinkId = source._contextLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["doNotPerform"]) {
            this.doNotPerform = source.doNotPerform;
        }
        if (source["_doNotPerform"]) {
            this._doNotPerform = new fhir.FhirElement(source._doNotPerform);
        }
        this.intent = null;
        if (source["intent"]) {
            this.intent = new fhir.CodeableConcept(source.intent);
        }
        if (this.intent === undefined) {
            this.intent = null;
        }
        if (source["linkId"]) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"]) {
            this._linkId = source._linkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["note"]) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source["occurrenceDateTime"]) {
            this.occurrenceDateTime = source.occurrenceDateTime;
        }
        if (source["_occurrenceDateTime"]) {
            this._occurrenceDateTime = new fhir.FhirElement(source._occurrenceDateTime);
        }
        if (source["occurrencePeriod"]) {
            this.occurrencePeriod = new fhir.Period(source.occurrencePeriod);
        }
        if (source["occurrenceTiming"]) {
            this.occurrenceTiming = new fhir.Timing(source.occurrenceTiming);
        }
        if (source["performer"]) {
            this.performer = new fhir.Reference(source.performer);
        }
        if (source["performerLinkId"]) {
            this.performerLinkId = source.performerLinkId.map((x) => (x));
        }
        if (source["_performerLinkId"]) {
            this._performerLinkId = source._performerLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["performerRole"]) {
            this.performerRole = new fhir.CodeableConcept(source.performerRole);
        }
        if (source["performerType"]) {
            this.performerType = source.performerType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["reason"]) {
            this.reason = source.reason.map((x) => (x));
        }
        if (source["_reason"]) {
            this._reason = source._reason.map((x) => new fhir.FhirElement(x));
        }
        if (source["reasonCode"]) {
            this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["reasonLinkId"]) {
            this.reasonLinkId = source.reasonLinkId.map((x) => (x));
        }
        if (source["_reasonLinkId"]) {
            this._reasonLinkId = source._reasonLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["reasonReference"]) {
            this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x));
        }
        if (source["requester"]) {
            this.requester = source.requester.map((x) => new fhir.Reference(x));
        }
        if (source["requesterLinkId"]) {
            this.requesterLinkId = source.requesterLinkId.map((x) => (x));
        }
        if (source["_requesterLinkId"]) {
            this._requesterLinkId = source._requesterLinkId.map((x) => new fhir.FhirElement(x));
        }
        if (source["securityLabelNumber"]) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"]) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhir.FhirElement(x));
        }
        this.status = null;
        if (source["status"]) {
            this.status = new fhir.CodeableConcept(source.status);
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["subject"]) {
            this.subject = source.subject.map((x) => new fhir.ContractTermActionSubject(x));
        }
        this.type = null;
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (this.type === undefined) {
            this.type = null;
        }
    }
    /**
     * Check if the current ContractTermAction contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["intent"] === undefined) {
            missingElements.push("intent");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTermAction from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTermAction(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
 */
export class ContractTerm extends fhir.BackboneElement {
    /**
     * Default constructor for ContractTerm - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["action"]) {
            this.action = source.action.map((x) => new fhir.ContractTermAction(x));
        }
        if (source["applies"]) {
            this.applies = new fhir.Period(source.applies);
        }
        if (source["asset"]) {
            this.asset = source.asset.map((x) => new fhir.ContractTermAsset(x));
        }
        if (source["group"]) {
            this.group = source.group.map((x) => new fhir.ContractTerm(x));
        }
        if (source["identifier"]) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source["issued"]) {
            this.issued = source.issued;
        }
        if (source["_issued"]) {
            this._issued = new fhir.FhirElement(source._issued);
        }
        this.offer = null;
        if (source["offer"]) {
            this.offer = new fhir.ContractTermOffer(source.offer);
        }
        if (this.offer === undefined) {
            this.offer = null;
        }
        if (source["securityLabel"]) {
            this.securityLabel = source.securityLabel.map((x) => new fhir.ContractTermSecurityLabel(x));
        }
        if (source["subType"]) {
            this.subType = new fhir.CodeableConcept(source.subType);
        }
        if (source["text"]) {
            this.text = source.text;
        }
        if (source["_text"]) {
            this._text = new fhir.FhirElement(source._text);
        }
        if (source["topicCodeableConcept"]) {
            this.topicCodeableConcept = new fhir.CodeableConcept(source.topicCodeableConcept);
        }
        if (source["topicReference"]) {
            this.topicReference = new fhir.Reference(source.topicReference);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current ContractTerm contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["offer"] === undefined) {
            missingElements.push("offer");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractTerm from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractTerm(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTerm is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
 * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
 */
export class ContractSigner extends fhir.BackboneElement {
    /**
     * Default constructor for ContractSigner - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.party = null;
        if (source["party"]) {
            this.party = new fhir.Reference(source.party);
        }
        if (this.party === undefined) {
            this.party = null;
        }
        this.signature = null;
        if (source["signature"]) {
            this.signature = source.signature.map((x) => new fhir.Signature(x));
        }
        if (this.signature === undefined) {
            this.signature = null;
        }
        this.type = null;
        if (source["type"]) {
            this.type = new fhir.Coding(source.type);
        }
        if (this.type === undefined) {
            this.type = null;
        }
    }
    /**
     * Check if the current ContractSigner contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["party"] === undefined) {
            missingElements.push("party");
        }
        if ((!this["signature"]) || (this["signature"].length === 0)) {
            missingElements.push("signature");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractSigner from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractSigner(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractSigner is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
 */
export class ContractFriendly extends fhir.BackboneElement {
    /**
     * Default constructor for ContractFriendly - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["contentAttachment"]) {
            this.contentAttachment = new fhir.Attachment(source.contentAttachment);
        }
        if (source["contentReference"]) {
            this.contentReference = new fhir.Reference(source.contentReference);
        }
    }
    /**
     * Check if the current ContractFriendly contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractFriendly from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractFriendly(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractFriendly is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * List of Legal expressions or representations of this Contract.
 */
export class ContractLegal extends fhir.BackboneElement {
    /**
     * Default constructor for ContractLegal - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["contentAttachment"]) {
            this.contentAttachment = new fhir.Attachment(source.contentAttachment);
        }
        if (source["contentReference"]) {
            this.contentReference = new fhir.Reference(source.contentReference);
        }
    }
    /**
     * Check if the current ContractLegal contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractLegal from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractLegal(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractLegal is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * List of Computable Policy Rule Language Representations of this Contract.
 */
export class ContractRule extends fhir.BackboneElement {
    /**
     * Default constructor for ContractRule - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["contentAttachment"]) {
            this.contentAttachment = new fhir.Attachment(source.contentAttachment);
        }
        if (source["contentReference"]) {
            this.contentReference = new fhir.Reference(source.contentReference);
        }
    }
    /**
     * Check if the current ContractRule contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ContractRule from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new ContractRule(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractRule is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
 */
export class Contract extends fhir.DomainResource {
    /**
     * Default constructor for Contract - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Contract';
        if (source["alias"]) {
            this.alias = source.alias.map((x) => (x));
        }
        if (source["_alias"]) {
            this._alias = source._alias.map((x) => new fhir.FhirElement(x));
        }
        if (source["applies"]) {
            this.applies = new fhir.Period(source.applies);
        }
        if (source["author"]) {
            this.author = new fhir.Reference(source.author);
        }
        if (source["authority"]) {
            this.authority = source.authority.map((x) => new fhir.Reference(x));
        }
        if (source["contentDefinition"]) {
            this.contentDefinition = new fhir.ContractContentDefinition(source.contentDefinition);
        }
        if (source["contentDerivative"]) {
            this.contentDerivative = new fhir.CodeableConcept(source.contentDerivative);
        }
        if (source["domain"]) {
            this.domain = source.domain.map((x) => new fhir.Reference(x));
        }
        if (source["expirationType"]) {
            this.expirationType = new fhir.CodeableConcept(source.expirationType);
        }
        if (source["friendly"]) {
            this.friendly = source.friendly.map((x) => new fhir.ContractFriendly(x));
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["instantiatesCanonical"]) {
            this.instantiatesCanonical = new fhir.Reference(source.instantiatesCanonical);
        }
        if (source["instantiatesUri"]) {
            this.instantiatesUri = source.instantiatesUri;
        }
        if (source["_instantiatesUri"]) {
            this._instantiatesUri = new fhir.FhirElement(source._instantiatesUri);
        }
        if (source["issued"]) {
            this.issued = source.issued;
        }
        if (source["_issued"]) {
            this._issued = new fhir.FhirElement(source._issued);
        }
        if (source["legal"]) {
            this.legal = source.legal.map((x) => new fhir.ContractLegal(x));
        }
        if (source["legallyBindingAttachment"]) {
            this.legallyBindingAttachment = new fhir.Attachment(source.legallyBindingAttachment);
        }
        if (source["legallyBindingReference"]) {
            this.legallyBindingReference = new fhir.Reference(source.legallyBindingReference);
        }
        if (source["legalState"]) {
            this.legalState = new fhir.CodeableConcept(source.legalState);
        }
        if (source["name"]) {
            this.name = source.name;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["relevantHistory"]) {
            this.relevantHistory = source.relevantHistory.map((x) => new fhir.Reference(x));
        }
        if (source["rule"]) {
            this.rule = source.rule.map((x) => new fhir.ContractRule(x));
        }
        if (source["scope"]) {
            this.scope = new fhir.CodeableConcept(source.scope);
        }
        if (source["signer"]) {
            this.signer = source.signer.map((x) => new fhir.ContractSigner(x));
        }
        if (source["site"]) {
            this.site = source.site.map((x) => new fhir.Reference(x));
        }
        if (source["status"]) {
            this.status = source.status;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["subject"]) {
            this.subject = source.subject.map((x) => new fhir.Reference(x));
        }
        if (source["subtitle"]) {
            this.subtitle = source.subtitle;
        }
        if (source["_subtitle"]) {
            this._subtitle = new fhir.FhirElement(source._subtitle);
        }
        if (source["subType"]) {
            this.subType = source.subType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["supportingInfo"]) {
            this.supportingInfo = source.supportingInfo.map((x) => new fhir.Reference(x));
        }
        if (source["term"]) {
            this.term = source.term.map((x) => new fhir.ContractTerm(x));
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source["topicCodeableConcept"]) {
            this.topicCodeableConcept = new fhir.CodeableConcept(source.topicCodeableConcept);
        }
        if (source["topicReference"]) {
            this.topicReference = new fhir.Reference(source.topicReference);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current Contract contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Contract from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new Contract(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `Contract is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the Contract.contentDefinition.publicationStatus field
 */
export var ContractContentDefinitionPublicationStatusEnum;
(function (ContractContentDefinitionPublicationStatusEnum) {
    ContractContentDefinitionPublicationStatusEnum["AMENDED"] = "amended";
    ContractContentDefinitionPublicationStatusEnum["APPENDED"] = "appended";
    ContractContentDefinitionPublicationStatusEnum["CANCELLED"] = "cancelled";
    ContractContentDefinitionPublicationStatusEnum["DISPUTED"] = "disputed";
    ContractContentDefinitionPublicationStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    ContractContentDefinitionPublicationStatusEnum["EXECUTABLE"] = "executable";
    ContractContentDefinitionPublicationStatusEnum["EXECUTED"] = "executed";
    ContractContentDefinitionPublicationStatusEnum["NEGOTIABLE"] = "negotiable";
    ContractContentDefinitionPublicationStatusEnum["OFFERED"] = "offered";
    ContractContentDefinitionPublicationStatusEnum["POLICY"] = "policy";
    ContractContentDefinitionPublicationStatusEnum["REJECTED"] = "rejected";
    ContractContentDefinitionPublicationStatusEnum["RENEWED"] = "renewed";
    ContractContentDefinitionPublicationStatusEnum["REVOKED"] = "revoked";
    ContractContentDefinitionPublicationStatusEnum["RESOLVED"] = "resolved";
    ContractContentDefinitionPublicationStatusEnum["TERMINATED"] = "terminated";
})(ContractContentDefinitionPublicationStatusEnum || (ContractContentDefinitionPublicationStatusEnum = {}));
/**
 * Code Values for the Contract.status field
 */
export var ContractStatusEnum;
(function (ContractStatusEnum) {
    ContractStatusEnum["AMENDED"] = "amended";
    ContractStatusEnum["APPENDED"] = "appended";
    ContractStatusEnum["CANCELLED"] = "cancelled";
    ContractStatusEnum["DISPUTED"] = "disputed";
    ContractStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    ContractStatusEnum["EXECUTABLE"] = "executable";
    ContractStatusEnum["EXECUTED"] = "executed";
    ContractStatusEnum["NEGOTIABLE"] = "negotiable";
    ContractStatusEnum["OFFERED"] = "offered";
    ContractStatusEnum["POLICY"] = "policy";
    ContractStatusEnum["REJECTED"] = "rejected";
    ContractStatusEnum["RENEWED"] = "renewed";
    ContractStatusEnum["REVOKED"] = "revoked";
    ContractStatusEnum["RESOLVED"] = "resolved";
    ContractStatusEnum["TERMINATED"] = "terminated";
})(ContractStatusEnum || (ContractStatusEnum = {}));
//# sourceMappingURL=Contract.js.map