// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Information about the primary source(s) involved in validation.
 */
export class VerificationResultPrimarySource extends fhir.BackboneElement {
    /**
     * Default constructor for VerificationResultPrimarySource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["canPushUpdates"]) {
            this.canPushUpdates = new fhir.CodeableConcept(source.canPushUpdates);
        }
        if (source["communicationMethod"]) {
            this.communicationMethod = source.communicationMethod.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["pushTypeAvailable"]) {
            this.pushTypeAvailable = source.pushTypeAvailable.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["type"]) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["validationDate"]) {
            this.validationDate = source.validationDate;
        }
        if (source["_validationDate"]) {
            this._validationDate = new fhir.FhirElement(source._validationDate);
        }
        if (source["validationStatus"]) {
            this.validationStatus = new fhir.CodeableConcept(source.validationStatus);
        }
        if (source["who"]) {
            this.who = new fhir.Reference(source.who);
        }
    }
    /**
     * Check if the current VerificationResultPrimarySource contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a VerificationResultPrimarySource from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new VerificationResultPrimarySource(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `VerificationResultPrimarySource is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about the entity attesting to information.
 */
export class VerificationResultAttestation extends fhir.BackboneElement {
    /**
     * Default constructor for VerificationResultAttestation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["communicationMethod"]) {
            this.communicationMethod = new fhir.CodeableConcept(source.communicationMethod);
        }
        if (source["date"]) {
            this.date = source.date;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["onBehalfOf"]) {
            this.onBehalfOf = new fhir.Reference(source.onBehalfOf);
        }
        if (source["proxyIdentityCertificate"]) {
            this.proxyIdentityCertificate = source.proxyIdentityCertificate;
        }
        if (source["_proxyIdentityCertificate"]) {
            this._proxyIdentityCertificate = new fhir.FhirElement(source._proxyIdentityCertificate);
        }
        if (source["proxySignature"]) {
            this.proxySignature = new fhir.Signature(source.proxySignature);
        }
        if (source["sourceIdentityCertificate"]) {
            this.sourceIdentityCertificate = source.sourceIdentityCertificate;
        }
        if (source["_sourceIdentityCertificate"]) {
            this._sourceIdentityCertificate = new fhir.FhirElement(source._sourceIdentityCertificate);
        }
        if (source["sourceSignature"]) {
            this.sourceSignature = new fhir.Signature(source.sourceSignature);
        }
        if (source["who"]) {
            this.who = new fhir.Reference(source.who);
        }
    }
    /**
     * Check if the current VerificationResultAttestation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a VerificationResultAttestation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new VerificationResultAttestation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `VerificationResultAttestation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about the entity validating information.
 */
export class VerificationResultValidator extends fhir.BackboneElement {
    /**
     * Default constructor for VerificationResultValidator - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["attestationSignature"]) {
            this.attestationSignature = new fhir.Signature(source.attestationSignature);
        }
        if (source["identityCertificate"]) {
            this.identityCertificate = source.identityCertificate;
        }
        if (source["_identityCertificate"]) {
            this._identityCertificate = new fhir.FhirElement(source._identityCertificate);
        }
        this.organization = null;
        if (source["organization"]) {
            this.organization = new fhir.Reference(source.organization);
        }
        if (this.organization === undefined) {
            this.organization = null;
        }
    }
    /**
     * Check if the current VerificationResultValidator contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["organization"] === undefined) {
            missingElements.push("organization");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a VerificationResultValidator from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new VerificationResultValidator(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `VerificationResultValidator is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Describes validation requirements, source(s), status and dates for one or more elements.
 */
export class VerificationResult extends fhir.DomainResource {
    /**
     * Default constructor for VerificationResult - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'VerificationResult';
        if (source["attestation"]) {
            this.attestation = new fhir.VerificationResultAttestation(source.attestation);
        }
        if (source["failureAction"]) {
            this.failureAction = new fhir.CodeableConcept(source.failureAction);
        }
        if (source["frequency"]) {
            this.frequency = new fhir.Timing(source.frequency);
        }
        if (source["lastPerformed"]) {
            this.lastPerformed = source.lastPerformed;
        }
        if (source["_lastPerformed"]) {
            this._lastPerformed = new fhir.FhirElement(source._lastPerformed);
        }
        if (source["need"]) {
            this.need = new fhir.CodeableConcept(source.need);
        }
        if (source["nextScheduled"]) {
            this.nextScheduled = source.nextScheduled;
        }
        if (source["_nextScheduled"]) {
            this._nextScheduled = new fhir.FhirElement(source._nextScheduled);
        }
        if (source["primarySource"]) {
            this.primarySource = source.primarySource.map((x) => new fhir.VerificationResultPrimarySource(x));
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["statusDate"]) {
            this.statusDate = source.statusDate;
        }
        if (source["_statusDate"]) {
            this._statusDate = new fhir.FhirElement(source._statusDate);
        }
        if (source["target"]) {
            this.target = source.target.map((x) => new fhir.Reference(x));
        }
        if (source["targetLocation"]) {
            this.targetLocation = source.targetLocation.map((x) => (x));
        }
        if (source["_targetLocation"]) {
            this._targetLocation = source._targetLocation.map((x) => new fhir.FhirElement(x));
        }
        if (source["validationProcess"]) {
            this.validationProcess = source.validationProcess.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["validationType"]) {
            this.validationType = new fhir.CodeableConcept(source.validationType);
        }
        if (source["validator"]) {
            this.validator = source.validator.map((x) => new fhir.VerificationResultValidator(x));
        }
    }
    /**
     * Check if the current VerificationResult contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a VerificationResult from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new VerificationResult(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `VerificationResult is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the VerificationResult.status field
 */
export var VerificationResultStatusEnum;
(function (VerificationResultStatusEnum) {
    VerificationResultStatusEnum["ATTESTED"] = "attested";
    VerificationResultStatusEnum["VALIDATED"] = "validated";
    VerificationResultStatusEnum["IN_PROCESS"] = "in-process";
    VerificationResultStatusEnum["REQ_REVALID"] = "req-revalid";
    VerificationResultStatusEnum["VAL_FAIL"] = "val-fail";
    VerificationResultStatusEnum["REVAL_FAIL"] = "reval-fail";
})(VerificationResultStatusEnum || (VerificationResultStatusEnum = {}));
//# sourceMappingURL=VerificationResult.js.map