// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: AuditEvent
import * as fhir from '../fhir.js';
import { NetworkTypeValueSet } from '../fhirValueSets/NetworkTypeValueSet.js';
import { ParticipationRoleTypeValueSet } from '../fhirValueSets/ParticipationRoleTypeValueSet.js';
import { SecurityRoleTypeValueSet } from '../fhirValueSets/SecurityRoleTypeValueSet.js';
import { Dicm405MediatypeValueSet } from '../fhirValueSets/Dicm405MediatypeValueSet.js';
import { V3PurposeOfUseValueSet } from '../fhirValueSets/V3PurposeOfUseValueSet.js';
import { AuditSourceTypeValueSet } from '../fhirValueSets/AuditSourceTypeValueSet.js';
import { AuditEntityTypeValueSet } from '../fhirValueSets/AuditEntityTypeValueSet.js';
import { ObjectRoleValueSet } from '../fhirValueSets/ObjectRoleValueSet.js';
import { SecurityLabelsValueSet } from '../fhirValueSets/SecurityLabelsValueSet.js';
import { AuditEventTypeValueSet } from '../fhirValueSets/AuditEventTypeValueSet.js';
import { AuditEventSubTypeValueSet } from '../fhirValueSets/AuditEventSubTypeValueSet.js';
import { AuditEventActionValueSet } from '../fhirValueSets/AuditEventActionValueSet.js';
import { AuditEventOutcomeValueSet } from '../fhirValueSets/AuditEventOutcomeValueSet.js';
/**
 * Logical network location for application activity, if the activity has a network location.
 */
export class AuditEventAgentNetwork extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventAgentNetwork - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['address']) {
            this.address = source.address;
        }
        if (source['_address']) {
            this._address = new fhir.FhirElement(source._address);
        }
        if (source['type']) {
            this.type = source.type;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    typeRequiredValueSet() {
        return NetworkTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_address"]) {
            results.push(...this._address.doModelValidation());
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        return results;
    }
}
/**
 * Several agents may be associated (i.e. have some responsibility for an activity) with an event or activity.
 * For example, an activity may be initiated by one user for other users or involve more than one user. However, only one user may be the initiator/requestor for the activity.
 */
export class AuditEventAgent extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventAgent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['role']) {
            this.role = source.role.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['who']) {
            this.who = new fhir.Reference(source.who);
        }
        if (source['altId']) {
            this.altId = source.altId;
        }
        if (source['_altId']) {
            this._altId = new fhir.FhirElement(source._altId);
        }
        if (source['name']) {
            this.name = source.name;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['requestor']) {
            this.requestor = source.requestor;
        }
        else {
            this.requestor = null;
        }
        if (source['_requestor']) {
            this._requestor = new fhir.FhirElement(source._requestor);
        }
        if (source['location']) {
            this.location = new fhir.Reference(source.location);
        }
        if (source['policy']) {
            this.policy = source.policy.map((x) => (x));
        }
        if (source['_policy']) {
            this._policy = source._policy.map((x) => new fhir.FhirElement(x));
        }
        if (source['media']) {
            this.media = new fhir.Coding(source.media);
        }
        if (source['network']) {
            this.network = new fhir.AuditEventAgentNetwork(source.network);
        }
        if (source['purposeOfUse']) {
            this.purposeOfUse = source.purposeOfUse.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    typeExtensibleValueSet() {
        return ParticipationRoleTypeValueSet;
    }
    /**
     * Example-bound Value Set for role
     */
    roleExampleValueSet() {
        return SecurityRoleTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for media
     */
    mediaExtensibleValueSet() {
        return Dicm405MediatypeValueSet;
    }
    /**
     * Extensible-bound Value Set for purposeOfUse
     */
    purposeOfUseExtensibleValueSet() {
        return V3PurposeOfUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["role"]) {
            this.role.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["who"]) {
            results.push(...this.who.doModelValidation());
        }
        if (this["_altId"]) {
            results.push(...this._altId.doModelValidation());
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (!this["requestor"]) {
            results.push(["requestor", 'Missing required element: AuditEvent.agent.requestor']);
        }
        if (this["_requestor"]) {
            results.push(...this._requestor.doModelValidation());
        }
        if (this["location"]) {
            results.push(...this.location.doModelValidation());
        }
        if (this["_policy"]) {
            this._policy.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["media"]) {
            results.push(...this.media.doModelValidation());
        }
        if (this["network"]) {
            results.push(...this.network.doModelValidation());
        }
        if (this["purposeOfUse"]) {
            this.purposeOfUse.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Since multi-tier, distributed, or composite applications make source identification ambiguous, this collection of fields may repeat for each application or process actively involved in the event. For example, multiple value-sets can identify participating web servers, application processes, and database server threads in an n-tier distributed application. Passive event participants (e.g. low-level network transports) need not be identified.
 */
export class AuditEventSource extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventSource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['site']) {
            this.site = source.site;
        }
        if (source['_site']) {
            this._site = new fhir.FhirElement(source._site);
        }
        if (source['observer']) {
            this.observer = new fhir.Reference(source.observer);
        }
        else {
            this.observer = null;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.Coding(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    typeExtensibleValueSet() {
        return AuditSourceTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_site"]) {
            results.push(...this._site.doModelValidation());
        }
        if (!this["observer"]) {
            results.push(["observer", 'Missing required element: AuditEvent.source.observer']);
        }
        if (this["observer"]) {
            results.push(...this.observer.doModelValidation());
        }
        if (this["type"]) {
            this.type.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Tagged value pairs for conveying additional information about the entity.
 */
export class AuditEventEntityDetail extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventEntityDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['_type']) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source['valueString']) {
            this.valueString = source.valueString;
        }
        if (source['_valueString']) {
            this._valueString = new fhir.FhirElement(source._valueString);
        }
        if (source['valueBase64Binary']) {
            this.valueBase64Binary = source.valueBase64Binary;
        }
        if (source['_valueBase64Binary']) {
            this._valueBase64Binary = new fhir.FhirElement(source._valueBase64Binary);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["type"]) {
            results.push(["type", 'Missing required element: AuditEvent.entity.detail.type']);
        }
        if (this["_type"]) {
            results.push(...this._type.doModelValidation());
        }
        if (this["_valueString"]) {
            results.push(...this._valueString.doModelValidation());
        }
        if (this["_valueBase64Binary"]) {
            results.push(...this._valueBase64Binary.doModelValidation());
        }
        return results;
    }
}
/**
 * Required unless the values for event identification, agent identification, and audit source identification are sufficient to document the entire auditable event. Because events may have more than one entity, this group can be a repeating set of values.
 */
export class AuditEventEntity extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventEntity - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['what']) {
            this.what = new fhir.Reference(source.what);
        }
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        if (source['role']) {
            this.role = new fhir.Coding(source.role);
        }
        if (source['lifecycle']) {
            this.lifecycle = new fhir.Coding(source.lifecycle);
        }
        if (source['securityLabel']) {
            this.securityLabel = source.securityLabel.map((x) => new fhir.Coding(x));
        }
        if (source['name']) {
            this.name = source.name;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['query']) {
            this.query = source.query;
        }
        if (source['_query']) {
            this._query = new fhir.FhirElement(source._query);
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.AuditEventEntityDetail(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    typeExtensibleValueSet() {
        return AuditEntityTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for role
     */
    roleExtensibleValueSet() {
        return ObjectRoleValueSet;
    }
    /**
     * Extensible-bound Value Set for securityLabel
     */
    securityLabelExtensibleValueSet() {
        return SecurityLabelsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["what"]) {
            results.push(...this.what.doModelValidation());
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["role"]) {
            results.push(...this.role.doModelValidation());
        }
        if (this["lifecycle"]) {
            results.push(...this.lifecycle.doModelValidation());
        }
        if (this["securityLabel"]) {
            this.securityLabel.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["_query"]) {
            results.push(...this._query.doModelValidation());
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
 */
export class AuditEvent extends fhir.DomainResource {
    /**
     * Default constructor for AuditEvent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'AuditEvent';
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        else {
            this.type = null;
        }
        if (source['subtype']) {
            this.subtype = source.subtype.map((x) => new fhir.Coding(x));
        }
        if (source['action']) {
            this.action = source.action;
        }
        if (source['_action']) {
            this._action = new fhir.FhirElement(source._action);
        }
        if (source['period']) {
            this.period = new fhir.Period(source.period);
        }
        if (source['recorded']) {
            this.recorded = source.recorded;
        }
        else {
            this.recorded = null;
        }
        if (source['_recorded']) {
            this._recorded = new fhir.FhirElement(source._recorded);
        }
        if (source['outcome']) {
            this.outcome = source.outcome;
        }
        if (source['_outcome']) {
            this._outcome = new fhir.FhirElement(source._outcome);
        }
        if (source['outcomeDesc']) {
            this.outcomeDesc = source.outcomeDesc;
        }
        if (source['_outcomeDesc']) {
            this._outcomeDesc = new fhir.FhirElement(source._outcomeDesc);
        }
        if (source['purposeOfEvent']) {
            this.purposeOfEvent = source.purposeOfEvent.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['agent']) {
            this.agent = source.agent.map((x) => new fhir.AuditEventAgent(x));
        }
        else {
            this.agent = null;
        }
        if (source['source']) {
            this.source = new fhir.AuditEventSource(source.source);
        }
        else {
            this.source = null;
        }
        if (source['entity']) {
            this.entity = source.entity.map((x) => new fhir.AuditEventEntity(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    typeExtensibleValueSet() {
        return AuditEventTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for subtype
     */
    subtypeExtensibleValueSet() {
        return AuditEventSubTypeValueSet;
    }
    /**
     * Required-bound Value Set for action
     */
    actionRequiredValueSet() {
        return AuditEventActionValueSet;
    }
    /**
     * Required-bound Value Set for outcome
     */
    outcomeRequiredValueSet() {
        return AuditEventOutcomeValueSet;
    }
    /**
     * Extensible-bound Value Set for purposeOfEvent
     */
    purposeOfEventExtensibleValueSet() {
        return V3PurposeOfUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: AuditEvent.resourceType']);
        }
        if (!this["type"]) {
            results.push(["type", 'Missing required element: AuditEvent.type']);
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["subtype"]) {
            this.subtype.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_action"]) {
            results.push(...this._action.doModelValidation());
        }
        if (this["period"]) {
            results.push(...this.period.doModelValidation());
        }
        if (!this["recorded"]) {
            results.push(["recorded", 'Missing required element: AuditEvent.recorded']);
        }
        if (this["_recorded"]) {
            results.push(...this._recorded.doModelValidation());
        }
        if (this["_outcome"]) {
            results.push(...this._outcome.doModelValidation());
        }
        if (this["_outcomeDesc"]) {
            results.push(...this._outcomeDesc.doModelValidation());
        }
        if (this["purposeOfEvent"]) {
            this.purposeOfEvent.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if ((!this["agent"]) || (this["agent"].length === 0)) {
            results.push(["agent", 'Missing required element: AuditEvent.agent']);
        }
        if (this["agent"]) {
            this.agent.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["source"]) {
            results.push(["source", 'Missing required element: AuditEvent.source']);
        }
        if (this["source"]) {
            results.push(...this.source.doModelValidation());
        }
        if (this["entity"]) {
            this.entity.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=AuditEvent.js.map