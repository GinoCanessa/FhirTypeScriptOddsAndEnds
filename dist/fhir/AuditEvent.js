// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: AuditEvent
import * as fhir from '../fhir.js';
import { NetworkTypeValueSet, } from '../fhirValueSets/NetworkTypeValueSet.js';
import { ParticipationRoleTypeValueSet, } from '../fhirValueSets/ParticipationRoleTypeValueSet.js';
import { SecurityRoleTypeValueSet, } from '../fhirValueSets/SecurityRoleTypeValueSet.js';
import { Dicm405MediatypeValueSet, } from '../fhirValueSets/Dicm405MediatypeValueSet.js';
import { V3PurposeOfUseValueSet, } from '../fhirValueSets/V3PurposeOfUseValueSet.js';
import { AuditSourceTypeValueSet, } from '../fhirValueSets/AuditSourceTypeValueSet.js';
import { AuditEntityTypeValueSet, } from '../fhirValueSets/AuditEntityTypeValueSet.js';
import { ObjectRoleValueSet, } from '../fhirValueSets/ObjectRoleValueSet.js';
import { SecurityLabelsValueSet, } from '../fhirValueSets/SecurityLabelsValueSet.js';
import { AuditEventTypeValueSet, } from '../fhirValueSets/AuditEventTypeValueSet.js';
import { AuditEventSubTypeValueSet, } from '../fhirValueSets/AuditEventSubTypeValueSet.js';
import { AuditEventActionValueSet, } from '../fhirValueSets/AuditEventActionValueSet.js';
import { AuditEventOutcomeValueSet, } from '../fhirValueSets/AuditEventOutcomeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Logical network location for application activity, if the activity has a network location.
 */
export class AuditEventAgentNetwork extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventAgentNetwork - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'AuditEventAgentNetwork';
        if (source['address']) {
            this.address = new fhir.FhirString({ value: source.address });
        }
        if (source['type']) {
            this.type = new fhir.FhirCode({ value: source.type });
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return NetworkTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["address"]) {
            outcome.issue.push(...this.address.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Several agents may be associated (i.e. have some responsibility for an activity) with an event or activity.
 * For example, an activity may be initiated by one user for other users or involve more than one user. However, only one user may be the initiator/requestor for the activity.
 */
export class AuditEventAgent extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventAgent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'AuditEventAgent';
        /**
         * Should be roles relevant to the event. Should  not be an exhaustive list of roles.
         */
        this.role = [];
        /**
         * For example: Where an OAuth token authorizes, the unique identifier from the OAuth token is placed into the policy element Where a policy engine (e.g. XACML) holds policy logic, the unique policy identifier is placed into the policy element.
         */
        this.policy = [];
        /**
         * Use AuditEvent.agent.purposeOfUse when you know that is specific to the agent, otherwise use AuditEvent.purposeOfEvent. For example, during a machine-to-machine transfer it might not be obvious to the audit system who caused the event, but it does know why.
         */
        this.purposeOfUse = [];
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['role']) {
            this.role = source.role.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['who']) {
            this.who = new fhir.Reference(source.who);
        }
        if (source['altId']) {
            this.altId = new fhir.FhirString({ value: source.altId });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['requestor']) {
            this.requestor = new fhir.FhirBoolean({ value: source.requestor });
        }
        else {
            this.requestor = null;
        }
        if (source['location']) {
            this.location = new fhir.Reference(source.location);
        }
        if (source['policy']) {
            this.policy = source.policy.map((x) => new fhir.FhirUri({ value: x }));
        }
        if (source['media']) {
            this.media = new fhir.Coding(source.media);
        }
        if (source['network']) {
            this.network = new fhir.AuditEventAgentNetwork(source.network);
        }
        if (source['purposeOfUse']) {
            this.purposeOfUse = source.purposeOfUse.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return ParticipationRoleTypeValueSet;
    }
    /**
     * Example-bound Value Set for role
     */
    static roleExampleValueSet() {
        return SecurityRoleTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for media
     */
    static mediaExtensibleValueSet() {
        return Dicm405MediatypeValueSet;
    }
    /**
     * Extensible-bound Value Set for purposeOfUse
     */
    static purposeOfUseExtensibleValueSet() {
        return V3PurposeOfUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["role"]) {
            this.role.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["who"]) {
            outcome.issue.push(...this.who.doModelValidation().issue);
        }
        if (this["altId"]) {
            outcome.issue.push(...this.altId.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['requestor']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property requestor:fhir.FhirBoolean fhir: AuditEvent.agent.requestor:boolean", }));
        }
        if (this["requestor"]) {
            outcome.issue.push(...this.requestor.doModelValidation().issue);
        }
        if (this["location"]) {
            outcome.issue.push(...this.location.doModelValidation().issue);
        }
        if (this["policy"]) {
            this.policy.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["media"]) {
            outcome.issue.push(...this.media.doModelValidation().issue);
        }
        if (this["network"]) {
            outcome.issue.push(...this.network.doModelValidation().issue);
        }
        if (this["purposeOfUse"]) {
            this.purposeOfUse.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Since multi-tier, distributed, or composite applications make source identification ambiguous, this collection of fields may repeat for each application or process actively involved in the event. For example, multiple value-sets can identify participating web servers, application processes, and database server threads in an n-tier distributed application. Passive event participants (e.g. low-level network transports) need not be identified.
 */
export class AuditEventSource extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventSource - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'AuditEventSource';
        /**
         * Code specifying the type of source where event originated.
         */
        this.type = [];
        if (source['site']) {
            this.site = new fhir.FhirString({ value: source.site });
        }
        if (source['observer']) {
            this.observer = new fhir.Reference(source.observer);
        }
        else {
            this.observer = null;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.Coding(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return AuditSourceTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["site"]) {
            outcome.issue.push(...this.site.doModelValidation().issue);
        }
        if (!this['observer']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property observer:fhir.Reference fhir: AuditEvent.source.observer:Reference", }));
        }
        if (this["observer"]) {
            outcome.issue.push(...this.observer.doModelValidation().issue);
        }
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Tagged value pairs for conveying additional information about the entity.
 */
export class AuditEventEntityDetail extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventEntityDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'AuditEventEntityDetail';
        this.__valueIsChoice = true;
        if (source['type']) {
            this.type = new fhir.FhirString({ value: source.type });
        }
        else {
            this.type = null;
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueBase64Binary']) {
            this.value = new fhir.FhirBase64Binary({ value: source.valueBase64Binary });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.FhirString fhir: AuditEvent.entity.detail.type:string", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value: fhir: AuditEvent.entity.detail.value[x]:", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Required unless the values for event identification, agent identification, and audit source identification are sufficient to document the entire auditable event. Because events may have more than one entity, this group can be a repeating set of values.
 */
export class AuditEventEntity extends fhir.BackboneElement {
    /**
     * Default constructor for AuditEventEntity - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'AuditEventEntity';
        /**
         * Copied from entity meta security tags.
         */
        this.securityLabel = [];
        /**
         * Tagged value pairs for conveying additional information about the entity.
         */
        this.detail = [];
        if (source['what']) {
            this.what = new fhir.Reference(source.what);
        }
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        if (source['role']) {
            this.role = new fhir.Coding(source.role);
        }
        if (source['lifecycle']) {
            this.lifecycle = new fhir.Coding(source.lifecycle);
        }
        if (source['securityLabel']) {
            this.securityLabel = source.securityLabel.map((x) => new fhir.Coding(x));
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['query']) {
            this.query = new fhir.FhirBase64Binary({ value: source.query });
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.AuditEventEntityDetail(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return AuditEntityTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for role
     */
    static roleExtensibleValueSet() {
        return ObjectRoleValueSet;
    }
    /**
     * Extensible-bound Value Set for securityLabel
     */
    static securityLabelExtensibleValueSet() {
        return SecurityLabelsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["what"]) {
            outcome.issue.push(...this.what.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["role"]) {
            outcome.issue.push(...this.role.doModelValidation().issue);
        }
        if (this["lifecycle"]) {
            outcome.issue.push(...this.lifecycle.doModelValidation().issue);
        }
        if (this["securityLabel"]) {
            this.securityLabel.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["query"]) {
            outcome.issue.push(...this.query.doModelValidation().issue);
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
 */
export class AuditEvent extends fhir.DomainResource {
    /**
     * Default constructor for AuditEvent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'AuditEvent';
        /**
         * Identifier for the category of event.
         */
        this.subtype = [];
        /**
         * Use AuditEvent.agent.purposeOfUse when you know that it is specific to the agent, otherwise use AuditEvent.purposeOfEvent. For example, during a machine-to-machine transfer it might not be obvious to the audit system who caused the event, but it does know why.
         */
        this.purposeOfEvent = [];
        /**
         * Several agents may be associated (i.e. have some responsibility for an activity) with an event or activity.
         * For example, an activity may be initiated by one user for other users or involve more than one user. However, only one user may be the initiator/requestor for the activity.
         */
        this.agent = [];
        /**
         * Required unless the values for event identification, agent identification, and audit source identification are sufficient to document the entire auditable event. Because events may have more than one entity, this group can be a repeating set of values.
         */
        this.entity = [];
        this.resourceType = 'AuditEvent';
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        else {
            this.type = null;
        }
        if (source['subtype']) {
            this.subtype = source.subtype.map((x) => new fhir.Coding(x));
        }
        if (source['action']) {
            this.action = new fhir.FhirCode({ value: source.action });
        }
        if (source['period']) {
            this.period = new fhir.Period(source.period);
        }
        if (source['recorded']) {
            this.recorded = new fhir.FhirInstant({ value: source.recorded });
        }
        else {
            this.recorded = null;
        }
        if (source['outcome']) {
            this.outcome = new fhir.FhirCode({ value: source.outcome });
        }
        if (source['outcomeDesc']) {
            this.outcomeDesc = new fhir.FhirString({ value: source.outcomeDesc });
        }
        if (source['purposeOfEvent']) {
            this.purposeOfEvent = source.purposeOfEvent.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['agent']) {
            this.agent = source.agent.map((x) => new fhir.AuditEventAgent(x));
        }
        else {
            this.agent = null;
        }
        if (source['source']) {
            this.source = new fhir.AuditEventSource(source.source);
        }
        else {
            this.source = null;
        }
        if (source['entity']) {
            this.entity = source.entity.map((x) => new fhir.AuditEventEntity(x));
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return AuditEventTypeValueSet;
    }
    /**
     * Extensible-bound Value Set for subtype
     */
    static subtypeExtensibleValueSet() {
        return AuditEventSubTypeValueSet;
    }
    /**
     * Required-bound Value Set for action
     */
    static actionRequiredValueSet() {
        return AuditEventActionValueSet;
    }
    /**
     * Required-bound Value Set for outcome
     */
    static outcomeRequiredValueSet() {
        return AuditEventOutcomeValueSet;
    }
    /**
     * Extensible-bound Value Set for purposeOfEvent
     */
    static purposeOfEventExtensibleValueSet() {
        return V3PurposeOfUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'AuditEvent' fhir: AuditEvent.resourceType:'AuditEvent'", }));
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.Coding fhir: AuditEvent.type:Coding", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["subtype"]) {
            this.subtype.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["action"]) {
            outcome.issue.push(...this.action.doModelValidation().issue);
        }
        if (this["period"]) {
            outcome.issue.push(...this.period.doModelValidation().issue);
        }
        if (!this['recorded']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property recorded:fhir.FhirInstant fhir: AuditEvent.recorded:instant", }));
        }
        if (this["recorded"]) {
            outcome.issue.push(...this.recorded.doModelValidation().issue);
        }
        if (this["outcome"]) {
            outcome.issue.push(...this.outcome.doModelValidation().issue);
        }
        if (this["outcomeDesc"]) {
            outcome.issue.push(...this.outcomeDesc.doModelValidation().issue);
        }
        if (this["purposeOfEvent"]) {
            this.purposeOfEvent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['agent']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property agent:fhir.AuditEventAgent[] fhir: AuditEvent.agent:agent", }));
        }
        else if (!Array.isArray(this.agent)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property agent:fhir.AuditEventAgent[] fhir: AuditEvent.agent:agent", }));
        }
        else if (this.agent.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property agent:fhir.AuditEventAgent[] fhir: AuditEvent.agent:agent", }));
        }
        if (this["agent"]) {
            this.agent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['source']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property source:fhir.AuditEventSource fhir: AuditEvent.source:source", }));
        }
        if (this["source"]) {
            outcome.issue.push(...this.source.doModelValidation().issue);
        }
        if (this["entity"]) {
            this.entity.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=AuditEvent.js.map