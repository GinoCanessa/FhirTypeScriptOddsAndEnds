// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: ObservationDefinition
import * as fhir from '../fhir.js';
import { UcumUnitsValueSet } from '../fhirValueSets/UcumUnitsValueSet.js';
import { ObservationRangeCategoryValueSet } from '../fhirValueSets/ObservationRangeCategoryValueSet.js';
import { ReferencerangeMeaningValueSet } from '../fhirValueSets/ReferencerangeMeaningValueSet.js';
import { ReferencerangeAppliestoValueSet } from '../fhirValueSets/ReferencerangeAppliestoValueSet.js';
import { AdministrativeGenderValueSet } from '../fhirValueSets/AdministrativeGenderValueSet.js';
import { ObservationCategoryValueSet } from '../fhirValueSets/ObservationCategoryValueSet.js';
import { ObservationCodesValueSet } from '../fhirValueSets/ObservationCodesValueSet.js';
import { PermittedDataTypeValueSet } from '../fhirValueSets/PermittedDataTypeValueSet.js';
import { ObservationMethodsValueSet } from '../fhirValueSets/ObservationMethodsValueSet.js';
/**
 * Characteristics for quantitative results of this observation.
 */
export class ObservationDefinitionQuantitativeDetails extends fhir.BackboneElement {
    /**
     * Default constructor for ObservationDefinitionQuantitativeDetails - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['customaryUnit']) {
            this.customaryUnit = new fhir.CodeableConcept(source.customaryUnit);
        }
        if (source['unit']) {
            this.unit = new fhir.CodeableConcept(source.unit);
        }
        if (source['conversionFactor']) {
            this.conversionFactor = source.conversionFactor;
        }
        if (source['_conversionFactor']) {
            this._conversionFactor = new fhir.FhirElement(source._conversionFactor);
        }
        if (source['decimalPrecision']) {
            this.decimalPrecision = source.decimalPrecision;
        }
        if (source['_decimalPrecision']) {
            this._decimalPrecision = new fhir.FhirElement(source._decimalPrecision);
        }
    }
    /**
     * Extensible-bound Value Set for customaryUnit
     */
    customaryUnitExtensibleValueSet() {
        return UcumUnitsValueSet;
    }
    /**
     * Extensible-bound Value Set for unit
     */
    unitExtensibleValueSet() {
        return UcumUnitsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["customaryUnit"]) {
            results.push(...this.customaryUnit.doModelValidation());
        }
        if (this["unit"]) {
            results.push(...this.unit.doModelValidation());
        }
        if (this["_conversionFactor"]) {
            results.push(...this._conversionFactor.doModelValidation());
        }
        if (this["_decimalPrecision"]) {
            results.push(...this._decimalPrecision.doModelValidation());
        }
        return results;
    }
}
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export class ObservationDefinitionQualifiedInterval extends fhir.BackboneElement {
    /**
     * Default constructor for ObservationDefinitionQualifiedInterval - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['category']) {
            this.category = source.category;
        }
        if (source['_category']) {
            this._category = new fhir.FhirElement(source._category);
        }
        if (source['range']) {
            this.range = new fhir.Range(source.range);
        }
        if (source['context']) {
            this.context = new fhir.CodeableConcept(source.context);
        }
        if (source['appliesTo']) {
            this.appliesTo = source.appliesTo.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['gender']) {
            this.gender = source.gender;
        }
        if (source['_gender']) {
            this._gender = new fhir.FhirElement(source._gender);
        }
        if (source['age']) {
            this.age = new fhir.Range(source.age);
        }
        if (source['gestationalAge']) {
            this.gestationalAge = new fhir.Range(source.gestationalAge);
        }
        if (source['condition']) {
            this.condition = source.condition;
        }
        if (source['_condition']) {
            this._condition = new fhir.FhirElement(source._condition);
        }
    }
    /**
     * Required-bound Value Set for category
     */
    categoryRequiredValueSet() {
        return ObservationRangeCategoryValueSet;
    }
    /**
     * Extensible-bound Value Set for context
     */
    contextExtensibleValueSet() {
        return ReferencerangeMeaningValueSet;
    }
    /**
     * Example-bound Value Set for appliesTo
     */
    appliesToExampleValueSet() {
        return ReferencerangeAppliestoValueSet;
    }
    /**
     * Required-bound Value Set for gender
     */
    genderRequiredValueSet() {
        return AdministrativeGenderValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_category"]) {
            results.push(...this._category.doModelValidation());
        }
        if (this["range"]) {
            results.push(...this.range.doModelValidation());
        }
        if (this["context"]) {
            results.push(...this.context.doModelValidation());
        }
        if (this["appliesTo"]) {
            this.appliesTo.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_gender"]) {
            results.push(...this._gender.doModelValidation());
        }
        if (this["age"]) {
            results.push(...this.age.doModelValidation());
        }
        if (this["gestationalAge"]) {
            results.push(...this.gestationalAge.doModelValidation());
        }
        if (this["_condition"]) {
            results.push(...this._condition.doModelValidation());
        }
        return results;
    }
}
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export class ObservationDefinition extends fhir.DomainResource {
    /**
     * Default constructor for ObservationDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'ObservationDefinition';
        if (source['category']) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['permittedDataType']) {
            this.permittedDataType = source.permittedDataType.map((x) => (x));
        }
        if (source['_permittedDataType']) {
            this._permittedDataType = source._permittedDataType.map((x) => new fhir.FhirElement(x));
        }
        if (source['multipleResultsAllowed']) {
            this.multipleResultsAllowed = source.multipleResultsAllowed;
        }
        if (source['_multipleResultsAllowed']) {
            this._multipleResultsAllowed = new fhir.FhirElement(source._multipleResultsAllowed);
        }
        if (source['method']) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source['preferredReportName']) {
            this.preferredReportName = source.preferredReportName;
        }
        if (source['_preferredReportName']) {
            this._preferredReportName = new fhir.FhirElement(source._preferredReportName);
        }
        if (source['quantitativeDetails']) {
            this.quantitativeDetails = new fhir.ObservationDefinitionQuantitativeDetails(source.quantitativeDetails);
        }
        if (source['qualifiedInterval']) {
            this.qualifiedInterval = source.qualifiedInterval.map((x) => new fhir.ObservationDefinitionQualifiedInterval(x));
        }
        if (source['validCodedValueSet']) {
            this.validCodedValueSet = new fhir.Reference(source.validCodedValueSet);
        }
        if (source['normalCodedValueSet']) {
            this.normalCodedValueSet = new fhir.Reference(source.normalCodedValueSet);
        }
        if (source['abnormalCodedValueSet']) {
            this.abnormalCodedValueSet = new fhir.Reference(source.abnormalCodedValueSet);
        }
        if (source['criticalCodedValueSet']) {
            this.criticalCodedValueSet = new fhir.Reference(source.criticalCodedValueSet);
        }
    }
    /**
     * Example-bound Value Set for category
     */
    categoryExampleValueSet() {
        return ObservationCategoryValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    codeExampleValueSet() {
        return ObservationCodesValueSet;
    }
    /**
     * Required-bound Value Set for permittedDataType
     */
    permittedDataTypeRequiredValueSet() {
        return PermittedDataTypeValueSet;
    }
    /**
     * Example-bound Value Set for method
     */
    methodExampleValueSet() {
        return ObservationMethodsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: ObservationDefinition.resourceType']);
        }
        if (this["category"]) {
            this.category.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["code"]) {
            results.push(["code", 'Missing required element: ObservationDefinition.code']);
        }
        if (this["code"]) {
            results.push(...this.code.doModelValidation());
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_permittedDataType"]) {
            this._permittedDataType.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_multipleResultsAllowed"]) {
            results.push(...this._multipleResultsAllowed.doModelValidation());
        }
        if (this["method"]) {
            results.push(...this.method.doModelValidation());
        }
        if (this["_preferredReportName"]) {
            results.push(...this._preferredReportName.doModelValidation());
        }
        if (this["quantitativeDetails"]) {
            results.push(...this.quantitativeDetails.doModelValidation());
        }
        if (this["qualifiedInterval"]) {
            this.qualifiedInterval.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["validCodedValueSet"]) {
            results.push(...this.validCodedValueSet.doModelValidation());
        }
        if (this["normalCodedValueSet"]) {
            results.push(...this.normalCodedValueSet.doModelValidation());
        }
        if (this["abnormalCodedValueSet"]) {
            results.push(...this.abnormalCodedValueSet.doModelValidation());
        }
        if (this["criticalCodedValueSet"]) {
            results.push(...this.criticalCodedValueSet.doModelValidation());
        }
        return results;
    }
}
//# sourceMappingURL=ObservationDefinition.js.map