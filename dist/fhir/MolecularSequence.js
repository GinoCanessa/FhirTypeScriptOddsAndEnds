// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: MolecularSequence
import * as fhir from '../fhir.js';
import { ChromosomeHumanValueSet, } from '../fhirValueSets/ChromosomeHumanValueSet.js';
import { OrientationTypeValueSet, } from '../fhirValueSets/OrientationTypeValueSet.js';
import { StrandTypeValueSet, } from '../fhirValueSets/StrandTypeValueSet.js';
import { QualityTypeValueSet, } from '../fhirValueSets/QualityTypeValueSet.js';
import { RepositoryTypeValueSet, } from '../fhirValueSets/RepositoryTypeValueSet.js';
import { SequenceTypeValueSet, } from '../fhirValueSets/SequenceTypeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
 */
export class MolecularSequenceReferenceSeq extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceReferenceSeq - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceReferenceSeq';
        if (source['chromosome']) {
            this.chromosome = new fhir.CodeableConcept(source.chromosome);
        }
        if (source['genomeBuild']) {
            this.genomeBuild = new fhir.FhirString({ value: source.genomeBuild });
        }
        if (source['orientation']) {
            this.orientation = source.orientation;
        }
        if (source['referenceSeqId']) {
            this.referenceSeqId = new fhir.CodeableConcept(source.referenceSeqId);
        }
        if (source['referenceSeqPointer']) {
            this.referenceSeqPointer = new fhir.Reference(source.referenceSeqPointer);
        }
        if (source['referenceSeqString']) {
            this.referenceSeqString = new fhir.FhirString({ value: source.referenceSeqString });
        }
        if (source['strand']) {
            this.strand = source.strand;
        }
        if (source['windowStart']) {
            this.windowStart = new fhir.FhirInteger({ value: source.windowStart });
        }
        if (source['windowEnd']) {
            this.windowEnd = new fhir.FhirInteger({ value: source.windowEnd });
        }
    }
    /**
     * Example-bound Value Set for chromosome
     */
    static chromosomeExampleValueSet() {
        return ChromosomeHumanValueSet;
    }
    /**
     * Required-bound Value Set for orientation
     */
    static orientationRequiredValueSet() {
        return OrientationTypeValueSet;
    }
    /**
     * Required-bound Value Set for strand
     */
    static strandRequiredValueSet() {
        return StrandTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["chromosome"]) {
            outcome.issue.push(...this.chromosome.doModelValidation().issue);
        }
        if (this["genomeBuild"]) {
            outcome.issue.push(...this.genomeBuild.doModelValidation().issue);
        }
        if (this["referenceSeqId"]) {
            outcome.issue.push(...this.referenceSeqId.doModelValidation().issue);
        }
        if (this["referenceSeqPointer"]) {
            outcome.issue.push(...this.referenceSeqPointer.doModelValidation().issue);
        }
        if (this["referenceSeqString"]) {
            outcome.issue.push(...this.referenceSeqString.doModelValidation().issue);
        }
        if (this["windowStart"]) {
            outcome.issue.push(...this.windowStart.doModelValidation().issue);
        }
        if (this["windowEnd"]) {
            outcome.issue.push(...this.windowEnd.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
 */
export class MolecularSequenceVariant extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceVariant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceVariant';
        if (source['start']) {
            this.start = new fhir.FhirInteger({ value: source.start });
        }
        if (source['end']) {
            this.end = new fhir.FhirInteger({ value: source.end });
        }
        if (source['observedAllele']) {
            this.observedAllele = new fhir.FhirString({ value: source.observedAllele });
        }
        if (source['referenceAllele']) {
            this.referenceAllele = new fhir.FhirString({ value: source.referenceAllele });
        }
        if (source['cigar']) {
            this.cigar = new fhir.FhirString({ value: source.cigar });
        }
        if (source['variantPointer']) {
            this.variantPointer = new fhir.Reference(source.variantPointer);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["start"]) {
            outcome.issue.push(...this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            outcome.issue.push(...this.end.doModelValidation().issue);
        }
        if (this["observedAllele"]) {
            outcome.issue.push(...this.observedAllele.doModelValidation().issue);
        }
        if (this["referenceAllele"]) {
            outcome.issue.push(...this.referenceAllele.doModelValidation().issue);
        }
        if (this["cigar"]) {
            outcome.issue.push(...this.cigar.doModelValidation().issue);
        }
        if (this["variantPointer"]) {
            outcome.issue.push(...this.variantPointer.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
 */
export class MolecularSequenceQualityRoc extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceQualityRoc - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceQualityRoc';
        /**
         * Invidual data point representing the GQ (genotype quality) score threshold.
         */
        this.score = [];
        /**
         * The number of true positives if the GQ score threshold was set to "score" field value.
         */
        this.numTP = [];
        /**
         * The number of false positives if the GQ score threshold was set to "score" field value.
         */
        this.numFP = [];
        /**
         * The number of false negatives if the GQ score threshold was set to "score" field value.
         */
        this.numFN = [];
        /**
         * Calculated precision if the GQ score threshold was set to "score" field value.
         */
        this.precision = [];
        /**
         * Calculated sensitivity if the GQ score threshold was set to "score" field value.
         */
        this.sensitivity = [];
        /**
         * Calculated fScore if the GQ score threshold was set to "score" field value.
         */
        this.fMeasure = [];
        if (source['score']) {
            this.score = source.score.map((x) => new fhir.FhirInteger({ value: x }));
        }
        if (source['numTP']) {
            this.numTP = source.numTP.map((x) => new fhir.FhirInteger({ value: x }));
        }
        if (source['numFP']) {
            this.numFP = source.numFP.map((x) => new fhir.FhirInteger({ value: x }));
        }
        if (source['numFN']) {
            this.numFN = source.numFN.map((x) => new fhir.FhirInteger({ value: x }));
        }
        if (source['precision']) {
            this.precision = source.precision.map((x) => new fhir.FhirDecimal({ value: x }));
        }
        if (source['sensitivity']) {
            this.sensitivity = source.sensitivity.map((x) => new fhir.FhirDecimal({ value: x }));
        }
        if (source['fMeasure']) {
            this.fMeasure = source.fMeasure.map((x) => new fhir.FhirDecimal({ value: x }));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["score"]) {
            this.score.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["numTP"]) {
            this.numTP.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["numFP"]) {
            this.numFP.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["numFN"]) {
            this.numFN.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["precision"]) {
            this.precision.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["sensitivity"]) {
            this.sensitivity.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["fMeasure"]) {
            this.fMeasure.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
 */
export class MolecularSequenceQuality extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceQuality - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceQuality';
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['standardSequence']) {
            this.standardSequence = new fhir.CodeableConcept(source.standardSequence);
        }
        if (source['start']) {
            this.start = new fhir.FhirInteger({ value: source.start });
        }
        if (source['end']) {
            this.end = new fhir.FhirInteger({ value: source.end });
        }
        if (source['score']) {
            this.score = new fhir.Quantity(source.score);
        }
        if (source['method']) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source['truthTP']) {
            this.truthTP = new fhir.FhirDecimal({ value: source.truthTP });
        }
        if (source['queryTP']) {
            this.queryTP = new fhir.FhirDecimal({ value: source.queryTP });
        }
        if (source['truthFN']) {
            this.truthFN = new fhir.FhirDecimal({ value: source.truthFN });
        }
        if (source['queryFP']) {
            this.queryFP = new fhir.FhirDecimal({ value: source.queryFP });
        }
        if (source['gtFP']) {
            this.gtFP = new fhir.FhirDecimal({ value: source.gtFP });
        }
        if (source['precision']) {
            this.precision = new fhir.FhirDecimal({ value: source.precision });
        }
        if (source['recall']) {
            this.recall = new fhir.FhirDecimal({ value: source.recall });
        }
        if (source['fScore']) {
            this.fScore = new fhir.FhirDecimal({ value: source.fScore });
        }
        if (source['roc']) {
            this.roc = new fhir.MolecularSequenceQualityRoc(source.roc);
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return QualityTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:QualityTypeValueSetEnum fhir: MolecularSequence.quality.type:code", }));
        }
        if (this["standardSequence"]) {
            outcome.issue.push(...this.standardSequence.doModelValidation().issue);
        }
        if (this["start"]) {
            outcome.issue.push(...this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            outcome.issue.push(...this.end.doModelValidation().issue);
        }
        if (this["score"]) {
            outcome.issue.push(...this.score.doModelValidation().issue);
        }
        if (this["method"]) {
            outcome.issue.push(...this.method.doModelValidation().issue);
        }
        if (this["truthTP"]) {
            outcome.issue.push(...this.truthTP.doModelValidation().issue);
        }
        if (this["queryTP"]) {
            outcome.issue.push(...this.queryTP.doModelValidation().issue);
        }
        if (this["truthFN"]) {
            outcome.issue.push(...this.truthFN.doModelValidation().issue);
        }
        if (this["queryFP"]) {
            outcome.issue.push(...this.queryFP.doModelValidation().issue);
        }
        if (this["gtFP"]) {
            outcome.issue.push(...this.gtFP.doModelValidation().issue);
        }
        if (this["precision"]) {
            outcome.issue.push(...this.precision.doModelValidation().issue);
        }
        if (this["recall"]) {
            outcome.issue.push(...this.recall.doModelValidation().issue);
        }
        if (this["fScore"]) {
            outcome.issue.push(...this.fScore.doModelValidation().issue);
        }
        if (this["roc"]) {
            outcome.issue.push(...this.roc.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
 */
export class MolecularSequenceRepository extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceRepository - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceRepository';
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['datasetId']) {
            this.datasetId = new fhir.FhirString({ value: source.datasetId });
        }
        if (source['variantsetId']) {
            this.variantsetId = new fhir.FhirString({ value: source.variantsetId });
        }
        if (source['readsetId']) {
            this.readsetId = new fhir.FhirString({ value: source.readsetId });
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return RepositoryTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:RepositoryTypeValueSetEnum fhir: MolecularSequence.repository.type:code", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["datasetId"]) {
            outcome.issue.push(...this.datasetId.doModelValidation().issue);
        }
        if (this["variantsetId"]) {
            outcome.issue.push(...this.variantsetId.doModelValidation().issue);
        }
        if (this["readsetId"]) {
            outcome.issue.push(...this.readsetId.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Structural variant outer.
 */
export class MolecularSequenceStructureVariantOuter extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceStructureVariantOuter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceStructureVariantOuter';
        if (source['start']) {
            this.start = new fhir.FhirInteger({ value: source.start });
        }
        if (source['end']) {
            this.end = new fhir.FhirInteger({ value: source.end });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["start"]) {
            outcome.issue.push(...this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            outcome.issue.push(...this.end.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Structural variant inner.
 */
export class MolecularSequenceStructureVariantInner extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceStructureVariantInner - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceStructureVariantInner';
        if (source['start']) {
            this.start = new fhir.FhirInteger({ value: source.start });
        }
        if (source['end']) {
            this.end = new fhir.FhirInteger({ value: source.end });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["start"]) {
            outcome.issue.push(...this.start.doModelValidation().issue);
        }
        if (this["end"]) {
            outcome.issue.push(...this.end.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Information about chromosome structure variation.
 */
export class MolecularSequenceStructureVariant extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceStructureVariant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequenceStructureVariant';
        if (source['variantType']) {
            this.variantType = new fhir.CodeableConcept(source.variantType);
        }
        if (source['exact']) {
            this.exact = new fhir.FhirBoolean({ value: source.exact });
        }
        if (source['length']) {
            this.length = new fhir.FhirInteger({ value: source.length });
        }
        if (source['outer']) {
            this.outer = new fhir.MolecularSequenceStructureVariantOuter(source.outer);
        }
        if (source['inner']) {
            this.inner = new fhir.MolecularSequenceStructureVariantInner(source.inner);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["variantType"]) {
            outcome.issue.push(...this.variantType.doModelValidation().issue);
        }
        if (this["exact"]) {
            outcome.issue.push(...this.exact.doModelValidation().issue);
        }
        if (this["length"]) {
            outcome.issue.push(...this.length.doModelValidation().issue);
        }
        if (this["outer"]) {
            outcome.issue.push(...this.outer.doModelValidation().issue);
        }
        if (this["inner"]) {
            outcome.issue.push(...this.inner.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Raw data describing a biological sequence.
 */
export class MolecularSequence extends fhir.DomainResource {
    /**
     * Default constructor for MolecularSequence - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'MolecularSequence';
        /**
         * A unique identifier for this particular sequence instance. This is a FHIR-defined id.
         */
        this.identifier = [];
        /**
         * The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
         */
        this.variant = [];
        /**
         * An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
         */
        this.quality = [];
        /**
         * Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
         */
        this.repository = [];
        /**
         * Pointer to next atomic sequence which at most contains one variant.
         */
        this.pointer = [];
        /**
         * Information about chromosome structure variation.
         */
        this.structureVariant = [];
        this.resourceType = 'MolecularSequence';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['type']) {
            this.type = source.type;
        }
        if (source['coordinateSystem']) {
            this.coordinateSystem = new fhir.FhirInteger({ value: source.coordinateSystem });
        }
        else {
            this.coordinateSystem = null;
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        if (source['specimen']) {
            this.specimen = new fhir.Reference(source.specimen);
        }
        if (source['device']) {
            this.device = new fhir.Reference(source.device);
        }
        if (source['performer']) {
            this.performer = new fhir.Reference(source.performer);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['referenceSeq']) {
            this.referenceSeq = new fhir.MolecularSequenceReferenceSeq(source.referenceSeq);
        }
        if (source['variant']) {
            this.variant = source.variant.map((x) => new fhir.MolecularSequenceVariant(x));
        }
        if (source['observedSeq']) {
            this.observedSeq = new fhir.FhirString({ value: source.observedSeq });
        }
        if (source['quality']) {
            this.quality = source.quality.map((x) => new fhir.MolecularSequenceQuality(x));
        }
        if (source['readCoverage']) {
            this.readCoverage = new fhir.FhirInteger({ value: source.readCoverage });
        }
        if (source['repository']) {
            this.repository = source.repository.map((x) => new fhir.MolecularSequenceRepository(x));
        }
        if (source['pointer']) {
            this.pointer = source.pointer.map((x) => new fhir.Reference(x));
        }
        if (source['structureVariant']) {
            this.structureVariant = source.structureVariant.map((x) => new fhir.MolecularSequenceStructureVariant(x));
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return SequenceTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'MolecularSequence' fhir: MolecularSequence.resourceType:'MolecularSequence'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['coordinateSystem']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property coordinateSystem:fhir.FhirInteger fhir: MolecularSequence.coordinateSystem:integer", }));
        }
        if (this["coordinateSystem"]) {
            outcome.issue.push(...this.coordinateSystem.doModelValidation().issue);
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["specimen"]) {
            outcome.issue.push(...this.specimen.doModelValidation().issue);
        }
        if (this["device"]) {
            outcome.issue.push(...this.device.doModelValidation().issue);
        }
        if (this["performer"]) {
            outcome.issue.push(...this.performer.doModelValidation().issue);
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["referenceSeq"]) {
            outcome.issue.push(...this.referenceSeq.doModelValidation().issue);
        }
        if (this["variant"]) {
            this.variant.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["observedSeq"]) {
            outcome.issue.push(...this.observedSeq.doModelValidation().issue);
        }
        if (this["quality"]) {
            this.quality.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["readCoverage"]) {
            outcome.issue.push(...this.readCoverage.doModelValidation().issue);
        }
        if (this["repository"]) {
            this.repository.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["pointer"]) {
            this.pointer.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["structureVariant"]) {
            this.structureVariant.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=MolecularSequence.js.map