// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
 */
export class MolecularSequenceReferenceSeq extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceReferenceSeq - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["chromosome"]) {
            this.chromosome = new fhir.CodeableConcept(source.chromosome);
        }
        if (source["genomeBuild"]) {
            this.genomeBuild = source.genomeBuild;
        }
        if (source["_genomeBuild"]) {
            this._genomeBuild = new fhir.FhirElement(source._genomeBuild);
        }
        if (source["orientation"]) {
            this.orientation = source.orientation;
        }
        if (source["_orientation"]) {
            this._orientation = new fhir.FhirElement(source._orientation);
        }
        if (source["referenceSeqId"]) {
            this.referenceSeqId = new fhir.CodeableConcept(source.referenceSeqId);
        }
        if (source["referenceSeqPointer"]) {
            this.referenceSeqPointer = new fhir.Reference(source.referenceSeqPointer);
        }
        if (source["referenceSeqString"]) {
            this.referenceSeqString = source.referenceSeqString;
        }
        if (source["_referenceSeqString"]) {
            this._referenceSeqString = new fhir.FhirElement(source._referenceSeqString);
        }
        if (source["strand"]) {
            this.strand = source.strand;
        }
        if (source["_strand"]) {
            this._strand = new fhir.FhirElement(source._strand);
        }
        if (source["windowEnd"]) {
            this.windowEnd = source.windowEnd;
        }
        if (source["_windowEnd"]) {
            this._windowEnd = new fhir.FhirElement(source._windowEnd);
        }
        if (source["windowStart"]) {
            this.windowStart = source.windowStart;
        }
        if (source["_windowStart"]) {
            this._windowStart = new fhir.FhirElement(source._windowStart);
        }
    }
    /**
     * Check if the current MolecularSequenceReferenceSeq contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceReferenceSeq from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceReferenceSeq(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceReferenceSeq is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
 */
export class MolecularSequenceVariant extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceVariant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["cigar"]) {
            this.cigar = source.cigar;
        }
        if (source["_cigar"]) {
            this._cigar = new fhir.FhirElement(source._cigar);
        }
        if (source["end"]) {
            this.end = source.end;
        }
        if (source["_end"]) {
            this._end = new fhir.FhirElement(source._end);
        }
        if (source["observedAllele"]) {
            this.observedAllele = source.observedAllele;
        }
        if (source["_observedAllele"]) {
            this._observedAllele = new fhir.FhirElement(source._observedAllele);
        }
        if (source["referenceAllele"]) {
            this.referenceAllele = source.referenceAllele;
        }
        if (source["_referenceAllele"]) {
            this._referenceAllele = new fhir.FhirElement(source._referenceAllele);
        }
        if (source["start"]) {
            this.start = source.start;
        }
        if (source["_start"]) {
            this._start = new fhir.FhirElement(source._start);
        }
        if (source["variantPointer"]) {
            this.variantPointer = new fhir.Reference(source.variantPointer);
        }
    }
    /**
     * Check if the current MolecularSequenceVariant contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceVariant from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceVariant(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceVariant is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
 */
export class MolecularSequenceQualityRoc extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceQualityRoc - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["fMeasure"]) {
            this.fMeasure = source.fMeasure.map((x) => (x));
        }
        if (source["_fMeasure"]) {
            this._fMeasure = source._fMeasure.map((x) => new fhir.FhirElement(x));
        }
        if (source["numFN"]) {
            this.numFN = source.numFN.map((x) => (x));
        }
        if (source["_numFN"]) {
            this._numFN = source._numFN.map((x) => new fhir.FhirElement(x));
        }
        if (source["numFP"]) {
            this.numFP = source.numFP.map((x) => (x));
        }
        if (source["_numFP"]) {
            this._numFP = source._numFP.map((x) => new fhir.FhirElement(x));
        }
        if (source["numTP"]) {
            this.numTP = source.numTP.map((x) => (x));
        }
        if (source["_numTP"]) {
            this._numTP = source._numTP.map((x) => new fhir.FhirElement(x));
        }
        if (source["precision"]) {
            this.precision = source.precision.map((x) => (x));
        }
        if (source["_precision"]) {
            this._precision = source._precision.map((x) => new fhir.FhirElement(x));
        }
        if (source["score"]) {
            this.score = source.score.map((x) => (x));
        }
        if (source["_score"]) {
            this._score = source._score.map((x) => new fhir.FhirElement(x));
        }
        if (source["sensitivity"]) {
            this.sensitivity = source.sensitivity.map((x) => (x));
        }
        if (source["_sensitivity"]) {
            this._sensitivity = source._sensitivity.map((x) => new fhir.FhirElement(x));
        }
    }
    /**
     * Check if the current MolecularSequenceQualityRoc contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceQualityRoc from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceQualityRoc(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceQualityRoc is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
 */
export class MolecularSequenceQuality extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceQuality - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["end"]) {
            this.end = source.end;
        }
        if (source["_end"]) {
            this._end = new fhir.FhirElement(source._end);
        }
        if (source["fScore"]) {
            this.fScore = source.fScore;
        }
        if (source["_fScore"]) {
            this._fScore = new fhir.FhirElement(source._fScore);
        }
        if (source["gtFP"]) {
            this.gtFP = source.gtFP;
        }
        if (source["_gtFP"]) {
            this._gtFP = new fhir.FhirElement(source._gtFP);
        }
        if (source["method"]) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source["precision"]) {
            this.precision = source.precision;
        }
        if (source["_precision"]) {
            this._precision = new fhir.FhirElement(source._precision);
        }
        if (source["queryFP"]) {
            this.queryFP = source.queryFP;
        }
        if (source["_queryFP"]) {
            this._queryFP = new fhir.FhirElement(source._queryFP);
        }
        if (source["queryTP"]) {
            this.queryTP = source.queryTP;
        }
        if (source["_queryTP"]) {
            this._queryTP = new fhir.FhirElement(source._queryTP);
        }
        if (source["recall"]) {
            this.recall = source.recall;
        }
        if (source["_recall"]) {
            this._recall = new fhir.FhirElement(source._recall);
        }
        if (source["roc"]) {
            this.roc = new fhir.MolecularSequenceQualityRoc(source.roc);
        }
        if (source["score"]) {
            this.score = new fhir.Quantity(source.score);
        }
        if (source["standardSequence"]) {
            this.standardSequence = new fhir.CodeableConcept(source.standardSequence);
        }
        if (source["start"]) {
            this.start = source.start;
        }
        if (source["_start"]) {
            this._start = new fhir.FhirElement(source._start);
        }
        if (source["truthFN"]) {
            this.truthFN = source.truthFN;
        }
        if (source["_truthFN"]) {
            this._truthFN = new fhir.FhirElement(source._truthFN);
        }
        if (source["truthTP"]) {
            this.truthTP = source.truthTP;
        }
        if (source["_truthTP"]) {
            this._truthTP = new fhir.FhirElement(source._truthTP);
        }
        this.type = null;
        if (source["type"]) {
            this.type = source.type;
        }
        if (this.type === undefined) {
            this.type = null;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Check if the current MolecularSequenceQuality contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceQuality from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceQuality(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceQuality is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
 */
export class MolecularSequenceRepository extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceRepository - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["datasetId"]) {
            this.datasetId = source.datasetId;
        }
        if (source["_datasetId"]) {
            this._datasetId = new fhir.FhirElement(source._datasetId);
        }
        if (source["name"]) {
            this.name = source.name;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["readsetId"]) {
            this.readsetId = source.readsetId;
        }
        if (source["_readsetId"]) {
            this._readsetId = new fhir.FhirElement(source._readsetId);
        }
        this.type = null;
        if (source["type"]) {
            this.type = source.type;
        }
        if (this.type === undefined) {
            this.type = null;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["variantsetId"]) {
            this.variantsetId = source.variantsetId;
        }
        if (source["_variantsetId"]) {
            this._variantsetId = new fhir.FhirElement(source._variantsetId);
        }
    }
    /**
     * Check if the current MolecularSequenceRepository contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceRepository from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceRepository(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceRepository is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Structural variant outer.
 */
export class MolecularSequenceStructureVariantOuter extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceStructureVariantOuter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["end"]) {
            this.end = source.end;
        }
        if (source["_end"]) {
            this._end = new fhir.FhirElement(source._end);
        }
        if (source["start"]) {
            this.start = source.start;
        }
        if (source["_start"]) {
            this._start = new fhir.FhirElement(source._start);
        }
    }
    /**
     * Check if the current MolecularSequenceStructureVariantOuter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceStructureVariantOuter from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceStructureVariantOuter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceStructureVariantOuter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Structural variant inner.
 */
export class MolecularSequenceStructureVariantInner extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceStructureVariantInner - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["end"]) {
            this.end = source.end;
        }
        if (source["_end"]) {
            this._end = new fhir.FhirElement(source._end);
        }
        if (source["start"]) {
            this.start = source.start;
        }
        if (source["_start"]) {
            this._start = new fhir.FhirElement(source._start);
        }
    }
    /**
     * Check if the current MolecularSequenceStructureVariantInner contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceStructureVariantInner from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceStructureVariantInner(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceStructureVariantInner is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Information about chromosome structure variation.
 */
export class MolecularSequenceStructureVariant extends fhir.BackboneElement {
    /**
     * Default constructor for MolecularSequenceStructureVariant - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["exact"]) {
            this.exact = source.exact;
        }
        if (source["_exact"]) {
            this._exact = new fhir.FhirElement(source._exact);
        }
        if (source["inner"]) {
            this.inner = new fhir.MolecularSequenceStructureVariantInner(source.inner);
        }
        if (source["length"]) {
            this.length = source.length;
        }
        if (source["_length"]) {
            this._length = new fhir.FhirElement(source._length);
        }
        if (source["outer"]) {
            this.outer = new fhir.MolecularSequenceStructureVariantOuter(source.outer);
        }
        if (source["variantType"]) {
            this.variantType = new fhir.CodeableConcept(source.variantType);
        }
    }
    /**
     * Check if the current MolecularSequenceStructureVariant contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequenceStructureVariant from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequenceStructureVariant(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequenceStructureVariant is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Raw data describing a biological sequence.
 */
export class MolecularSequence extends fhir.DomainResource {
    /**
     * Default constructor for MolecularSequence - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'MolecularSequence';
        this.coordinateSystem = null;
        if (source["coordinateSystem"]) {
            this.coordinateSystem = source.coordinateSystem;
        }
        if (this.coordinateSystem === undefined) {
            this.coordinateSystem = null;
        }
        if (source["_coordinateSystem"]) {
            this._coordinateSystem = new fhir.FhirElement(source._coordinateSystem);
        }
        if (source["device"]) {
            this.device = new fhir.Reference(source.device);
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["observedSeq"]) {
            this.observedSeq = source.observedSeq;
        }
        if (source["_observedSeq"]) {
            this._observedSeq = new fhir.FhirElement(source._observedSeq);
        }
        if (source["patient"]) {
            this.patient = new fhir.Reference(source.patient);
        }
        if (source["performer"]) {
            this.performer = new fhir.Reference(source.performer);
        }
        if (source["pointer"]) {
            this.pointer = source.pointer.map((x) => new fhir.Reference(x));
        }
        if (source["quality"]) {
            this.quality = source.quality.map((x) => new fhir.MolecularSequenceQuality(x));
        }
        if (source["quantity"]) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source["readCoverage"]) {
            this.readCoverage = source.readCoverage;
        }
        if (source["_readCoverage"]) {
            this._readCoverage = new fhir.FhirElement(source._readCoverage);
        }
        if (source["referenceSeq"]) {
            this.referenceSeq = new fhir.MolecularSequenceReferenceSeq(source.referenceSeq);
        }
        if (source["repository"]) {
            this.repository = source.repository.map((x) => new fhir.MolecularSequenceRepository(x));
        }
        if (source["specimen"]) {
            this.specimen = new fhir.Reference(source.specimen);
        }
        if (source["structureVariant"]) {
            this.structureVariant = source.structureVariant.map((x) => new fhir.MolecularSequenceStructureVariant(x));
        }
        if (source["type"]) {
            this.type = source.type;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
        if (source["variant"]) {
            this.variant = source.variant.map((x) => new fhir.MolecularSequenceVariant(x));
        }
    }
    /**
     * Check if the current MolecularSequence contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["coordinateSystem"] === undefined) {
            missingElements.push("coordinateSystem");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MolecularSequence from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new MolecularSequence(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `MolecularSequence is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the MolecularSequence.referenceSeq.orientation field
 */
export var MolecularSequenceReferenceSeqOrientationEnum;
(function (MolecularSequenceReferenceSeqOrientationEnum) {
    MolecularSequenceReferenceSeqOrientationEnum["SENSE"] = "sense";
    MolecularSequenceReferenceSeqOrientationEnum["ANTISENSE"] = "antisense";
})(MolecularSequenceReferenceSeqOrientationEnum || (MolecularSequenceReferenceSeqOrientationEnum = {}));
/**
 * Code Values for the MolecularSequence.referenceSeq.strand field
 */
export var MolecularSequenceReferenceSeqStrandEnum;
(function (MolecularSequenceReferenceSeqStrandEnum) {
    MolecularSequenceReferenceSeqStrandEnum["WATSON"] = "watson";
    MolecularSequenceReferenceSeqStrandEnum["CRICK"] = "crick";
})(MolecularSequenceReferenceSeqStrandEnum || (MolecularSequenceReferenceSeqStrandEnum = {}));
/**
 * Code Values for the MolecularSequence.quality.type field
 */
export var MolecularSequenceQualityTypeEnum;
(function (MolecularSequenceQualityTypeEnum) {
    MolecularSequenceQualityTypeEnum["INDEL"] = "indel";
    MolecularSequenceQualityTypeEnum["SNP"] = "snp";
    MolecularSequenceQualityTypeEnum["UNKNOWN"] = "unknown";
})(MolecularSequenceQualityTypeEnum || (MolecularSequenceQualityTypeEnum = {}));
/**
 * Code Values for the MolecularSequence.repository.type field
 */
export var MolecularSequenceRepositoryTypeEnum;
(function (MolecularSequenceRepositoryTypeEnum) {
    MolecularSequenceRepositoryTypeEnum["DIRECTLINK"] = "directlink";
    MolecularSequenceRepositoryTypeEnum["OPENAPI"] = "openapi";
    MolecularSequenceRepositoryTypeEnum["LOGIN"] = "login";
    MolecularSequenceRepositoryTypeEnum["OAUTH"] = "oauth";
    MolecularSequenceRepositoryTypeEnum["OTHER"] = "other";
})(MolecularSequenceRepositoryTypeEnum || (MolecularSequenceRepositoryTypeEnum = {}));
/**
 * Code Values for the MolecularSequence.type field
 */
export var MolecularSequenceTypeEnum;
(function (MolecularSequenceTypeEnum) {
    MolecularSequenceTypeEnum["AA"] = "aa";
    MolecularSequenceTypeEnum["DNA"] = "dna";
    MolecularSequenceTypeEnum["RNA"] = "rna";
})(MolecularSequenceTypeEnum || (MolecularSequenceTypeEnum = {}));
//# sourceMappingURL=MolecularSequence.js.map