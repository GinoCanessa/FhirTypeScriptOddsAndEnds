// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: NutritionOrder
import * as fhir from '../fhir.js';
import { NutrientCodeValueSet, } from '../fhirValueSets/NutrientCodeValueSet.js';
import { ModifiedFoodtypeValueSet, } from '../fhirValueSets/ModifiedFoodtypeValueSet.js';
import { DietTypeValueSet, } from '../fhirValueSets/DietTypeValueSet.js';
import { EntformulaAdditiveValueSet, } from '../fhirValueSets/EntformulaAdditiveValueSet.js';
import { EnteralRouteValueSet, } from '../fhirValueSets/EnteralRouteValueSet.js';
import { RequestStatusValueSet, } from '../fhirValueSets/RequestStatusValueSet.js';
import { RequestIntentValueSet, } from '../fhirValueSets/RequestIntentValueSet.js';
import { EncounterDietValueSet, } from '../fhirValueSets/EncounterDietValueSet.js';
import { FoodTypeValueSet, } from '../fhirValueSets/FoodTypeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
 */
export class NutritionOrderOralDietNutrient extends fhir.BackboneElement {
    /**
     * Default constructor for NutritionOrderOralDietNutrient - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrderOralDietNutrient';
        if (source['modifier']) {
            this.modifier = new fhir.CodeableConcept(source.modifier);
        }
        if (source['amount']) {
            this.amount = new fhir.Quantity(source.amount);
        }
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return NutrientCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["modifier"]) {
            outcome.issue.push(...this.modifier.doModelValidation().issue);
        }
        if (this["amount"]) {
            outcome.issue.push(...this.amount.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
 */
export class NutritionOrderOralDietTexture extends fhir.BackboneElement {
    /**
     * Default constructor for NutritionOrderOralDietTexture - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrderOralDietTexture';
        if (source['modifier']) {
            this.modifier = new fhir.CodeableConcept(source.modifier);
        }
        if (source['foodType']) {
            this.foodType = new fhir.CodeableConcept(source.foodType);
        }
    }
    /**
     * Example-bound Value Set for foodType
     */
    static foodTypeExampleValueSet() {
        return ModifiedFoodtypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["modifier"]) {
            outcome.issue.push(...this.modifier.doModelValidation().issue);
        }
        if (this["foodType"]) {
            outcome.issue.push(...this.foodType.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Diet given orally in contrast to enteral (tube) feeding.
 */
export class NutritionOrderOralDiet extends fhir.BackboneElement {
    /**
     * Default constructor for NutritionOrderOralDiet - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrderOralDiet';
        /**
         * The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet.
         */
        this.type = [];
        /**
         * The time period and frequency at which the diet should be given.  The diet should be given for the combination of all schedules if more than one schedule is present.
         */
        this.schedule = [];
        /**
         * Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
         */
        this.nutrient = [];
        /**
         * Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
         */
        this.texture = [];
        /**
         * The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient.
         */
        this.fluidConsistencyType = [];
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['schedule']) {
            this.schedule = source.schedule.map((x) => new fhir.Timing(x));
        }
        if (source['nutrient']) {
            this.nutrient = source.nutrient.map((x) => new fhir.NutritionOrderOralDietNutrient(x));
        }
        if (source['texture']) {
            this.texture = source.texture.map((x) => new fhir.NutritionOrderOralDietTexture(x));
        }
        if (source['fluidConsistencyType']) {
            this.fluidConsistencyType = source.fluidConsistencyType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['instruction']) {
            this.instruction = new fhir.FhirString({ value: source.instruction });
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return DietTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["schedule"]) {
            this.schedule.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["nutrient"]) {
            this.nutrient.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["texture"]) {
            this.texture.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["fluidConsistencyType"]) {
            this.fluidConsistencyType.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["instruction"]) {
            outcome.issue.push(...this.instruction.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Oral nutritional products given in order to add further nutritional value to the patient's diet.
 */
export class NutritionOrderSupplement extends fhir.BackboneElement {
    /**
     * Default constructor for NutritionOrderSupplement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrderSupplement';
        /**
         * The time period and frequency at which the supplement(s) should be given.  The supplement should be given for the combination of all schedules if more than one schedule is present.
         */
        this.schedule = [];
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['productName']) {
            this.productName = new fhir.FhirString({ value: source.productName });
        }
        if (source['schedule']) {
            this.schedule = source.schedule.map((x) => new fhir.Timing(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['instruction']) {
            this.instruction = new fhir.FhirString({ value: source.instruction });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["productName"]) {
            outcome.issue.push(...this.productName.doModelValidation().issue);
        }
        if (this["schedule"]) {
            this.schedule.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["instruction"]) {
            outcome.issue.push(...this.instruction.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * See implementation notes below for further discussion on how to order continuous vs bolus enteral feeding using this resource.
 */
export class NutritionOrderEnteralFormulaAdministration extends fhir.BackboneElement {
    /**
     * Default constructor for NutritionOrderEnteralFormulaAdministration - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrderEnteralFormulaAdministration';
        this.__rateIsChoice = true;
        if (source['schedule']) {
            this.schedule = new fhir.Timing(source.schedule);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['rate']) {
            this.rate = source.rate;
        }
        else if (source['rateQuantity']) {
            this.rate = new fhir.Quantity(source.rateQuantity);
        }
        else if (source['rateRatio']) {
            this.rate = new fhir.Ratio(source.rateRatio);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["schedule"]) {
            outcome.issue.push(...this.schedule.doModelValidation().issue);
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
 */
export class NutritionOrderEnteralFormula extends fhir.BackboneElement {
    /**
     * Default constructor for NutritionOrderEnteralFormula - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrderEnteralFormula';
        /**
         * See implementation notes below for further discussion on how to order continuous vs bolus enteral feeding using this resource.
         */
        this.administration = [];
        if (source['baseFormulaType']) {
            this.baseFormulaType = new fhir.CodeableConcept(source.baseFormulaType);
        }
        if (source['baseFormulaProductName']) {
            this.baseFormulaProductName = new fhir.FhirString({ value: source.baseFormulaProductName });
        }
        if (source['additiveType']) {
            this.additiveType = new fhir.CodeableConcept(source.additiveType);
        }
        if (source['additiveProductName']) {
            this.additiveProductName = new fhir.FhirString({ value: source.additiveProductName });
        }
        if (source['caloricDensity']) {
            this.caloricDensity = new fhir.Quantity(source.caloricDensity);
        }
        if (source['routeofAdministration']) {
            this.routeofAdministration = new fhir.CodeableConcept(source.routeofAdministration);
        }
        if (source['administration']) {
            this.administration = source.administration.map((x) => new fhir.NutritionOrderEnteralFormulaAdministration(x));
        }
        if (source['maxVolumeToDeliver']) {
            this.maxVolumeToDeliver = new fhir.Quantity(source.maxVolumeToDeliver);
        }
        if (source['administrationInstruction']) {
            this.administrationInstruction = new fhir.FhirString({ value: source.administrationInstruction });
        }
    }
    /**
     * Example-bound Value Set for additiveType
     */
    static additiveTypeExampleValueSet() {
        return EntformulaAdditiveValueSet;
    }
    /**
     * Extensible-bound Value Set for routeofAdministration
     */
    static routeofAdministrationExtensibleValueSet() {
        return EnteralRouteValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["baseFormulaType"]) {
            outcome.issue.push(...this.baseFormulaType.doModelValidation().issue);
        }
        if (this["baseFormulaProductName"]) {
            outcome.issue.push(...this.baseFormulaProductName.doModelValidation().issue);
        }
        if (this["additiveType"]) {
            outcome.issue.push(...this.additiveType.doModelValidation().issue);
        }
        if (this["additiveProductName"]) {
            outcome.issue.push(...this.additiveProductName.doModelValidation().issue);
        }
        if (this["caloricDensity"]) {
            outcome.issue.push(...this.caloricDensity.doModelValidation().issue);
        }
        if (this["routeofAdministration"]) {
            outcome.issue.push(...this.routeofAdministration.doModelValidation().issue);
        }
        if (this["administration"]) {
            this.administration.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["maxVolumeToDeliver"]) {
            outcome.issue.push(...this.maxVolumeToDeliver.doModelValidation().issue);
        }
        if (this["administrationInstruction"]) {
            outcome.issue.push(...this.administrationInstruction.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
 */
export class NutritionOrder extends fhir.DomainResource {
    /**
     * Default constructor for NutritionOrder - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'NutritionOrder';
        /**
         * The Identifier.type element can be to indicate filler vs. placer if needed.  This is explained in further detail [here](servicerequest.html#notes).
         */
        this.identifier = [];
        /**
         * Note: This is a business identifier, not a resource identifier (see [discussion](resource.html#identifiers)).  It is best practice for the identifier to only appear on a single resource instance, however business practices may occasionally dictate that multiple resource instances with the same identifier can exist - possibly even with different resource types.  For example, multiple Patient and a Person resource instance might share the same social insurance number.
         */
        this.instantiatesCanonical = [];
        /**
         * This might be an HTML page, PDF, etc. or could just be a non-resolvable URI identifier.
         */
        this.instantiatesUri = [];
        /**
         * The URL pointing to a protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
         */
        this.instantiates = [];
        /**
         * Information on a patient's food allergies and intolerances to inform healthcare personnel about the type of foods that the patient shouldn't receive or consume.
         */
        this.allergyIntolerance = [];
        /**
         * Information on a patient's food preferences that inform healthcare personnel about the food that the patient should receive or consume.
         */
        this.foodPreferenceModifier = [];
        /**
         * Information on a patient's food allergies, intolerances and preferences to inform healthcare personnel about the type  of foods that the patient shouldn't receive or consume.
         */
        this.excludeFoodModifier = [];
        /**
         * Oral nutritional products given in order to add further nutritional value to the patient's diet.
         */
        this.supplement = [];
        /**
         * This element SHALL NOT be used to supply free text instructions for the diet which are represented in the `.oralDiet.instruction`, `supplement.instruction`, or `enteralFormula.administrationInstruction` elements.
         */
        this.note = [];
        this.resourceType = 'NutritionOrder';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['instantiatesCanonical']) {
            this.instantiatesCanonical = source.instantiatesCanonical.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['instantiatesUri']) {
            this.instantiatesUri = source.instantiatesUri.map((x) => new fhir.FhirUri({ value: x }));
        }
        if (source['instantiates']) {
            this.instantiates = source.instantiates.map((x) => new fhir.FhirUri({ value: x }));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['intent']) {
            this.intent = source.intent;
        }
        else {
            this.intent = null;
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        else {
            this.patient = null;
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['dateTime']) {
            this.dateTime = new fhir.FhirDateTime({ value: source.dateTime });
        }
        else {
            this.dateTime = null;
        }
        if (source['orderer']) {
            this.orderer = new fhir.Reference(source.orderer);
        }
        if (source['allergyIntolerance']) {
            this.allergyIntolerance = source.allergyIntolerance.map((x) => new fhir.Reference(x));
        }
        if (source['foodPreferenceModifier']) {
            this.foodPreferenceModifier = source.foodPreferenceModifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['excludeFoodModifier']) {
            this.excludeFoodModifier = source.excludeFoodModifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['oralDiet']) {
            this.oralDiet = new fhir.NutritionOrderOralDiet(source.oralDiet);
        }
        if (source['supplement']) {
            this.supplement = source.supplement.map((x) => new fhir.NutritionOrderSupplement(x));
        }
        if (source['enteralFormula']) {
            this.enteralFormula = new fhir.NutritionOrderEnteralFormula(source.enteralFormula);
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return RequestStatusValueSet;
    }
    /**
     * Required-bound Value Set for intent
     */
    static intentRequiredValueSet() {
        return RequestIntentValueSet;
    }
    /**
     * Example-bound Value Set for foodPreferenceModifier
     */
    static foodPreferenceModifierExampleValueSet() {
        return EncounterDietValueSet;
    }
    /**
     * Example-bound Value Set for excludeFoodModifier
     */
    static excludeFoodModifierExampleValueSet() {
        return FoodTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'NutritionOrder' fhir: NutritionOrder.resourceType:'NutritionOrder'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["instantiatesCanonical"]) {
            this.instantiatesCanonical.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["instantiatesUri"]) {
            this.instantiatesUri.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["instantiates"]) {
            this.instantiates.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:RequestStatusValueSetEnum fhir: NutritionOrder.status:code", }));
        }
        if (!this['intent']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property intent:RequestIntentValueSetEnum fhir: NutritionOrder.intent:code", }));
        }
        if (!this['patient']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property patient:fhir.Reference fhir: NutritionOrder.patient:Reference", }));
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["encounter"]) {
            outcome.issue.push(...this.encounter.doModelValidation().issue);
        }
        if (!this['dateTime']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property dateTime:fhir.FhirDateTime fhir: NutritionOrder.dateTime:dateTime", }));
        }
        if (this["dateTime"]) {
            outcome.issue.push(...this.dateTime.doModelValidation().issue);
        }
        if (this["orderer"]) {
            outcome.issue.push(...this.orderer.doModelValidation().issue);
        }
        if (this["allergyIntolerance"]) {
            this.allergyIntolerance.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["foodPreferenceModifier"]) {
            this.foodPreferenceModifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["excludeFoodModifier"]) {
            this.excludeFoodModifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["oralDiet"]) {
            outcome.issue.push(...this.oralDiet.doModelValidation().issue);
        }
        if (this["supplement"]) {
            this.supplement.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["enteralFormula"]) {
            outcome.issue.push(...this.enteralFormula.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=NutritionOrder.js.map