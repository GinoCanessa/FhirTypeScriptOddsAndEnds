// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: CodeSystem
import * as fhir from '../fhir.js';
import { FilterOperatorValueSet, } from '../fhirValueSets/FilterOperatorValueSet.js';
import { ConceptPropertyTypeValueSet, } from '../fhirValueSets/ConceptPropertyTypeValueSet.js';
import { LanguagesValueSet, } from '../fhirValueSets/LanguagesValueSet.js';
import { DesignationUseValueSet, } from '../fhirValueSets/DesignationUseValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { CodesystemHierarchyMeaningValueSet, } from '../fhirValueSets/CodesystemHierarchyMeaningValueSet.js';
import { CodesystemContentModeValueSet, } from '../fhirValueSets/CodesystemContentModeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Note that filters defined in code systems usually require custom code on the part of any terminology engine that will make them available for use in value set filters. For this reason, they are generally only seen in high value published terminologies.
 */
export class CodeSystemFilter extends fhir.BackboneElement {
    /**
     * Default constructor for CodeSystemFilter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CodeSystemFilter';
        /**
         * A list of operators that can be used with the filter.
         */
        this.operator = [];
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['operator']) {
            this.operator = source.operator.map((x) => x);
        }
        else {
            this.operator = null;
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Required-bound Value Set for operator
     */
    static operatorRequiredValueSet() {
        return FilterOperatorValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: CodeSystem.filter.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (!this['operator']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property operator:FilterOperatorValueSetEnum[] fhir: CodeSystem.filter.operator:code", }));
        }
        else if (!Array.isArray(this.operator)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property operator:FilterOperatorValueSetEnum[] fhir: CodeSystem.filter.operator:code", }));
        }
        else if (this.operator.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property operator:FilterOperatorValueSetEnum[] fhir: CodeSystem.filter.operator:code", }));
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value:fhir.FhirString fhir: CodeSystem.filter.value:string", }));
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A property defines an additional slot through which additional information can be provided about a concept.
 */
export class CodeSystemProperty extends fhir.BackboneElement {
    /**
     * Default constructor for CodeSystemProperty - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CodeSystemProperty';
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['uri']) {
            this.uri = new fhir.FhirUri({ value: source.uri });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return ConceptPropertyTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: CodeSystem.property.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["uri"]) {
            outcome.issue.push(...this.uri.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:ConceptPropertyTypeValueSetEnum fhir: CodeSystem.property.type:code", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
 */
export class CodeSystemConceptDesignation extends fhir.BackboneElement {
    /**
     * Default constructor for CodeSystemConceptDesignation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CodeSystemConceptDesignation';
        if (source['language']) {
            this.language = new fhir.FhirCode({ value: source.language });
        }
        if (source['use']) {
            this.use = new fhir.Coding(source.use);
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Preferred-bound Value Set for language
     */
    static languagePreferredValueSet() {
        return LanguagesValueSet;
    }
    /**
     * Extensible-bound Value Set for use
     */
    static useExtensibleValueSet() {
        return DesignationUseValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["language"]) {
            outcome.issue.push(...this.language.doModelValidation().issue);
        }
        if (this["use"]) {
            outcome.issue.push(...this.use.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value:fhir.FhirString fhir: CodeSystem.concept.designation.value:string", }));
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A property value for this concept.
 */
export class CodeSystemConceptProperty extends fhir.BackboneElement {
    /**
     * Default constructor for CodeSystemConceptProperty - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CodeSystemConceptProperty';
        this.__valueIsChoice = true;
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueCode']) {
            this.value = new fhir.FhirCode({ value: source.valueCode });
        }
        else if (source['valueCoding']) {
            this.value = new fhir.Coding(source.valueCoding);
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueInteger']) {
            this.value = new fhir.FhirInteger({ value: source.valueInteger });
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueDateTime']) {
            this.value = new fhir.FhirDateTime({ value: source.valueDateTime });
        }
        else if (source['valueDecimal']) {
            this.value = new fhir.FhirDecimal({ value: source.valueDecimal });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: CodeSystem.concept.property.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value: fhir: CodeSystem.concept.property.value[x]:", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * If this is empty, it means that the code system resource does not represent the content of the code system.
 */
export class CodeSystemConcept extends fhir.BackboneElement {
    /**
     * Default constructor for CodeSystemConcept - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CodeSystemConcept';
        /**
         * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
         */
        this.designation = [];
        /**
         * A property value for this concept.
         */
        this.property = [];
        /**
         * Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) - see hierarchyMeaning.
         */
        this.concept = [];
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['display']) {
            this.display = new fhir.FhirString({ value: source.display });
        }
        if (source['definition']) {
            this.definition = new fhir.FhirString({ value: source.definition });
        }
        if (source['designation']) {
            this.designation = source.designation.map((x) => new fhir.CodeSystemConceptDesignation(x));
        }
        if (source['property']) {
            this.property = source.property.map((x) => new fhir.CodeSystemConceptProperty(x));
        }
        if (source['concept']) {
            this.concept = source.concept.map((x) => new fhir.CodeSystemConcept(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: CodeSystem.concept.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["display"]) {
            outcome.issue.push(...this.display.doModelValidation().issue);
        }
        if (this["definition"]) {
            outcome.issue.push(...this.definition.doModelValidation().issue);
        }
        if (this["designation"]) {
            this.designation.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["property"]) {
            this.property.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["concept"]) {
            this.concept.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content.
 */
export class CodeSystem extends fhir.DomainResource {
    /**
     * Default constructor for CodeSystem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'CodeSystem';
        /**
         * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this code system outside of FHIR, where it is not possible to use the logical URI.  Note that HL7 defines at least three identifiers for many of its code systems - the FHIR canonical URL, the OID and the V2 Table 0396 mnemonic code.
         */
        this.identifier = [];
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the code system to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * Note that filters defined in code systems usually require custom code on the part of any terminology engine that will make them available for use in value set filters. For this reason, they are generally only seen in high value published terminologies.
         */
        this.filter = [];
        /**
         * A property defines an additional slot through which additional information can be provided about a concept.
         */
        this.property = [];
        /**
         * If this is empty, it means that the code system resource does not represent the content of the code system.
         */
        this.concept = [];
        this.resourceType = 'CodeSystem';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['caseSensitive']) {
            this.caseSensitive = new fhir.FhirBoolean({ value: source.caseSensitive });
        }
        if (source['valueSet']) {
            this.valueSet = new fhir.FhirCanonical({ value: source.valueSet });
        }
        if (source['hierarchyMeaning']) {
            this.hierarchyMeaning = source.hierarchyMeaning;
        }
        if (source['compositional']) {
            this.compositional = new fhir.FhirBoolean({ value: source.compositional });
        }
        if (source['versionNeeded']) {
            this.versionNeeded = new fhir.FhirBoolean({ value: source.versionNeeded });
        }
        if (source['content']) {
            this.content = source.content;
        }
        else {
            this.content = null;
        }
        if (source['supplements']) {
            this.supplements = new fhir.FhirCanonical({ value: source.supplements });
        }
        if (source['count']) {
            this.count = new fhir.FhirUnsignedInt({ value: source.count });
        }
        if (source['filter']) {
            this.filter = source.filter.map((x) => new fhir.CodeSystemFilter(x));
        }
        if (source['property']) {
            this.property = source.property.map((x) => new fhir.CodeSystemProperty(x));
        }
        if (source['concept']) {
            this.concept = source.concept.map((x) => new fhir.CodeSystemConcept(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Required-bound Value Set for hierarchyMeaning
     */
    static hierarchyMeaningRequiredValueSet() {
        return CodesystemHierarchyMeaningValueSet;
    }
    /**
     * Required-bound Value Set for content
     */
    static contentRequiredValueSet() {
        return CodesystemContentModeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'CodeSystem' fhir: CodeSystem.resourceType:'CodeSystem'", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: CodeSystem.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["caseSensitive"]) {
            outcome.issue.push(...this.caseSensitive.doModelValidation().issue);
        }
        if (this["valueSet"]) {
            outcome.issue.push(...this.valueSet.doModelValidation().issue);
        }
        if (this["compositional"]) {
            outcome.issue.push(...this.compositional.doModelValidation().issue);
        }
        if (this["versionNeeded"]) {
            outcome.issue.push(...this.versionNeeded.doModelValidation().issue);
        }
        if (!this['content']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property content:CodesystemContentModeValueSetEnum fhir: CodeSystem.content:code", }));
        }
        if (this["supplements"]) {
            outcome.issue.push(...this.supplements.doModelValidation().issue);
        }
        if (this["count"]) {
            outcome.issue.push(...this.count.doModelValidation().issue);
        }
        if (this["filter"]) {
            this.filter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["property"]) {
            this.property.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["concept"]) {
            this.concept.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=CodeSystem.js.map