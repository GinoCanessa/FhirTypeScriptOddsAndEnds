// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Specimen
import * as fhir from '../fhir.js';
import { SpecimenCollectionMethodValueSet, } from '../fhirValueSets/SpecimenCollectionMethodValueSet.js';
import { BodySiteValueSet, } from '../fhirValueSets/BodySiteValueSet.js';
import { SpecimenProcessingProcedureValueSet, } from '../fhirValueSets/SpecimenProcessingProcedureValueSet.js';
import { SpecimenContainerTypeValueSet, } from '../fhirValueSets/SpecimenContainerTypeValueSet.js';
import { SpecimenStatusValueSet, } from '../fhirValueSets/SpecimenStatusValueSet.js';
import { V20487ValueSet, } from '../fhirValueSets/V20487ValueSet.js';
import { V20493ValueSet, } from '../fhirValueSets/V20493ValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Details concerning the specimen collection.
 */
export class SpecimenCollection extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenCollection - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenCollection';
        this.__collectedIsChoice = true;
        this.__fastingStatusIsChoice = true;
        if (source['collector']) {
            this.collector = new fhir.Reference(source.collector);
        }
        if (source['collected']) {
            this.collected = source.collected;
        }
        else if (source['collectedDateTime']) {
            this.collected = new fhir.FhirDateTime({ value: source.collectedDateTime });
        }
        else if (source['collectedPeriod']) {
            this.collected = new fhir.Period(source.collectedPeriod);
        }
        if (source['duration']) {
            this.duration = new fhir.Duration(source.duration);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['method']) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source['bodySite']) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source['fastingStatus']) {
            this.fastingStatus = source.fastingStatus;
        }
        else if (source['fastingStatusCodeableConcept']) {
            this.fastingStatus = new fhir.CodeableConcept(source.fastingStatusCodeableConcept);
        }
        else if (source['fastingStatusDuration']) {
            this.fastingStatus = new fhir.Duration(source.fastingStatusDuration);
        }
    }
    /**
     * Example-bound Value Set for method
     */
    static methodExampleValueSet() {
        return SpecimenCollectionMethodValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return BodySiteValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["collector"]) {
            outcome.issue.push(...this.collector.doModelValidation().issue);
        }
        if (this["duration"]) {
            outcome.issue.push(...this.duration.doModelValidation().issue);
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["method"]) {
            outcome.issue.push(...this.method.doModelValidation().issue);
        }
        if (this["bodySite"]) {
            outcome.issue.push(...this.bodySite.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Details concerning processing and processing steps for the specimen.
 */
export class SpecimenProcessing extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenProcessing - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenProcessing';
        /**
         * Material used in the processing step.
         */
        this.additive = [];
        this.__timeIsChoice = true;
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['procedure']) {
            this.procedure = new fhir.CodeableConcept(source.procedure);
        }
        if (source['additive']) {
            this.additive = source.additive.map((x) => new fhir.Reference(x));
        }
        if (source['time']) {
            this.time = source.time;
        }
        else if (source['timeDateTime']) {
            this.time = new fhir.FhirDateTime({ value: source.timeDateTime });
        }
        else if (source['timePeriod']) {
            this.time = new fhir.Period(source.timePeriod);
        }
    }
    /**
     * Example-bound Value Set for procedure
     */
    static procedureExampleValueSet() {
        return SpecimenProcessingProcedureValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["procedure"]) {
            outcome.issue.push(...this.procedure.doModelValidation().issue);
        }
        if (this["additive"]) {
            this.additive.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
 */
export class SpecimenContainer extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenContainer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SpecimenContainer';
        /**
         * Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
         */
        this.identifier = [];
        this.__additiveIsChoice = true;
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['capacity']) {
            this.capacity = new fhir.Quantity(source.capacity);
        }
        if (source['specimenQuantity']) {
            this.specimenQuantity = new fhir.Quantity(source.specimenQuantity);
        }
        if (source['additive']) {
            this.additive = source.additive;
        }
        else if (source['additiveCodeableConcept']) {
            this.additive = new fhir.CodeableConcept(source.additiveCodeableConcept);
        }
        else if (source['additiveReference']) {
            this.additive = new fhir.Reference(source.additiveReference);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return SpecimenContainerTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["capacity"]) {
            outcome.issue.push(...this.capacity.doModelValidation().issue);
        }
        if (this["specimenQuantity"]) {
            outcome.issue.push(...this.specimenQuantity.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A sample to be used for analysis.
 */
export class Specimen extends fhir.DomainResource {
    /**
     * Default constructor for Specimen - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Specimen';
        /**
         * Id for specimen.
         */
        this.identifier = [];
        /**
         * The parent specimen could be the source from which the current specimen is derived by some processing step (e.g. an aliquot or isolate or extracted nucleic acids from clinical samples) or one of many specimens that were combined to create a pooled sample.
         */
        this.parent = [];
        /**
         * The request may be explicit or implied such with a ServiceRequest that requires a blood draw.
         */
        this.request = [];
        /**
         * Details concerning processing and processing steps for the specimen.
         */
        this.processing = [];
        /**
         * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
         */
        this.container = [];
        /**
         * Specimen condition is an observation made about the specimen.  It's a point-in-time assessment.  It can be used to assess its quality or appropriateness for a specific test.
         */
        this.condition = [];
        /**
         * To communicate any details or issues about the specimen or during the specimen collection. (for example: broken vial, sent with patient, frozen).
         */
        this.note = [];
        this.resourceType = 'Specimen';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['accessionIdentifier']) {
            this.accessionIdentifier = new fhir.Identifier(source.accessionIdentifier);
        }
        if (source['status']) {
            this.status = source.status;
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source['receivedTime']) {
            this.receivedTime = new fhir.FhirDateTime({ value: source.receivedTime });
        }
        if (source['parent']) {
            this.parent = source.parent.map((x) => new fhir.Reference(x));
        }
        if (source['request']) {
            this.request = source.request.map((x) => new fhir.Reference(x));
        }
        if (source['collection']) {
            this.collection = new fhir.SpecimenCollection(source.collection);
        }
        if (source['processing']) {
            this.processing = source.processing.map((x) => new fhir.SpecimenProcessing(x));
        }
        if (source['container']) {
            this.container = source.container.map((x) => new fhir.SpecimenContainer(x));
        }
        if (source['condition']) {
            this.condition = source.condition.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return SpecimenStatusValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return V20487ValueSet;
    }
    /**
     * Extensible-bound Value Set for condition
     */
    static conditionExtensibleValueSet() {
        return V20493ValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Specimen' fhir: Specimen.resourceType:'Specimen'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["accessionIdentifier"]) {
            outcome.issue.push(...this.accessionIdentifier.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["subject"]) {
            outcome.issue.push(...this.subject.doModelValidation().issue);
        }
        if (this["receivedTime"]) {
            outcome.issue.push(...this.receivedTime.doModelValidation().issue);
        }
        if (this["parent"]) {
            this.parent.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["request"]) {
            this.request.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["collection"]) {
            outcome.issue.push(...this.collection.doModelValidation().issue);
        }
        if (this["processing"]) {
            this.processing.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["container"]) {
            this.container.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["condition"]) {
            this.condition.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Specimen.js.map