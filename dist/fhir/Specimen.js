// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Details concerning the specimen collection.
 */
export class SpecimenCollection extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenCollection - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["bodySite"]) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source["collectedDateTime"]) {
            this.collectedDateTime = source.collectedDateTime;
        }
        if (source["_collectedDateTime"]) {
            this._collectedDateTime = new fhir.FhirElement(source._collectedDateTime);
        }
        if (source["collectedPeriod"]) {
            this.collectedPeriod = new fhir.Period(source.collectedPeriod);
        }
        if (source["collector"]) {
            this.collector = new fhir.Reference(source.collector);
        }
        if (source["duration"]) {
            this.duration = new fhir.Duration(source.duration);
        }
        if (source["fastingStatusCodeableConcept"]) {
            this.fastingStatusCodeableConcept = new fhir.CodeableConcept(source.fastingStatusCodeableConcept);
        }
        if (source["fastingStatusDuration"]) {
            this.fastingStatusDuration = new fhir.Duration(source.fastingStatusDuration);
        }
        if (source["method"]) {
            this.method = new fhir.CodeableConcept(source.method);
        }
        if (source["quantity"]) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
    }
    /**
     * Check if the current SpecimenCollection contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenCollection from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenCollection(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenCollection is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Details concerning processing and processing steps for the specimen.
 */
export class SpecimenProcessing extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenProcessing - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["additive"]) {
            this.additive = source.additive.map((x) => new fhir.Reference(x));
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["procedure"]) {
            this.procedure = new fhir.CodeableConcept(source.procedure);
        }
        if (source["timeDateTime"]) {
            this.timeDateTime = source.timeDateTime;
        }
        if (source["_timeDateTime"]) {
            this._timeDateTime = new fhir.FhirElement(source._timeDateTime);
        }
        if (source["timePeriod"]) {
            this.timePeriod = new fhir.Period(source.timePeriod);
        }
    }
    /**
     * Check if the current SpecimenProcessing contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenProcessing from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenProcessing(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenProcessing is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
 */
export class SpecimenContainer extends fhir.BackboneElement {
    /**
     * Default constructor for SpecimenContainer - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["additiveCodeableConcept"]) {
            this.additiveCodeableConcept = new fhir.CodeableConcept(source.additiveCodeableConcept);
        }
        if (source["additiveReference"]) {
            this.additiveReference = new fhir.Reference(source.additiveReference);
        }
        if (source["capacity"]) {
            this.capacity = new fhir.Quantity(source.capacity);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["specimenQuantity"]) {
            this.specimenQuantity = new fhir.Quantity(source.specimenQuantity);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current SpecimenContainer contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SpecimenContainer from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SpecimenContainer(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SpecimenContainer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A sample to be used for analysis.
 */
export class Specimen extends fhir.DomainResource {
    /**
     * Default constructor for Specimen - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Specimen';
        if (source["accessionIdentifier"]) {
            this.accessionIdentifier = new fhir.Identifier(source.accessionIdentifier);
        }
        if (source["collection"]) {
            this.collection = new fhir.SpecimenCollection(source.collection);
        }
        if (source["condition"]) {
            this.condition = source.condition.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["container"]) {
            this.container = source.container.map((x) => new fhir.SpecimenContainer(x));
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["note"]) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source["parent"]) {
            this.parent = source.parent.map((x) => new fhir.Reference(x));
        }
        if (source["processing"]) {
            this.processing = source.processing.map((x) => new fhir.SpecimenProcessing(x));
        }
        if (source["receivedTime"]) {
            this.receivedTime = source.receivedTime;
        }
        if (source["_receivedTime"]) {
            this._receivedTime = new fhir.FhirElement(source._receivedTime);
        }
        if (source["request"]) {
            this.request = source.request.map((x) => new fhir.Reference(x));
        }
        if (source["status"]) {
            this.status = source.status;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["subject"]) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current Specimen contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Specimen from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new Specimen(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `Specimen is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the Specimen.status field
 */
export var SpecimenStatusEnum;
(function (SpecimenStatusEnum) {
    SpecimenStatusEnum["AVAILABLE"] = "available";
    SpecimenStatusEnum["UNAVAILABLE"] = "unavailable";
    SpecimenStatusEnum["UNSATISFACTORY"] = "unsatisfactory";
    SpecimenStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
})(SpecimenStatusEnum || (SpecimenStatusEnum = {}));
//# sourceMappingURL=Specimen.js.map