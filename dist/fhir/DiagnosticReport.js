// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: DiagnosticReport
import * as fhir from '../fhir.js';
import { DiagnosticReportStatusValueSet, } from '../fhirValueSets/DiagnosticReportStatusValueSet.js';
import { DiagnosticServiceSectionsValueSet, } from '../fhirValueSets/DiagnosticServiceSectionsValueSet.js';
import { ReportCodesValueSet, } from '../fhirValueSets/ReportCodesValueSet.js';
import { ClinicalFindingsValueSet, } from '../fhirValueSets/ClinicalFindingsValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
 */
export class DiagnosticReportMedia extends fhir.BackboneElement {
    /**
     * Default constructor for DiagnosticReportMedia - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DiagnosticReportMedia';
        if (source['comment']) {
            this.comment = new fhir.FhirString({ value: source.comment });
        }
        if (source['link']) {
            this.link = new fhir.Reference(source.link);
        }
        else {
            this.link = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["comment"]) {
            outcome.issue.push(...this.comment.doModelValidation().issue);
        }
        if (!this['link']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property link:fhir.Reference fhir: DiagnosticReport.media.link:Reference", }));
        }
        if (this["link"]) {
            outcome.issue.push(...this.link.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
 */
export class DiagnosticReport extends fhir.DomainResource {
    /**
     * Default constructor for DiagnosticReport - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DiagnosticReport';
        /**
         * Usually assigned by the Information System of the diagnostic service provider (filler id).
         */
        this.identifier = [];
        /**
         * Note: Usually there is one test request for each result, however in some circumstances multiple test requests may be represented using a single test result resource. Note that there are also cases where one request leads to multiple reports.
         */
        this.basedOn = [];
        /**
         * Multiple categories are allowed using various categorization schemes.   The level of granularity is defined by the category concepts in the value set. More fine-grained filtering can be performed using the metadata and/or terminology hierarchy in DiagnosticReport.code.
         */
        this.category = [];
        this.__effectiveIsChoice = true;
        /**
         * This is not necessarily the source of the atomic data items or the entity that interpreted the results. It is the entity that takes responsibility for the clinical report.
         */
        this.performer = [];
        /**
         * Might not be the same entity that takes responsibility for the clinical report.
         */
        this.resultsInterpreter = [];
        /**
         * If the specimen is sufficiently specified with a code in the test result name, then this additional data may be redundant. If there are multiple specimens, these may be represented per observation or group.
         */
        this.specimen = [];
        /**
         * Observations can contain observations.
         */
        this.result = [];
        /**
         * ImagingStudy and the image element are somewhat overlapping - typically, the list of image references in the image element will also be found in one of the imaging study resources. However, each caters to different types of displays for different types of purposes. Neither, either, or both may be provided.
         */
        this.imagingStudy = [];
        /**
         * A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
         */
        this.media = [];
        /**
         * One or more codes that represent the summary conclusion (interpretation/impression) of the diagnostic report.
         */
        this.conclusionCode = [];
        /**
         * "application/pdf" is recommended as the most reliable and interoperable in this context.
         */
        this.presentedForm = [];
        this.resourceType = 'DiagnosticReport';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['basedOn']) {
            this.basedOn = source.basedOn.map((x) => new fhir.Reference(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['category']) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['effective']) {
            this.effective = source.effective;
        }
        else if (source['effectiveDateTime']) {
            this.effective = new fhir.FhirDateTime({ value: source.effectiveDateTime });
        }
        else if (source['effectivePeriod']) {
            this.effective = new fhir.Period(source.effectivePeriod);
        }
        if (source['issued']) {
            this.issued = new fhir.FhirInstant({ value: source.issued });
        }
        if (source['performer']) {
            this.performer = source.performer.map((x) => new fhir.Reference(x));
        }
        if (source['resultsInterpreter']) {
            this.resultsInterpreter = source.resultsInterpreter.map((x) => new fhir.Reference(x));
        }
        if (source['specimen']) {
            this.specimen = source.specimen.map((x) => new fhir.Reference(x));
        }
        if (source['result']) {
            this.result = source.result.map((x) => new fhir.Reference(x));
        }
        if (source['imagingStudy']) {
            this.imagingStudy = source.imagingStudy.map((x) => new fhir.Reference(x));
        }
        if (source['media']) {
            this.media = source.media.map((x) => new fhir.DiagnosticReportMedia(x));
        }
        if (source['conclusion']) {
            this.conclusion = new fhir.FhirString({ value: source.conclusion });
        }
        if (source['conclusionCode']) {
            this.conclusionCode = source.conclusionCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['presentedForm']) {
            this.presentedForm = source.presentedForm.map((x) => new fhir.Attachment(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return DiagnosticReportStatusValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return DiagnosticServiceSectionsValueSet;
    }
    /**
     * Preferred-bound Value Set for code
     */
    static codePreferredValueSet() {
        return ReportCodesValueSet;
    }
    /**
     * Example-bound Value Set for conclusionCode
     */
    static conclusionCodeExampleValueSet() {
        return ClinicalFindingsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'DiagnosticReport' fhir: DiagnosticReport.resourceType:'DiagnosticReport'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["basedOn"]) {
            this.basedOn.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:DiagnosticReportStatusValueSetEnum fhir: DiagnosticReport.status:code", }));
        }
        if (this["category"]) {
            this.category.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.CodeableConcept fhir: DiagnosticReport.code:CodeableConcept", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["subject"]) {
            outcome.issue.push(...this.subject.doModelValidation().issue);
        }
        if (this["encounter"]) {
            outcome.issue.push(...this.encounter.doModelValidation().issue);
        }
        if (this["issued"]) {
            outcome.issue.push(...this.issued.doModelValidation().issue);
        }
        if (this["performer"]) {
            this.performer.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["resultsInterpreter"]) {
            this.resultsInterpreter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["specimen"]) {
            this.specimen.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["result"]) {
            this.result.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["imagingStudy"]) {
            this.imagingStudy.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["media"]) {
            this.media.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["conclusion"]) {
            outcome.issue.push(...this.conclusion.doModelValidation().issue);
        }
        if (this["conclusionCode"]) {
            this.conclusionCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["presentedForm"]) {
            this.presentedForm.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=DiagnosticReport.js.map