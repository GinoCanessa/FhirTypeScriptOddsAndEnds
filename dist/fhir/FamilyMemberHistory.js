// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: FamilyMemberHistory
import * as fhir from '../fhir.js';
import { ConditionCodeValueSet, } from '../fhirValueSets/ConditionCodeValueSet.js';
import { ConditionOutcomeValueSet, } from '../fhirValueSets/ConditionOutcomeValueSet.js';
import { HistoryStatusValueSet, } from '../fhirValueSets/HistoryStatusValueSet.js';
import { HistoryAbsentReasonValueSet, } from '../fhirValueSets/HistoryAbsentReasonValueSet.js';
import { V3FamilyMemberValueSet, } from '../fhirValueSets/V3FamilyMemberValueSet.js';
import { AdministrativeGenderValueSet, } from '../fhirValueSets/AdministrativeGenderValueSet.js';
import { ClinicalFindingsValueSet, } from '../fhirValueSets/ClinicalFindingsValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
 */
export class FamilyMemberHistoryCondition extends fhir.BackboneElement {
    /**
     * Default constructor for FamilyMemberHistoryCondition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'FamilyMemberHistoryCondition';
        this.__onsetIsChoice = true;
        /**
         * An area where general notes can be placed about this specific condition.
         */
        this.note = [];
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        else {
            this.code = null;
        }
        if (source['outcome']) {
            this.outcome = new fhir.CodeableConcept(source.outcome);
        }
        if (source['contributedToDeath']) {
            this.contributedToDeath = new fhir.FhirBoolean({ value: source.contributedToDeath });
        }
        if (source['onset']) {
            this.onset = source.onset;
        }
        else if (source['onsetAge']) {
            this.onset = new fhir.Age(source.onsetAge);
        }
        else if (source['onsetRange']) {
            this.onset = new fhir.Range(source.onsetRange);
        }
        else if (source['onsetPeriod']) {
            this.onset = new fhir.Period(source.onsetPeriod);
        }
        else if (source['onsetString']) {
            this.onset = new fhir.FhirString({ value: source.onsetString });
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ConditionCodeValueSet;
    }
    /**
     * Example-bound Value Set for outcome
     */
    static outcomeExampleValueSet() {
        return ConditionOutcomeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.CodeableConcept fhir: FamilyMemberHistory.condition.code:CodeableConcept", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["outcome"]) {
            outcome.issue.push(...this.outcome.doModelValidation().issue);
        }
        if (this["contributedToDeath"]) {
            outcome.issue.push(...this.contributedToDeath.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Significant health conditions for a person related to the patient relevant in the context of care for the patient.
 */
export class FamilyMemberHistory extends fhir.DomainResource {
    /**
     * Default constructor for FamilyMemberHistory - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'FamilyMemberHistory';
        /**
         * This is a business identifier, not a resource identifier (see [discussion](resource.html#identifiers)).  It is best practice for the identifier to only appear on a single resource instance, however business practices may occasionally dictate that multiple resource instances with the same identifier can exist - possibly even with different resource types.  For example, multiple Patient and a Person resource instance might share the same social insurance number.
         */
        this.identifier = [];
        /**
         * The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this FamilyMemberHistory.
         */
        this.instantiatesCanonical = [];
        /**
         * This might be an HTML page, PDF, etc. or could just be a non-resolvable URI identifier.
         */
        this.instantiatesUri = [];
        this.__bornIsChoice = true;
        this.__ageIsChoice = true;
        this.__deceasedIsChoice = true;
        /**
         * Textual reasons can be captured using reasonCode.text.
         */
        this.reasonCode = [];
        /**
         * Indicates a Condition, Observation, AllergyIntolerance, or QuestionnaireResponse that justifies this family member history event.
         */
        this.reasonReference = [];
        /**
         * This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
         */
        this.note = [];
        /**
         * The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
         */
        this.condition = [];
        this.resourceType = 'FamilyMemberHistory';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['instantiatesCanonical']) {
            this.instantiatesCanonical = source.instantiatesCanonical.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['instantiatesUri']) {
            this.instantiatesUri = source.instantiatesUri.map((x) => new fhir.FhirUri({ value: x }));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['dataAbsentReason']) {
            this.dataAbsentReason = new fhir.CodeableConcept(source.dataAbsentReason);
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        else {
            this.patient = null;
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['relationship']) {
            this.relationship = new fhir.CodeableConcept(source.relationship);
        }
        else {
            this.relationship = null;
        }
        if (source['sex']) {
            this.sex = new fhir.CodeableConcept(source.sex);
        }
        if (source['born']) {
            this.born = source.born;
        }
        else if (source['bornPeriod']) {
            this.born = new fhir.Period(source.bornPeriod);
        }
        else if (source['bornDate']) {
            this.born = new fhir.FhirDate({ value: source.bornDate });
        }
        else if (source['bornString']) {
            this.born = new fhir.FhirString({ value: source.bornString });
        }
        if (source['age']) {
            this.age = source.age;
        }
        else if (source['ageAge']) {
            this.age = new fhir.Age(source.ageAge);
        }
        else if (source['ageRange']) {
            this.age = new fhir.Range(source.ageRange);
        }
        else if (source['ageString']) {
            this.age = new fhir.FhirString({ value: source.ageString });
        }
        if (source['estimatedAge']) {
            this.estimatedAge = new fhir.FhirBoolean({ value: source.estimatedAge });
        }
        if (source['deceased']) {
            this.deceased = source.deceased;
        }
        else if (source['deceasedBoolean']) {
            this.deceased = new fhir.FhirBoolean({ value: source.deceasedBoolean });
        }
        else if (source['deceasedAge']) {
            this.deceased = new fhir.Age(source.deceasedAge);
        }
        else if (source['deceasedRange']) {
            this.deceased = new fhir.Range(source.deceasedRange);
        }
        else if (source['deceasedDate']) {
            this.deceased = new fhir.FhirDate({ value: source.deceasedDate });
        }
        else if (source['deceasedString']) {
            this.deceased = new fhir.FhirString({ value: source.deceasedString });
        }
        if (source['reasonCode']) {
            this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['reasonReference']) {
            this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x));
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source['condition']) {
            this.condition = source.condition.map((x) => new fhir.FamilyMemberHistoryCondition(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return HistoryStatusValueSet;
    }
    /**
     * Example-bound Value Set for dataAbsentReason
     */
    static dataAbsentReasonExampleValueSet() {
        return HistoryAbsentReasonValueSet;
    }
    /**
     * Example-bound Value Set for relationship
     */
    static relationshipExampleValueSet() {
        return V3FamilyMemberValueSet;
    }
    /**
     * Extensible-bound Value Set for sex
     */
    static sexExtensibleValueSet() {
        return AdministrativeGenderValueSet;
    }
    /**
     * Example-bound Value Set for reasonCode
     */
    static reasonCodeExampleValueSet() {
        return ClinicalFindingsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'FamilyMemberHistory' fhir: FamilyMemberHistory.resourceType:'FamilyMemberHistory'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["instantiatesCanonical"]) {
            this.instantiatesCanonical.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["instantiatesUri"]) {
            this.instantiatesUri.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:HistoryStatusValueSetEnum fhir: FamilyMemberHistory.status:code", }));
        }
        if (this["dataAbsentReason"]) {
            outcome.issue.push(...this.dataAbsentReason.doModelValidation().issue);
        }
        if (!this['patient']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property patient:fhir.Reference fhir: FamilyMemberHistory.patient:Reference", }));
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['relationship']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property relationship:fhir.CodeableConcept fhir: FamilyMemberHistory.relationship:CodeableConcept", }));
        }
        if (this["relationship"]) {
            outcome.issue.push(...this.relationship.doModelValidation().issue);
        }
        if (this["sex"]) {
            outcome.issue.push(...this.sex.doModelValidation().issue);
        }
        if (this["estimatedAge"]) {
            outcome.issue.push(...this.estimatedAge.doModelValidation().issue);
        }
        if (this["reasonCode"]) {
            this.reasonCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["reasonReference"]) {
            this.reasonReference.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["condition"]) {
            this.condition.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=FamilyMemberHistory.js.map