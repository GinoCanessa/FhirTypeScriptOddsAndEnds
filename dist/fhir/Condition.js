// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Clinical stage or grade of a condition. May include formal severity assessments.
 */
export class ConditionStage extends fhir.BackboneElement {
    /**
     * Default constructor for ConditionStage - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["assessment"]) {
            this.assessment = source.assessment.map((x) => new fhir.Reference(x));
        }
        if (source["summary"]) {
            this.summary = new fhir.CodeableConcept(source.summary);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current ConditionStage contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConditionStage from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ConditionStage(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConditionStage is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The evidence may be a simple list of coded symptoms/manifestations, or references to observations or formal assessments, or both.
 */
export class ConditionEvidence extends fhir.BackboneElement {
    /**
     * Default constructor for ConditionEvidence - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["detail"]) {
            this.detail = source.detail.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Check if the current ConditionEvidence contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a ConditionEvidence from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new ConditionEvidence(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ConditionEvidence is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
 */
export class Condition extends fhir.DomainResource {
    /**
     * Default constructor for Condition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'Condition';
        if (source["abatementDateTime"]) {
            this.abatementDateTime = source.abatementDateTime;
        }
        if (source["_abatementDateTime"]) {
            this._abatementDateTime = new fhir.FhirElement(source._abatementDateTime);
        }
        if (source["abatementAge"]) {
            this.abatementAge = new fhir.Age(source.abatementAge);
        }
        if (source["abatementPeriod"]) {
            this.abatementPeriod = new fhir.Period(source.abatementPeriod);
        }
        if (source["abatementRange"]) {
            this.abatementRange = new fhir.Range(source.abatementRange);
        }
        if (source["abatementString"]) {
            this.abatementString = source.abatementString;
        }
        if (source["_abatementString"]) {
            this._abatementString = new fhir.FhirElement(source._abatementString);
        }
        if (source["asserter"]) {
            this.asserter = new fhir.Reference(source.asserter);
        }
        if (source["bodySite"]) {
            this.bodySite = source.bodySite.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["category"]) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["clinicalStatus"]) {
            this.clinicalStatus = new fhir.CodeableConcept(source.clinicalStatus);
        }
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source["encounter"]) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source["evidence"]) {
            this.evidence = source.evidence.map((x) => new fhir.ConditionEvidence(x));
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["note"]) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source["onsetDateTime"]) {
            this.onsetDateTime = source.onsetDateTime;
        }
        if (source["_onsetDateTime"]) {
            this._onsetDateTime = new fhir.FhirElement(source._onsetDateTime);
        }
        if (source["onsetAge"]) {
            this.onsetAge = new fhir.Age(source.onsetAge);
        }
        if (source["onsetPeriod"]) {
            this.onsetPeriod = new fhir.Period(source.onsetPeriod);
        }
        if (source["onsetRange"]) {
            this.onsetRange = new fhir.Range(source.onsetRange);
        }
        if (source["onsetString"]) {
            this.onsetString = source.onsetString;
        }
        if (source["_onsetString"]) {
            this._onsetString = new fhir.FhirElement(source._onsetString);
        }
        if (source["recordedDate"]) {
            this.recordedDate = source.recordedDate;
        }
        if (source["_recordedDate"]) {
            this._recordedDate = new fhir.FhirElement(source._recordedDate);
        }
        if (source["recorder"]) {
            this.recorder = new fhir.Reference(source.recorder);
        }
        if (source["severity"]) {
            this.severity = new fhir.CodeableConcept(source.severity);
        }
        if (source["stage"]) {
            this.stage = source.stage.map((x) => new fhir.ConditionStage(x));
        }
        this.subject = null;
        if (source["subject"]) {
            this.subject = new fhir.Reference(source.subject);
        }
        if (this.subject === undefined) {
            this.subject = null;
        }
        if (source["verificationStatus"]) {
            this.verificationStatus = new fhir.CodeableConcept(source.verificationStatus);
        }
    }
    /**
     * Check if the current Condition contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["subject"] === undefined) {
            missingElements.push("subject");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a Condition from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new Condition(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `Condition is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
//# sourceMappingURL=Condition.js.map