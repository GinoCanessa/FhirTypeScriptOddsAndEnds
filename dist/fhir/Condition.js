// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Condition
import * as fhir from '../fhir.js';
import { ConditionStageValueSet, } from '../fhirValueSets/ConditionStageValueSet.js';
import { ConditionStageTypeValueSet, } from '../fhirValueSets/ConditionStageTypeValueSet.js';
import { ManifestationOrSymptomValueSet, } from '../fhirValueSets/ManifestationOrSymptomValueSet.js';
import { ConditionClinicalValueSet, } from '../fhirValueSets/ConditionClinicalValueSet.js';
import { ConditionVerStatusValueSet, } from '../fhirValueSets/ConditionVerStatusValueSet.js';
import { ConditionCategoryValueSet, } from '../fhirValueSets/ConditionCategoryValueSet.js';
import { ConditionSeverityValueSet, } from '../fhirValueSets/ConditionSeverityValueSet.js';
import { ConditionCodeValueSet, } from '../fhirValueSets/ConditionCodeValueSet.js';
import { BodySiteValueSet, } from '../fhirValueSets/BodySiteValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Clinical stage or grade of a condition. May include formal severity assessments.
 */
export class ConditionStage extends fhir.BackboneElement {
    /**
     * Default constructor for ConditionStage - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConditionStage';
        /**
         * Reference to a formal record of the evidence on which the staging assessment is based.
         */
        this.assessment = [];
        if (source['summary']) {
            this.summary = new fhir.CodeableConcept(source.summary);
        }
        if (source['assessment']) {
            this.assessment = source.assessment.map((x) => new fhir.Reference(x));
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Example-bound Value Set for summary
     */
    static summaryExampleValueSet() {
        return ConditionStageValueSet;
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return ConditionStageTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["summary"]) {
            outcome.issue.push(...this.summary.doModelValidation().issue);
        }
        if (this["assessment"]) {
            this.assessment.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The evidence may be a simple list of coded symptoms/manifestations, or references to observations or formal assessments, or both.
 */
export class ConditionEvidence extends fhir.BackboneElement {
    /**
     * Default constructor for ConditionEvidence - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ConditionEvidence';
        /**
         * A manifestation or symptom that led to the recording of this condition.
         */
        this.code = [];
        /**
         * Links to other relevant information, including pathology reports.
         */
        this.detail = [];
        if (source['code']) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ManifestationOrSymptomValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["code"]) {
            this.code.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
 */
export class Condition extends fhir.DomainResource {
    /**
     * Default constructor for Condition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Condition';
        /**
         * This is a business identifier, not a resource identifier (see [discussion](resource.html#identifiers)).  It is best practice for the identifier to only appear on a single resource instance, however business practices may occasionally dictate that multiple resource instances with the same identifier can exist - possibly even with different resource types.  For example, multiple Patient and a Person resource instance might share the same social insurance number.
         */
        this.identifier = [];
        /**
         * The categorization is often highly contextual and may appear poorly differentiated or not very useful in other contexts.
         */
        this.category = [];
        /**
         * Only used if not implicit in code found in Condition.code. If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [bodySite](extension-bodysite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
         */
        this.bodySite = [];
        this.__onsetIsChoice = true;
        this.__abatementIsChoice = true;
        /**
         * Clinical stage or grade of a condition. May include formal severity assessments.
         */
        this.stage = [];
        /**
         * The evidence may be a simple list of coded symptoms/manifestations, or references to observations or formal assessments, or both.
         */
        this.evidence = [];
        /**
         * Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
         */
        this.note = [];
        this.resourceType = 'Condition';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['clinicalStatus']) {
            this.clinicalStatus = new fhir.CodeableConcept(source.clinicalStatus);
        }
        if (source['verificationStatus']) {
            this.verificationStatus = new fhir.CodeableConcept(source.verificationStatus);
        }
        if (source['category']) {
            this.category = source.category.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['severity']) {
            this.severity = new fhir.CodeableConcept(source.severity);
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['bodySite']) {
            this.bodySite = source.bodySite.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['subject']) {
            this.subject = new fhir.Reference(source.subject);
        }
        else {
            this.subject = null;
        }
        if (source['encounter']) {
            this.encounter = new fhir.Reference(source.encounter);
        }
        if (source['onset']) {
            this.onset = source.onset;
        }
        else if (source['onsetDateTime']) {
            this.onset = new fhir.FhirDateTime({ value: source.onsetDateTime });
        }
        else if (source['onsetAge']) {
            this.onset = new fhir.Age(source.onsetAge);
        }
        else if (source['onsetPeriod']) {
            this.onset = new fhir.Period(source.onsetPeriod);
        }
        else if (source['onsetRange']) {
            this.onset = new fhir.Range(source.onsetRange);
        }
        else if (source['onsetString']) {
            this.onset = new fhir.FhirString({ value: source.onsetString });
        }
        if (source['abatement']) {
            this.abatement = source.abatement;
        }
        else if (source['abatementDateTime']) {
            this.abatement = new fhir.FhirDateTime({ value: source.abatementDateTime });
        }
        else if (source['abatementAge']) {
            this.abatement = new fhir.Age(source.abatementAge);
        }
        else if (source['abatementPeriod']) {
            this.abatement = new fhir.Period(source.abatementPeriod);
        }
        else if (source['abatementRange']) {
            this.abatement = new fhir.Range(source.abatementRange);
        }
        else if (source['abatementString']) {
            this.abatement = new fhir.FhirString({ value: source.abatementString });
        }
        if (source['recordedDate']) {
            this.recordedDate = new fhir.FhirDateTime({ value: source.recordedDate });
        }
        if (source['recorder']) {
            this.recorder = new fhir.Reference(source.recorder);
        }
        if (source['asserter']) {
            this.asserter = new fhir.Reference(source.asserter);
        }
        if (source['stage']) {
            this.stage = source.stage.map((x) => new fhir.ConditionStage(x));
        }
        if (source['evidence']) {
            this.evidence = source.evidence.map((x) => new fhir.ConditionEvidence(x));
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
    }
    /**
     * Required-bound Value Set for clinicalStatus
     */
    static clinicalStatusRequiredValueSet() {
        return ConditionClinicalValueSet;
    }
    /**
     * Required-bound Value Set for verificationStatus
     */
    static verificationStatusRequiredValueSet() {
        return ConditionVerStatusValueSet;
    }
    /**
     * Extensible-bound Value Set for category
     */
    static categoryExtensibleValueSet() {
        return ConditionCategoryValueSet;
    }
    /**
     * Preferred-bound Value Set for severity
     */
    static severityPreferredValueSet() {
        return ConditionSeverityValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ConditionCodeValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return BodySiteValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Condition' fhir: Condition.resourceType:'Condition'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["clinicalStatus"]) {
            outcome.issue.push(...this.clinicalStatus.doModelValidation().issue);
        }
        if (this["verificationStatus"]) {
            outcome.issue.push(...this.verificationStatus.doModelValidation().issue);
        }
        if (this["category"]) {
            this.category.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["severity"]) {
            outcome.issue.push(...this.severity.doModelValidation().issue);
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["bodySite"]) {
            this.bodySite.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['subject']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property subject:fhir.Reference fhir: Condition.subject:Reference", }));
        }
        if (this["subject"]) {
            outcome.issue.push(...this.subject.doModelValidation().issue);
        }
        if (this["encounter"]) {
            outcome.issue.push(...this.encounter.doModelValidation().issue);
        }
        if (this["recordedDate"]) {
            outcome.issue.push(...this.recordedDate.doModelValidation().issue);
        }
        if (this["recorder"]) {
            outcome.issue.push(...this.recorder.doModelValidation().issue);
        }
        if (this["asserter"]) {
            outcome.issue.push(...this.asserter.doModelValidation().issue);
        }
        if (this["stage"]) {
            this.stage.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["evidence"]) {
            this.evidence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Condition.js.map