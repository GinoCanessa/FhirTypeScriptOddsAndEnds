// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * The populations that make up the population group, one for each type of population appropriate for the measure.
 */
export class MeasureReportGroupPopulation extends fhir.BackboneElement {
    /**
     * Default constructor for MeasureReportGroupPopulation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source["count"]) {
            this.count = source.count;
        }
        if (source["_count"]) {
            this._count = new fhir.FhirElement(source._count);
        }
        if (source["subjectResults"]) {
            this.subjectResults = new fhir.Reference(source.subjectResults);
        }
    }
    /**
     * Check if the current MeasureReportGroupPopulation contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReportGroupPopulation from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReportGroupPopulation(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReportGroupPopulation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A stratifier component value.
 */
export class MeasureReportGroupStratifierStratumComponent extends fhir.BackboneElement {
    /**
     * Default constructor for MeasureReportGroupStratifierStratumComponent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.code = null;
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (this.code === undefined) {
            this.code = null;
        }
        this.value = null;
        if (source["value"]) {
            this.value = new fhir.CodeableConcept(source.value);
        }
        if (this.value === undefined) {
            this.value = null;
        }
    }
    /**
     * Check if the current MeasureReportGroupStratifierStratumComponent contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        if (this["value"] === undefined) {
            missingElements.push("value");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReportGroupStratifierStratumComponent from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReportGroupStratifierStratumComponent(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReportGroupStratifierStratumComponent is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The populations that make up the stratum, one for each type of population appropriate to the measure.
 */
export class MeasureReportGroupStratifierStratumPopulation extends fhir.BackboneElement {
    /**
     * Default constructor for MeasureReportGroupStratifierStratumPopulation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source["count"]) {
            this.count = source.count;
        }
        if (source["_count"]) {
            this._count = new fhir.FhirElement(source._count);
        }
        if (source["subjectResults"]) {
            this.subjectResults = new fhir.Reference(source.subjectResults);
        }
    }
    /**
     * Check if the current MeasureReportGroupStratifierStratumPopulation contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReportGroupStratifierStratumPopulation from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReportGroupStratifierStratumPopulation(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReportGroupStratifierStratumPopulation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
 */
export class MeasureReportGroupStratifierStratum extends fhir.BackboneElement {
    /**
     * Default constructor for MeasureReportGroupStratifierStratum - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["component"]) {
            this.component = source.component.map((x) => new fhir.MeasureReportGroupStratifierStratumComponent(x));
        }
        if (source["measureScore"]) {
            this.measureScore = new fhir.Quantity(source.measureScore);
        }
        if (source["population"]) {
            this.population = source.population.map((x) => new fhir.MeasureReportGroupStratifierStratumPopulation(x));
        }
        if (source["value"]) {
            this.value = new fhir.CodeableConcept(source.value);
        }
    }
    /**
     * Check if the current MeasureReportGroupStratifierStratum contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReportGroupStratifierStratum from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReportGroupStratifierStratum(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReportGroupStratifierStratum is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
 */
export class MeasureReportGroupStratifier extends fhir.BackboneElement {
    /**
     * Default constructor for MeasureReportGroupStratifier - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = source.code.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["stratum"]) {
            this.stratum = source.stratum.map((x) => new fhir.MeasureReportGroupStratifierStratum(x));
        }
    }
    /**
     * Check if the current MeasureReportGroupStratifier contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReportGroupStratifier from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReportGroupStratifier(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReportGroupStratifier is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The results of the calculation, one for each population group in the measure.
 */
export class MeasureReportGroup extends fhir.BackboneElement {
    /**
     * Default constructor for MeasureReportGroup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["code"]) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source["measureScore"]) {
            this.measureScore = new fhir.Quantity(source.measureScore);
        }
        if (source["population"]) {
            this.population = source.population.map((x) => new fhir.MeasureReportGroupPopulation(x));
        }
        if (source["stratifier"]) {
            this.stratifier = source.stratifier.map((x) => new fhir.MeasureReportGroupStratifier(x));
        }
    }
    /**
     * Check if the current MeasureReportGroup contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReportGroup from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReportGroup(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReportGroup is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.
 */
export class MeasureReport extends fhir.DomainResource {
    /**
     * Default constructor for MeasureReport - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'MeasureReport';
        if (source["date"]) {
            this.date = source.date;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["evaluatedResource"]) {
            this.evaluatedResource = source.evaluatedResource.map((x) => new fhir.Reference(x));
        }
        if (source["group"]) {
            this.group = source.group.map((x) => new fhir.MeasureReportGroup(x));
        }
        if (source["identifier"]) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source["improvementNotation"]) {
            this.improvementNotation = new fhir.CodeableConcept(source.improvementNotation);
        }
        this.measure = null;
        if (source["measure"]) {
            this.measure = source.measure;
        }
        if (this.measure === undefined) {
            this.measure = null;
        }
        if (source["_measure"]) {
            this._measure = new fhir.FhirElement(source._measure);
        }
        this.period = null;
        if (source["period"]) {
            this.period = new fhir.Period(source.period);
        }
        if (this.period === undefined) {
            this.period = null;
        }
        if (source["reporter"]) {
            this.reporter = new fhir.Reference(source.reporter);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["subject"]) {
            this.subject = new fhir.Reference(source.subject);
        }
        this.type = null;
        if (source["type"]) {
            this.type = source.type;
        }
        if (this.type === undefined) {
            this.type = null;
        }
        if (source["_type"]) {
            this._type = new fhir.FhirElement(source._type);
        }
    }
    /**
     * Check if the current MeasureReport contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["measure"] === undefined) {
            missingElements.push("measure");
        }
        if (this["period"] === undefined) {
            missingElements.push("period");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a MeasureReport from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new MeasureReport(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `MeasureReport is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the MeasureReport.status field
 */
export var MeasureReportStatusEnum;
(function (MeasureReportStatusEnum) {
    MeasureReportStatusEnum["COMPLETE"] = "complete";
    MeasureReportStatusEnum["PENDING"] = "pending";
    MeasureReportStatusEnum["ERROR"] = "error";
})(MeasureReportStatusEnum || (MeasureReportStatusEnum = {}));
/**
 * Code Values for the MeasureReport.type field
 */
export var MeasureReportTypeEnum;
(function (MeasureReportTypeEnum) {
    MeasureReportTypeEnum["INDIVIDUAL"] = "individual";
    MeasureReportTypeEnum["SUBJECT_LIST"] = "subject-list";
    MeasureReportTypeEnum["SUMMARY"] = "summary";
    MeasureReportTypeEnum["DATA_COLLECTION"] = "data-collection";
})(MeasureReportTypeEnum || (MeasureReportTypeEnum = {}));
//# sourceMappingURL=MeasureReport.js.map