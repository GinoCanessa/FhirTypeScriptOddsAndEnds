// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Claim
import * as fhir from '../fhir.js';
import { RelatedClaimRelationshipValueSet, } from '../fhirValueSets/RelatedClaimRelationshipValueSet.js';
import { PayeetypeValueSet, } from '../fhirValueSets/PayeetypeValueSet.js';
import { ClaimCareteamroleValueSet, } from '../fhirValueSets/ClaimCareteamroleValueSet.js';
import { ProviderQualificationValueSet, } from '../fhirValueSets/ProviderQualificationValueSet.js';
import { ClaimInformationcategoryValueSet, } from '../fhirValueSets/ClaimInformationcategoryValueSet.js';
import { ClaimExceptionValueSet, } from '../fhirValueSets/ClaimExceptionValueSet.js';
import { MissingToothReasonValueSet, } from '../fhirValueSets/MissingToothReasonValueSet.js';
import { ExDiagnosistypeValueSet, } from '../fhirValueSets/ExDiagnosistypeValueSet.js';
import { ExDiagnosisOnAdmissionValueSet, } from '../fhirValueSets/ExDiagnosisOnAdmissionValueSet.js';
import { ExDiagnosisrelatedgroupValueSet, } from '../fhirValueSets/ExDiagnosisrelatedgroupValueSet.js';
import { ExProcedureTypeValueSet, } from '../fhirValueSets/ExProcedureTypeValueSet.js';
import { V3ActIncidentCodeValueSet, } from '../fhirValueSets/V3ActIncidentCodeValueSet.js';
import { ExRevenueCenterValueSet, } from '../fhirValueSets/ExRevenueCenterValueSet.js';
import { ExBenefitcategoryValueSet, } from '../fhirValueSets/ExBenefitcategoryValueSet.js';
import { ServiceUsclsValueSet, } from '../fhirValueSets/ServiceUsclsValueSet.js';
import { ClaimModifiersValueSet, } from '../fhirValueSets/ClaimModifiersValueSet.js';
import { ExProgramCodeValueSet, } from '../fhirValueSets/ExProgramCodeValueSet.js';
import { ToothValueSet, } from '../fhirValueSets/ToothValueSet.js';
import { SurfaceValueSet, } from '../fhirValueSets/SurfaceValueSet.js';
import { FmStatusValueSet, } from '../fhirValueSets/FmStatusValueSet.js';
import { ClaimTypeValueSet, } from '../fhirValueSets/ClaimTypeValueSet.js';
import { ClaimSubtypeValueSet, } from '../fhirValueSets/ClaimSubtypeValueSet.js';
import { ClaimUseValueSet, } from '../fhirValueSets/ClaimUseValueSet.js';
import { ProcessPriorityValueSet, } from '../fhirValueSets/ProcessPriorityValueSet.js';
import { FundsreserveValueSet, } from '../fhirValueSets/FundsreserveValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * For example,  for the original treatment and follow-up exams.
 */
export class ClaimRelated extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimRelated - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimRelated';
        if (source['claim']) {
            this.claim = new fhir.Reference(source.claim);
        }
        if (source['relationship']) {
            this.relationship = new fhir.CodeableConcept(source.relationship);
        }
        if (source['reference']) {
            this.reference = new fhir.Identifier(source.reference);
        }
    }
    /**
     * Example-bound Value Set for relationship
     */
    static relationshipExampleValueSet() {
        return RelatedClaimRelationshipValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["claim"]) {
            outcome.issue.push(...this.claim.doModelValidation().issue);
        }
        if (this["relationship"]) {
            outcome.issue.push(...this.relationship.doModelValidation().issue);
        }
        if (this["reference"]) {
            outcome.issue.push(...this.reference.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Often providers agree to receive the benefits payable to reduce the near-term costs to the patient. The insurer may decline to pay the provider and choose to pay the subscriber instead.
 */
export class ClaimPayee extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimPayee - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimPayee';
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['party']) {
            this.party = new fhir.Reference(source.party);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return PayeetypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: Claim.payee.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["party"]) {
            outcome.issue.push(...this.party.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The members of the team who provided the products and services.
 */
export class ClaimCareTeam extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimCareTeam - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimCareTeam';
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['provider']) {
            this.provider = new fhir.Reference(source.provider);
        }
        else {
            this.provider = null;
        }
        if (source['responsible']) {
            this.responsible = new fhir.FhirBoolean({ value: source.responsible });
        }
        if (source['role']) {
            this.role = new fhir.CodeableConcept(source.role);
        }
        if (source['qualification']) {
            this.qualification = new fhir.CodeableConcept(source.qualification);
        }
    }
    /**
     * Example-bound Value Set for role
     */
    static roleExampleValueSet() {
        return ClaimCareteamroleValueSet;
    }
    /**
     * Example-bound Value Set for qualification
     */
    static qualificationExampleValueSet() {
        return ProviderQualificationValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.careTeam.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['provider']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property provider:fhir.Reference fhir: Claim.careTeam.provider:Reference", }));
        }
        if (this["provider"]) {
            outcome.issue.push(...this.provider.doModelValidation().issue);
        }
        if (this["responsible"]) {
            outcome.issue.push(...this.responsible.doModelValidation().issue);
        }
        if (this["role"]) {
            outcome.issue.push(...this.role.doModelValidation().issue);
        }
        if (this["qualification"]) {
            outcome.issue.push(...this.qualification.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Often there are multiple jurisdiction specific valuesets which are required.
 */
export class ClaimSupportingInfo extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimSupportingInfo - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimSupportingInfo';
        this.__timingIsChoice = true;
        this.__valueIsChoice = true;
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        else {
            this.category = null;
        }
        if (source['code']) {
            this.code = new fhir.CodeableConcept(source.code);
        }
        if (source['timing']) {
            this.timing = source.timing;
        }
        else if (source['timingDate']) {
            this.timing = new fhir.FhirDate({ value: source.timingDate });
        }
        else if (source['timingPeriod']) {
            this.timing = new fhir.Period(source.timingPeriod);
        }
        if (source['value']) {
            this.value = source.value;
        }
        else if (source['valueBoolean']) {
            this.value = new fhir.FhirBoolean({ value: source.valueBoolean });
        }
        else if (source['valueString']) {
            this.value = new fhir.FhirString({ value: source.valueString });
        }
        else if (source['valueQuantity']) {
            this.value = new fhir.Quantity(source.valueQuantity);
        }
        else if (source['valueAttachment']) {
            this.value = new fhir.Attachment(source.valueAttachment);
        }
        else if (source['valueReference']) {
            this.value = new fhir.Reference(source.valueReference);
        }
        if (source['reason']) {
            this.reason = new fhir.CodeableConcept(source.reason);
        }
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ClaimInformationcategoryValueSet;
    }
    /**
     * Example-bound Value Set for code
     */
    static codeExampleValueSet() {
        return ClaimExceptionValueSet;
    }
    /**
     * Example-bound Value Set for reason
     */
    static reasonExampleValueSet() {
        return MissingToothReasonValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.supportingInfo.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['category']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property category:fhir.CodeableConcept fhir: Claim.supportingInfo.category:CodeableConcept", }));
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (this["reason"]) {
            outcome.issue.push(...this.reason.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Information about diagnoses relevant to the claim items.
 */
export class ClaimDiagnosis extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimDiagnosis - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimDiagnosis';
        this.__diagnosisIsChoice = true;
        /**
         * For example: admitting, primary, secondary, discharge.
         */
        this.type = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['diagnosis']) {
            this.diagnosis = source.diagnosis;
        }
        else if (source['diagnosisCodeableConcept']) {
            this.diagnosis = new fhir.CodeableConcept(source.diagnosisCodeableConcept);
        }
        else if (source['diagnosisReference']) {
            this.diagnosis = new fhir.Reference(source.diagnosisReference);
        }
        else {
            this.diagnosis = null;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['onAdmission']) {
            this.onAdmission = new fhir.CodeableConcept(source.onAdmission);
        }
        if (source['packageCode']) {
            this.packageCode = new fhir.CodeableConcept(source.packageCode);
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return ExDiagnosistypeValueSet;
    }
    /**
     * Example-bound Value Set for onAdmission
     */
    static onAdmissionExampleValueSet() {
        return ExDiagnosisOnAdmissionValueSet;
    }
    /**
     * Example-bound Value Set for packageCode
     */
    static packageCodeExampleValueSet() {
        return ExDiagnosisrelatedgroupValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.diagnosis.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['diagnosis']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property diagnosis: fhir: Claim.diagnosis.diagnosis[x]:", }));
        }
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["onAdmission"]) {
            outcome.issue.push(...this.onAdmission.doModelValidation().issue);
        }
        if (this["packageCode"]) {
            outcome.issue.push(...this.packageCode.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Procedures performed on the patient relevant to the billing items with the claim.
 */
export class ClaimProcedure extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimProcedure - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimProcedure';
        /**
         * For example: primary, secondary.
         */
        this.type = [];
        this.__procedureIsChoice = true;
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['type']) {
            this.type = source.type.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['procedure']) {
            this.procedure = source.procedure;
        }
        else if (source['procedureCodeableConcept']) {
            this.procedure = new fhir.CodeableConcept(source.procedureCodeableConcept);
        }
        else if (source['procedureReference']) {
            this.procedure = new fhir.Reference(source.procedureReference);
        }
        else {
            this.procedure = null;
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return ExProcedureTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.procedure.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["type"]) {
            this.type.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (!this['procedure']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property procedure: fhir: Claim.procedure.procedure[x]:", }));
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * All insurance coverages for the patient which may be applicable for reimbursement, of the products and services listed in the claim, are typically provided in the claim to allow insurers to confirm the ordering of the insurance coverages relative to local 'coordination of benefit' rules. One coverage (and only one) with 'focal=true' is to be used in the adjudication of this claim. Coverages appearing before the focal Coverage in the list, and where 'Coverage.subrogation=false', should provide a reference to the ClaimResponse containing the adjudication results of the prior claim.
 */
export class ClaimInsurance extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimInsurance - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimInsurance';
        /**
         * This value is an alphanumeric string that may be provided over the phone, via text, via paper, or within a ClaimResponse resource and is not a FHIR Identifier.
         */
        this.preAuthRef = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['focal']) {
            this.focal = new fhir.FhirBoolean({ value: source.focal });
        }
        else {
            this.focal = null;
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['coverage']) {
            this.coverage = new fhir.Reference(source.coverage);
        }
        else {
            this.coverage = null;
        }
        if (source['businessArrangement']) {
            this.businessArrangement = new fhir.FhirString({ value: source.businessArrangement });
        }
        if (source['preAuthRef']) {
            this.preAuthRef = source.preAuthRef.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['claimResponse']) {
            this.claimResponse = new fhir.Reference(source.claimResponse);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.insurance.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (!this['focal']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property focal:fhir.FhirBoolean fhir: Claim.insurance.focal:boolean", }));
        }
        if (this["focal"]) {
            outcome.issue.push(...this.focal.doModelValidation().issue);
        }
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (!this['coverage']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property coverage:fhir.Reference fhir: Claim.insurance.coverage:Reference", }));
        }
        if (this["coverage"]) {
            outcome.issue.push(...this.coverage.doModelValidation().issue);
        }
        if (this["businessArrangement"]) {
            outcome.issue.push(...this.businessArrangement.doModelValidation().issue);
        }
        if (this["preAuthRef"]) {
            this.preAuthRef.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["claimResponse"]) {
            outcome.issue.push(...this.claimResponse.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Details of an accident which resulted in injuries which required the products and services listed in the claim.
 */
export class ClaimAccident extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimAccident - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimAccident';
        this.__locationIsChoice = true;
        if (source['date']) {
            this.date = new fhir.FhirDate({ value: source.date });
        }
        else {
            this.date = null;
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['location']) {
            this.location = source.location;
        }
        else if (source['locationAddress']) {
            this.location = new fhir.Address(source.locationAddress);
        }
        else if (source['locationReference']) {
            this.location = new fhir.Reference(source.locationReference);
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return V3ActIncidentCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['date']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property date:fhir.FhirDate fhir: Claim.accident.date:date", }));
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
 */
export class ClaimItemDetailSubDetail extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimItemDetailSubDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimItemDetailSubDetail';
        /**
         * For example in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['revenue']) {
            this.revenue = new fhir.CodeableConcept(source.revenue);
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Example-bound Value Set for revenue
     */
    static revenueExampleValueSet() {
        return ExRevenueCenterValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.item.detail.subDetail.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["revenue"]) {
            outcome.issue.push(...this.revenue.doModelValidation().issue);
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: Claim.item.detail.subDetail.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
 */
export class ClaimItemDetail extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimItemDetail - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimItemDetail';
        /**
         * For example in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or out of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        /**
         * A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
         */
        this.subDetail = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['revenue']) {
            this.revenue = new fhir.CodeableConcept(source.revenue);
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
        if (source['subDetail']) {
            this.subDetail = source.subDetail.map((x) => new fhir.ClaimItemDetailSubDetail(x));
        }
    }
    /**
     * Example-bound Value Set for revenue
     */
    static revenueExampleValueSet() {
        return ExRevenueCenterValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.item.detail.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["revenue"]) {
            outcome.issue.push(...this.revenue.doModelValidation().issue);
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: Claim.item.detail.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["subDetail"]) {
            this.subDetail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
 */
export class ClaimItem extends fhir.BackboneElement {
    /**
     * Default constructor for ClaimItem - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'ClaimItem';
        /**
         * CareTeam members related to this service or product.
         */
        this.careTeamSequence = [];
        /**
         * Diagnosis applicable for this service or product.
         */
        this.diagnosisSequence = [];
        /**
         * Procedures applicable for this service or product.
         */
        this.procedureSequence = [];
        /**
         * Exceptions, special conditions and supporting information applicable for this service or product.
         */
        this.informationSequence = [];
        /**
         * For example in Oral whether the treatment is cosmetic or associated with TMJ, or for Medical whether the treatment was outside the clinic or outside of office hours.
         */
        this.modifier = [];
        /**
         * For example: Neonatal program, child dental program or drug users recovery program.
         */
        this.programCode = [];
        this.__servicedIsChoice = true;
        this.__locationIsChoice = true;
        /**
         * Unique Device Identifiers associated with this line item.
         */
        this.udi = [];
        /**
         * A region or surface of the bodySite, e.g. limb region or tooth surface(s).
         */
        this.subSite = [];
        /**
         * This will typically be the encounter the event occurred within, but some activities may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter.
         */
        this.encounter = [];
        /**
         * A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
         */
        this.detail = [];
        if (source['sequence']) {
            this.sequence = new fhir.FhirPositiveInt({ value: source.sequence });
        }
        else {
            this.sequence = null;
        }
        if (source['careTeamSequence']) {
            this.careTeamSequence = source.careTeamSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['diagnosisSequence']) {
            this.diagnosisSequence = source.diagnosisSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['procedureSequence']) {
            this.procedureSequence = source.procedureSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['informationSequence']) {
            this.informationSequence = source.informationSequence.map((x) => new fhir.FhirPositiveInt({ value: x }));
        }
        if (source['revenue']) {
            this.revenue = new fhir.CodeableConcept(source.revenue);
        }
        if (source['category']) {
            this.category = new fhir.CodeableConcept(source.category);
        }
        if (source['productOrService']) {
            this.productOrService = new fhir.CodeableConcept(source.productOrService);
        }
        else {
            this.productOrService = null;
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['programCode']) {
            this.programCode = source.programCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['serviced']) {
            this.serviced = source.serviced;
        }
        else if (source['servicedDate']) {
            this.serviced = new fhir.FhirDate({ value: source.servicedDate });
        }
        else if (source['servicedPeriod']) {
            this.serviced = new fhir.Period(source.servicedPeriod);
        }
        if (source['location']) {
            this.location = source.location;
        }
        else if (source['locationCodeableConcept']) {
            this.location = new fhir.CodeableConcept(source.locationCodeableConcept);
        }
        else if (source['locationAddress']) {
            this.location = new fhir.Address(source.locationAddress);
        }
        else if (source['locationReference']) {
            this.location = new fhir.Reference(source.locationReference);
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['unitPrice']) {
            this.unitPrice = new fhir.Money(source.unitPrice);
        }
        if (source['factor']) {
            this.factor = new fhir.FhirDecimal({ value: source.factor });
        }
        if (source['net']) {
            this.net = new fhir.Money(source.net);
        }
        if (source['udi']) {
            this.udi = source.udi.map((x) => new fhir.Reference(x));
        }
        if (source['bodySite']) {
            this.bodySite = new fhir.CodeableConcept(source.bodySite);
        }
        if (source['subSite']) {
            this.subSite = source.subSite.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['encounter']) {
            this.encounter = source.encounter.map((x) => new fhir.Reference(x));
        }
        if (source['detail']) {
            this.detail = source.detail.map((x) => new fhir.ClaimItemDetail(x));
        }
    }
    /**
     * Example-bound Value Set for revenue
     */
    static revenueExampleValueSet() {
        return ExRevenueCenterValueSet;
    }
    /**
     * Example-bound Value Set for category
     */
    static categoryExampleValueSet() {
        return ExBenefitcategoryValueSet;
    }
    /**
     * Example-bound Value Set for productOrService
     */
    static productOrServiceExampleValueSet() {
        return ServiceUsclsValueSet;
    }
    /**
     * Example-bound Value Set for modifier
     */
    static modifierExampleValueSet() {
        return ClaimModifiersValueSet;
    }
    /**
     * Example-bound Value Set for programCode
     */
    static programCodeExampleValueSet() {
        return ExProgramCodeValueSet;
    }
    /**
     * Example-bound Value Set for bodySite
     */
    static bodySiteExampleValueSet() {
        return ToothValueSet;
    }
    /**
     * Example-bound Value Set for subSite
     */
    static subSiteExampleValueSet() {
        return SurfaceValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['sequence']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property sequence:fhir.FhirPositiveInt fhir: Claim.item.sequence:positiveInt", }));
        }
        if (this["sequence"]) {
            outcome.issue.push(...this.sequence.doModelValidation().issue);
        }
        if (this["careTeamSequence"]) {
            this.careTeamSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["diagnosisSequence"]) {
            this.diagnosisSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["procedureSequence"]) {
            this.procedureSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["informationSequence"]) {
            this.informationSequence.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["revenue"]) {
            outcome.issue.push(...this.revenue.doModelValidation().issue);
        }
        if (this["category"]) {
            outcome.issue.push(...this.category.doModelValidation().issue);
        }
        if (!this['productOrService']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property productOrService:fhir.CodeableConcept fhir: Claim.item.productOrService:CodeableConcept", }));
        }
        if (this["productOrService"]) {
            outcome.issue.push(...this.productOrService.doModelValidation().issue);
        }
        if (this["modifier"]) {
            this.modifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["programCode"]) {
            this.programCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["unitPrice"]) {
            outcome.issue.push(...this.unitPrice.doModelValidation().issue);
        }
        if (this["factor"]) {
            outcome.issue.push(...this.factor.doModelValidation().issue);
        }
        if (this["net"]) {
            outcome.issue.push(...this.net.doModelValidation().issue);
        }
        if (this["udi"]) {
            this.udi.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["bodySite"]) {
            outcome.issue.push(...this.bodySite.doModelValidation().issue);
        }
        if (this["subSite"]) {
            this.subSite.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["encounter"]) {
            this.encounter.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["detail"]) {
            this.detail.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement.
 */
export class Claim extends fhir.DomainResource {
    /**
     * Default constructor for Claim - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Claim';
        /**
         * A unique identifier assigned to this claim.
         */
        this.identifier = [];
        /**
         * For example,  for the original treatment and follow-up exams.
         */
        this.related = [];
        /**
         * The members of the team who provided the products and services.
         */
        this.careTeam = [];
        /**
         * Often there are multiple jurisdiction specific valuesets which are required.
         */
        this.supportingInfo = [];
        /**
         * Information about diagnoses relevant to the claim items.
         */
        this.diagnosis = [];
        /**
         * Procedures performed on the patient relevant to the billing items with the claim.
         */
        this.procedure = [];
        /**
         * All insurance coverages for the patient which may be applicable for reimbursement, of the products and services listed in the claim, are typically provided in the claim to allow insurers to confirm the ordering of the insurance coverages relative to local 'coordination of benefit' rules. One coverage (and only one) with 'focal=true' is to be used in the adjudication of this claim. Coverages appearing before the focal Coverage in the list, and where 'Coverage.subrogation=false', should provide a reference to the ClaimResponse containing the adjudication results of the prior claim.
         */
        this.insurance = [];
        /**
         * A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
         */
        this.item = [];
        this.resourceType = 'Claim';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['subType']) {
            this.subType = new fhir.CodeableConcept(source.subType);
        }
        if (source['use']) {
            this.use = source.use;
        }
        else {
            this.use = null;
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        else {
            this.patient = null;
        }
        if (source['billablePeriod']) {
            this.billablePeriod = new fhir.Period(source.billablePeriod);
        }
        if (source['created']) {
            this.created = new fhir.FhirDateTime({ value: source.created });
        }
        else {
            this.created = null;
        }
        if (source['enterer']) {
            this.enterer = new fhir.Reference(source.enterer);
        }
        if (source['insurer']) {
            this.insurer = new fhir.Reference(source.insurer);
        }
        if (source['provider']) {
            this.provider = new fhir.Reference(source.provider);
        }
        else {
            this.provider = null;
        }
        if (source['priority']) {
            this.priority = new fhir.CodeableConcept(source.priority);
        }
        else {
            this.priority = null;
        }
        if (source['fundsReserve']) {
            this.fundsReserve = new fhir.CodeableConcept(source.fundsReserve);
        }
        if (source['related']) {
            this.related = source.related.map((x) => new fhir.ClaimRelated(x));
        }
        if (source['prescription']) {
            this.prescription = new fhir.Reference(source.prescription);
        }
        if (source['originalPrescription']) {
            this.originalPrescription = new fhir.Reference(source.originalPrescription);
        }
        if (source['payee']) {
            this.payee = new fhir.ClaimPayee(source.payee);
        }
        if (source['referral']) {
            this.referral = new fhir.Reference(source.referral);
        }
        if (source['facility']) {
            this.facility = new fhir.Reference(source.facility);
        }
        if (source['careTeam']) {
            this.careTeam = source.careTeam.map((x) => new fhir.ClaimCareTeam(x));
        }
        if (source['supportingInfo']) {
            this.supportingInfo = source.supportingInfo.map((x) => new fhir.ClaimSupportingInfo(x));
        }
        if (source['diagnosis']) {
            this.diagnosis = source.diagnosis.map((x) => new fhir.ClaimDiagnosis(x));
        }
        if (source['procedure']) {
            this.procedure = source.procedure.map((x) => new fhir.ClaimProcedure(x));
        }
        if (source['insurance']) {
            this.insurance = source.insurance.map((x) => new fhir.ClaimInsurance(x));
        }
        else {
            this.insurance = null;
        }
        if (source['accident']) {
            this.accident = new fhir.ClaimAccident(source.accident);
        }
        if (source['item']) {
            this.item = source.item.map((x) => new fhir.ClaimItem(x));
        }
        if (source['total']) {
            this.total = new fhir.Money(source.total);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return FmStatusValueSet;
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return ClaimTypeValueSet;
    }
    /**
     * Example-bound Value Set for subType
     */
    static subTypeExampleValueSet() {
        return ClaimSubtypeValueSet;
    }
    /**
     * Required-bound Value Set for use
     */
    static useRequiredValueSet() {
        return ClaimUseValueSet;
    }
    /**
     * Example-bound Value Set for priority
     */
    static priorityExampleValueSet() {
        return ProcessPriorityValueSet;
    }
    /**
     * Example-bound Value Set for fundsReserve
     */
    static fundsReserveExampleValueSet() {
        return FundsreserveValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Claim' fhir: Claim.resourceType:'Claim'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:FmStatusValueSetEnum fhir: Claim.status:code", }));
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: Claim.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["subType"]) {
            outcome.issue.push(...this.subType.doModelValidation().issue);
        }
        if (!this['use']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property use:ClaimUseValueSetEnum fhir: Claim.use:code", }));
        }
        if (!this['patient']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property patient:fhir.Reference fhir: Claim.patient:Reference", }));
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["billablePeriod"]) {
            outcome.issue.push(...this.billablePeriod.doModelValidation().issue);
        }
        if (!this['created']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property created:fhir.FhirDateTime fhir: Claim.created:dateTime", }));
        }
        if (this["created"]) {
            outcome.issue.push(...this.created.doModelValidation().issue);
        }
        if (this["enterer"]) {
            outcome.issue.push(...this.enterer.doModelValidation().issue);
        }
        if (this["insurer"]) {
            outcome.issue.push(...this.insurer.doModelValidation().issue);
        }
        if (!this['provider']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property provider:fhir.Reference fhir: Claim.provider:Reference", }));
        }
        if (this["provider"]) {
            outcome.issue.push(...this.provider.doModelValidation().issue);
        }
        if (!this['priority']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property priority:fhir.CodeableConcept fhir: Claim.priority:CodeableConcept", }));
        }
        if (this["priority"]) {
            outcome.issue.push(...this.priority.doModelValidation().issue);
        }
        if (this["fundsReserve"]) {
            outcome.issue.push(...this.fundsReserve.doModelValidation().issue);
        }
        if (this["related"]) {
            this.related.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["prescription"]) {
            outcome.issue.push(...this.prescription.doModelValidation().issue);
        }
        if (this["originalPrescription"]) {
            outcome.issue.push(...this.originalPrescription.doModelValidation().issue);
        }
        if (this["payee"]) {
            outcome.issue.push(...this.payee.doModelValidation().issue);
        }
        if (this["referral"]) {
            outcome.issue.push(...this.referral.doModelValidation().issue);
        }
        if (this["facility"]) {
            outcome.issue.push(...this.facility.doModelValidation().issue);
        }
        if (this["careTeam"]) {
            this.careTeam.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["supportingInfo"]) {
            this.supportingInfo.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["diagnosis"]) {
            this.diagnosis.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["procedure"]) {
            this.procedure.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['insurance']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property insurance:fhir.ClaimInsurance[] fhir: Claim.insurance:insurance", }));
        }
        else if (!Array.isArray(this.insurance)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property insurance:fhir.ClaimInsurance[] fhir: Claim.insurance:insurance", }));
        }
        else if (this.insurance.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property insurance:fhir.ClaimInsurance[] fhir: Claim.insurance:insurance", }));
        }
        if (this["insurance"]) {
            this.insurance.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["accident"]) {
            outcome.issue.push(...this.accident.doModelValidation().issue);
        }
        if (this["item"]) {
            this.item.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["total"]) {
            outcome.issue.push(...this.total.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Claim.js.map