// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * Todo.
 */
export class SubstanceReferenceInformationGene extends fhir.BackboneElement {
    /**
     * Default constructor for SubstanceReferenceInformationGene - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["gene"]) {
            this.gene = new fhir.CodeableConcept(source.gene);
        }
        if (source["geneSequenceOrigin"]) {
            this.geneSequenceOrigin = new fhir.CodeableConcept(source.geneSequenceOrigin);
        }
        if (source["source"]) {
            this.source = source.source.map((x) => new fhir.Reference(x));
        }
    }
    /**
     * Check if the current SubstanceReferenceInformationGene contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SubstanceReferenceInformationGene from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SubstanceReferenceInformationGene(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SubstanceReferenceInformationGene is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Todo.
 */
export class SubstanceReferenceInformationGeneElement extends fhir.BackboneElement {
    /**
     * Default constructor for SubstanceReferenceInformationGeneElement - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["element"]) {
            this.element = new fhir.Identifier(source.element);
        }
        if (source["source"]) {
            this.source = source.source.map((x) => new fhir.Reference(x));
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current SubstanceReferenceInformationGeneElement contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SubstanceReferenceInformationGeneElement from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SubstanceReferenceInformationGeneElement(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SubstanceReferenceInformationGeneElement is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Todo.
 */
export class SubstanceReferenceInformationClassification extends fhir.BackboneElement {
    /**
     * Default constructor for SubstanceReferenceInformationClassification - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["classification"]) {
            this.classification = new fhir.CodeableConcept(source.classification);
        }
        if (source["domain"]) {
            this.domain = new fhir.CodeableConcept(source.domain);
        }
        if (source["source"]) {
            this.source = source.source.map((x) => new fhir.Reference(x));
        }
        if (source["subtype"]) {
            this.subtype = source.subtype.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Check if the current SubstanceReferenceInformationClassification contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SubstanceReferenceInformationClassification from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SubstanceReferenceInformationClassification(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SubstanceReferenceInformationClassification is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Todo.
 */
export class SubstanceReferenceInformationTarget extends fhir.BackboneElement {
    /**
     * Default constructor for SubstanceReferenceInformationTarget - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["amountQuantity"]) {
            this.amountQuantity = new fhir.Quantity(source.amountQuantity);
        }
        if (source["amountRange"]) {
            this.amountRange = new fhir.Range(source.amountRange);
        }
        if (source["amountString"]) {
            this.amountString = source.amountString;
        }
        if (source["_amountString"]) {
            this._amountString = new fhir.FhirElement(source._amountString);
        }
        if (source["amountType"]) {
            this.amountType = new fhir.CodeableConcept(source.amountType);
        }
        if (source["interaction"]) {
            this.interaction = new fhir.CodeableConcept(source.interaction);
        }
        if (source["organism"]) {
            this.organism = new fhir.CodeableConcept(source.organism);
        }
        if (source["organismType"]) {
            this.organismType = new fhir.CodeableConcept(source.organismType);
        }
        if (source["source"]) {
            this.source = source.source.map((x) => new fhir.Reference(x));
        }
        if (source["target"]) {
            this.target = new fhir.Identifier(source.target);
        }
        if (source["type"]) {
            this.type = new fhir.CodeableConcept(source.type);
        }
    }
    /**
     * Check if the current SubstanceReferenceInformationTarget contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SubstanceReferenceInformationTarget from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SubstanceReferenceInformationTarget(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SubstanceReferenceInformationTarget is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Todo.
 */
export class SubstanceReferenceInformation extends fhir.DomainResource {
    /**
     * Default constructor for SubstanceReferenceInformation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'SubstanceReferenceInformation';
        if (source["classification"]) {
            this.classification = source.classification.map((x) => new fhir.SubstanceReferenceInformationClassification(x));
        }
        if (source["comment"]) {
            this.comment = source.comment;
        }
        if (source["_comment"]) {
            this._comment = new fhir.FhirElement(source._comment);
        }
        if (source["gene"]) {
            this.gene = source.gene.map((x) => new fhir.SubstanceReferenceInformationGene(x));
        }
        if (source["geneElement"]) {
            this.geneElement = source.geneElement.map((x) => new fhir.SubstanceReferenceInformationGeneElement(x));
        }
        if (source["target"]) {
            this.target = source.target.map((x) => new fhir.SubstanceReferenceInformationTarget(x));
        }
    }
    /**
     * Check if the current SubstanceReferenceInformation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a SubstanceReferenceInformation from an object that MUST contain all required elements.
     */
    static fromStrict(source) {
        var dest = new SubstanceReferenceInformation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `SubstanceReferenceInformation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
//# sourceMappingURL=SubstanceReferenceInformation.js.map