// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: DeviceDefinition
import * as fhir from '../fhir.js';
import { DeviceNametypeValueSet, } from '../fhirValueSets/DeviceNametypeValueSet.js';
import { DeviceKindValueSet, } from '../fhirValueSets/DeviceKindValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
 */
export class DeviceDefinitionUdiDeviceIdentifier extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDefinitionUdiDeviceIdentifier - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinitionUdiDeviceIdentifier';
        if (source['deviceIdentifier']) {
            this.deviceIdentifier = new fhir.FhirString({ value: source.deviceIdentifier });
        }
        else {
            this.deviceIdentifier = null;
        }
        if (source['issuer']) {
            this.issuer = new fhir.FhirUri({ value: source.issuer });
        }
        else {
            this.issuer = null;
        }
        if (source['jurisdiction']) {
            this.jurisdiction = new fhir.FhirUri({ value: source.jurisdiction });
        }
        else {
            this.jurisdiction = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['deviceIdentifier']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property deviceIdentifier:fhir.FhirString fhir: DeviceDefinition.udiDeviceIdentifier.deviceIdentifier:string", }));
        }
        if (this["deviceIdentifier"]) {
            outcome.issue.push(...this.deviceIdentifier.doModelValidation().issue);
        }
        if (!this['issuer']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property issuer:fhir.FhirUri fhir: DeviceDefinition.udiDeviceIdentifier.issuer:uri", }));
        }
        if (this["issuer"]) {
            outcome.issue.push(...this.issuer.doModelValidation().issue);
        }
        if (!this['jurisdiction']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property jurisdiction:fhir.FhirUri fhir: DeviceDefinition.udiDeviceIdentifier.jurisdiction:uri", }));
        }
        if (this["jurisdiction"]) {
            outcome.issue.push(...this.jurisdiction.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A name given to the device to identify it.
 */
export class DeviceDefinitionDeviceName extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDefinitionDeviceName - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinitionDeviceName';
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return DeviceNametypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: DeviceDefinition.deviceName.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:DeviceNametypeValueSetEnum fhir: DeviceDefinition.deviceName.type:code", }));
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
 */
export class DeviceDefinitionSpecialization extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDefinitionSpecialization - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinitionSpecialization';
        if (source['systemType']) {
            this.systemType = new fhir.FhirString({ value: source.systemType });
        }
        else {
            this.systemType = null;
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['systemType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property systemType:fhir.FhirString fhir: DeviceDefinition.specialization.systemType:string", }));
        }
        if (this["systemType"]) {
            outcome.issue.push(...this.systemType.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Device capabilities.
 */
export class DeviceDefinitionCapability extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDefinitionCapability - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinitionCapability';
        /**
         * Description of capability.
         */
        this.description = [];
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['description']) {
            this.description = source.description.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: DeviceDefinition.capability.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["description"]) {
            this.description.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
 */
export class DeviceDefinitionProperty extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDefinitionProperty - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinitionProperty';
        /**
         * Property value as a quantity.
         */
        this.valueQuantity = [];
        /**
         * Property value as a code, e.g., NTP4 (synced to NTP).
         */
        this.valueCode = [];
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        else {
            this.type = null;
        }
        if (source['valueQuantity']) {
            this.valueQuantity = source.valueQuantity.map((x) => new fhir.Quantity(x));
        }
        if (source['valueCode']) {
            this.valueCode = source.valueCode.map((x) => new fhir.CodeableConcept(x));
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:fhir.CodeableConcept fhir: DeviceDefinition.property.type:CodeableConcept", }));
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["valueQuantity"]) {
            this.valueQuantity.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["valueCode"]) {
            this.valueCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A substance used to create the material(s) of which the device is made.
 */
export class DeviceDefinitionMaterial extends fhir.BackboneElement {
    /**
     * Default constructor for DeviceDefinitionMaterial - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinitionMaterial';
        if (source['substance']) {
            this.substance = new fhir.CodeableConcept(source.substance);
        }
        else {
            this.substance = null;
        }
        if (source['alternate']) {
            this.alternate = new fhir.FhirBoolean({ value: source.alternate });
        }
        if (source['allergenicIndicator']) {
            this.allergenicIndicator = new fhir.FhirBoolean({ value: source.allergenicIndicator });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['substance']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property substance:fhir.CodeableConcept fhir: DeviceDefinition.material.substance:CodeableConcept", }));
        }
        if (this["substance"]) {
            outcome.issue.push(...this.substance.doModelValidation().issue);
        }
        if (this["alternate"]) {
            outcome.issue.push(...this.alternate.doModelValidation().issue);
        }
        if (this["allergenicIndicator"]) {
            outcome.issue.push(...this.allergenicIndicator.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The characteristics, operational status and capabilities of a medical-related component of a medical device.
 */
export class DeviceDefinition extends fhir.DomainResource {
    /**
     * Default constructor for DeviceDefinition - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'DeviceDefinition';
        /**
         * Unique instance identifiers assigned to a device by the software, manufacturers, other organizations or owners. For example: handle ID.
         */
        this.identifier = [];
        /**
         * Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
         */
        this.udiDeviceIdentifier = [];
        this.__manufacturerIsChoice = true;
        /**
         * A name given to the device to identify it.
         */
        this.deviceName = [];
        /**
         * The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
         */
        this.specialization = [];
        /**
         * The available versions of the device, e.g., software versions.
         */
        this.version = [];
        /**
         * Safety characteristics of the device.
         */
        this.safety = [];
        /**
         * Shelf Life and storage information.
         */
        this.shelfLifeStorage = [];
        /**
         * Language code for the human-readable text strings produced by the device (all supported).
         */
        this.languageCode = [];
        /**
         * Device capabilities.
         */
        this.capability = [];
        /**
         * The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
         */
        this.property = [];
        /**
         * used for troubleshooting etc.
         */
        this.contact = [];
        /**
         * Descriptive information, usage information or implantation information that is not captured in an existing element.
         */
        this.note = [];
        /**
         * A substance used to create the material(s) of which the device is made.
         */
        this.material = [];
        this.resourceType = 'DeviceDefinition';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['udiDeviceIdentifier']) {
            this.udiDeviceIdentifier = source.udiDeviceIdentifier.map((x) => new fhir.DeviceDefinitionUdiDeviceIdentifier(x));
        }
        if (source['manufacturer']) {
            this.manufacturer = source.manufacturer;
        }
        else if (source['manufacturerString']) {
            this.manufacturer = new fhir.FhirString({ value: source.manufacturerString });
        }
        else if (source['manufacturerReference']) {
            this.manufacturer = new fhir.Reference(source.manufacturerReference);
        }
        if (source['deviceName']) {
            this.deviceName = source.deviceName.map((x) => new fhir.DeviceDefinitionDeviceName(x));
        }
        if (source['modelNumber']) {
            this.modelNumber = new fhir.FhirString({ value: source.modelNumber });
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['specialization']) {
            this.specialization = source.specialization.map((x) => new fhir.DeviceDefinitionSpecialization(x));
        }
        if (source['version']) {
            this.version = source.version.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['safety']) {
            this.safety = source.safety.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['shelfLifeStorage']) {
            this.shelfLifeStorage = source.shelfLifeStorage.map((x) => new fhir.ProductShelfLife(x));
        }
        if (source['physicalCharacteristics']) {
            this.physicalCharacteristics = new fhir.ProdCharacteristic(source.physicalCharacteristics);
        }
        if (source['languageCode']) {
            this.languageCode = source.languageCode.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['capability']) {
            this.capability = source.capability.map((x) => new fhir.DeviceDefinitionCapability(x));
        }
        if (source['property']) {
            this.property = source.property.map((x) => new fhir.DeviceDefinitionProperty(x));
        }
        if (source['owner']) {
            this.owner = new fhir.Reference(source.owner);
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactPoint(x));
        }
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        if (source['onlineInformation']) {
            this.onlineInformation = new fhir.FhirUri({ value: source.onlineInformation });
        }
        if (source['note']) {
            this.note = source.note.map((x) => new fhir.Annotation(x));
        }
        if (source['quantity']) {
            this.quantity = new fhir.Quantity(source.quantity);
        }
        if (source['parentDevice']) {
            this.parentDevice = new fhir.Reference(source.parentDevice);
        }
        if (source['material']) {
            this.material = source.material.map((x) => new fhir.DeviceDefinitionMaterial(x));
        }
    }
    /**
     * Example-bound Value Set for type
     */
    static typeExampleValueSet() {
        return DeviceKindValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'DeviceDefinition' fhir: DeviceDefinition.resourceType:'DeviceDefinition'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["udiDeviceIdentifier"]) {
            this.udiDeviceIdentifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["deviceName"]) {
            this.deviceName.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["modelNumber"]) {
            outcome.issue.push(...this.modelNumber.doModelValidation().issue);
        }
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["specialization"]) {
            this.specialization.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["version"]) {
            this.version.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["safety"]) {
            this.safety.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["shelfLifeStorage"]) {
            this.shelfLifeStorage.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["physicalCharacteristics"]) {
            outcome.issue.push(...this.physicalCharacteristics.doModelValidation().issue);
        }
        if (this["languageCode"]) {
            this.languageCode.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["capability"]) {
            this.capability.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["property"]) {
            this.property.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["owner"]) {
            outcome.issue.push(...this.owner.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["onlineInformation"]) {
            outcome.issue.push(...this.onlineInformation.doModelValidation().issue);
        }
        if (this["note"]) {
            this.note.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["quantity"]) {
            outcome.issue.push(...this.quantity.doModelValidation().issue);
        }
        if (this["parentDevice"]) {
            outcome.issue.push(...this.parentDevice.doModelValidation().issue);
        }
        if (this["material"]) {
            this.material.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=DeviceDefinition.js.map