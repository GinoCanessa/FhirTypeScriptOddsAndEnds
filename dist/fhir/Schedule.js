// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Schedule
import * as fhir from '../fhir.js';
import { ServiceCategoryValueSet, } from '../fhirValueSets/ServiceCategoryValueSet.js';
import { ServiceTypeValueSet, } from '../fhirValueSets/ServiceTypeValueSet.js';
import { C80PracticeCodesValueSet, } from '../fhirValueSets/C80PracticeCodesValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * A container for slots of time that may be available for booking appointments.
 */
export class Schedule extends fhir.DomainResource {
    /**
     * Default constructor for Schedule - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Schedule';
        /**
         * External Ids for this item.
         */
        this.identifier = [];
        /**
         * A broad categorization of the service that is to be performed during this appointment.
         */
        this.serviceCategory = [];
        /**
         * The specific service that is to be performed during this appointment.
         */
        this.serviceType = [];
        /**
         * The specialty of a practitioner that would be required to perform the service requested in this appointment.
         */
        this.specialty = [];
        /**
         * The capacity to support multiple referenced resource types should be used in cases where the specific resources themselves cannot be scheduled without the other, and thus only make sense to the system exposing them as a group. Common examples of this are where the combination of a practitioner and a room (Location) are always required by a system.
         */
        this.actor = [];
        this.resourceType = 'Schedule';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['active']) {
            this.active = new fhir.FhirBoolean({ value: source.active });
        }
        if (source['serviceCategory']) {
            this.serviceCategory = source.serviceCategory.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['serviceType']) {
            this.serviceType = source.serviceType.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['specialty']) {
            this.specialty = source.specialty.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['actor']) {
            this.actor = source.actor.map((x) => new fhir.Reference(x));
        }
        else {
            this.actor = null;
        }
        if (source['planningHorizon']) {
            this.planningHorizon = new fhir.Period(source.planningHorizon);
        }
        if (source['comment']) {
            this.comment = new fhir.FhirString({ value: source.comment });
        }
    }
    /**
     * Example-bound Value Set for serviceCategory
     */
    static serviceCategoryExampleValueSet() {
        return ServiceCategoryValueSet;
    }
    /**
     * Example-bound Value Set for serviceType
     */
    static serviceTypeExampleValueSet() {
        return ServiceTypeValueSet;
    }
    /**
     * Preferred-bound Value Set for specialty
     */
    static specialtyPreferredValueSet() {
        return C80PracticeCodesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'Schedule' fhir: Schedule.resourceType:'Schedule'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["active"]) {
            outcome.issue.push(...this.active.doModelValidation().issue);
        }
        if (this["serviceCategory"]) {
            this.serviceCategory.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["serviceType"]) {
            this.serviceType.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["specialty"]) {
            this.specialty.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['actor']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property actor:fhir.Reference[] fhir: Schedule.actor:Reference", }));
        }
        else if (!Array.isArray(this.actor)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property actor:fhir.Reference[] fhir: Schedule.actor:Reference", }));
        }
        else if (this.actor.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property actor:fhir.Reference[] fhir: Schedule.actor:Reference", }));
        }
        if (this["actor"]) {
            this.actor.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["planningHorizon"]) {
            outcome.issue.push(...this.planningHorizon.doModelValidation().issue);
        }
        if (this["comment"]) {
            outcome.issue.push(...this.comment.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Schedule.js.map