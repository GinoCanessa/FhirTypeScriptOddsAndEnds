// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: SearchParameter
import * as fhir from '../fhir.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { ResourceTypesValueSet, } from '../fhirValueSets/ResourceTypesValueSet.js';
import { SearchParamTypeValueSet, } from '../fhirValueSets/SearchParamTypeValueSet.js';
import { SearchXpathUsageValueSet, } from '../fhirValueSets/SearchXpathUsageValueSet.js';
import { SearchComparatorValueSet, } from '../fhirValueSets/SearchComparatorValueSet.js';
import { SearchModifierCodeValueSet, } from '../fhirValueSets/SearchModifierCodeValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Used to define the parts of a composite search parameter.
 */
export class SearchParameterComponent extends fhir.BackboneElement {
    /**
     * Default constructor for SearchParameterComponent - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SearchParameterComponent';
        if (source['definition']) {
            this.definition = new fhir.FhirCanonical({ value: source.definition });
        }
        else {
            this.definition = null;
        }
        if (source['expression']) {
            this.expression = new fhir.FhirString({ value: source.expression });
        }
        else {
            this.expression = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['definition']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property definition:fhir.FhirCanonical fhir: SearchParameter.component.definition:canonical", }));
        }
        if (this["definition"]) {
            outcome.issue.push(...this.definition.doModelValidation().issue);
        }
        if (!this['expression']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property expression:fhir.FhirString fhir: SearchParameter.component.expression:string", }));
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A search parameter that defines a named search item that can be used to search/filter on a resource.
 */
export class SearchParameter extends fhir.DomainResource {
    /**
     * Default constructor for SearchParameter - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'SearchParameter';
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the search parameter to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * A search parameter must always apply to at least one resource type. When search parameters apply to more than one resource type, they can be used against any of the listed resource types, or in a cross-type search (see [Cross Resource Search](http.html#xres-search)).
         */
        this.base = [];
        /**
         * Types of resource (if a resource is referenced).
         */
        this.target = [];
        /**
         * If no comparators are listed, clients should not expect servers to support any comparators.
         */
        this.comparator = [];
        /**
         * A modifier supported for the search parameter.
         */
        this.modifier = [];
        /**
         * Systems are not required to list all the chain names they support, but if they don't list them, clients might not know to use them.
         */
        this.chain = [];
        /**
         * Used to define the parts of a composite search parameter.
         */
        this.component = [];
        this.resourceType = 'SearchParameter';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['derivedFrom']) {
            this.derivedFrom = new fhir.FhirCanonical({ value: source.derivedFrom });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        else {
            this.description = null;
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['code']) {
            this.code = new fhir.FhirCode({ value: source.code });
        }
        else {
            this.code = null;
        }
        if (source['base']) {
            this.base = source.base.map((x) => new fhir.FhirCode({ value: x }));
        }
        else {
            this.base = null;
        }
        if (source['type']) {
            this.type = source.type;
        }
        else {
            this.type = null;
        }
        if (source['expression']) {
            this.expression = new fhir.FhirString({ value: source.expression });
        }
        if (source['xpath']) {
            this.xpath = new fhir.FhirString({ value: source.xpath });
        }
        if (source['xpathUsage']) {
            this.xpathUsage = source.xpathUsage;
        }
        if (source['target']) {
            this.target = source.target.map((x) => new fhir.FhirCode({ value: x }));
        }
        if (source['multipleOr']) {
            this.multipleOr = new fhir.FhirBoolean({ value: source.multipleOr });
        }
        if (source['multipleAnd']) {
            this.multipleAnd = new fhir.FhirBoolean({ value: source.multipleAnd });
        }
        if (source['comparator']) {
            this.comparator = source.comparator.map((x) => x);
        }
        if (source['modifier']) {
            this.modifier = source.modifier.map((x) => x);
        }
        if (source['chain']) {
            this.chain = source.chain.map((x) => new fhir.FhirString({ value: x }));
        }
        if (source['component']) {
            this.component = source.component.map((x) => new fhir.SearchParameterComponent(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Required-bound Value Set for base
     */
    static baseRequiredValueSet() {
        return ResourceTypesValueSet;
    }
    /**
     * Required-bound Value Set for type
     */
    static typeRequiredValueSet() {
        return SearchParamTypeValueSet;
    }
    /**
     * Required-bound Value Set for xpathUsage
     */
    static xpathUsageRequiredValueSet() {
        return SearchXpathUsageValueSet;
    }
    /**
     * Required-bound Value Set for target
     */
    static targetRequiredValueSet() {
        return ResourceTypesValueSet;
    }
    /**
     * Required-bound Value Set for comparator
     */
    static comparatorRequiredValueSet() {
        return SearchComparatorValueSet;
    }
    /**
     * Required-bound Value Set for modifier
     */
    static modifierRequiredValueSet() {
        return SearchModifierCodeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'SearchParameter' fhir: SearchParameter.resourceType:'SearchParameter'", }));
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: SearchParameter.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: SearchParameter.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["derivedFrom"]) {
            outcome.issue.push(...this.derivedFrom.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: SearchParameter.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['description']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property description:fhir.FhirMarkdown fhir: SearchParameter.description:markdown", }));
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (!this['code']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property code:fhir.FhirCode fhir: SearchParameter.code:code", }));
        }
        if (this["code"]) {
            outcome.issue.push(...this.code.doModelValidation().issue);
        }
        if (!this['base']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property base:fhir.FhirCode[] fhir: SearchParameter.base:code", }));
        }
        else if (!Array.isArray(this.base)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property base:fhir.FhirCode[] fhir: SearchParameter.base:code", }));
        }
        else if (this.base.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property base:fhir.FhirCode[] fhir: SearchParameter.base:code", }));
        }
        if (this["base"]) {
            this.base.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['type']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property type:SearchParamTypeValueSetEnum fhir: SearchParameter.type:code", }));
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        if (this["xpath"]) {
            outcome.issue.push(...this.xpath.doModelValidation().issue);
        }
        if (this["target"]) {
            this.target.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["multipleOr"]) {
            outcome.issue.push(...this.multipleOr.doModelValidation().issue);
        }
        if (this["multipleAnd"]) {
            outcome.issue.push(...this.multipleAnd.doModelValidation().issue);
        }
        if (this["chain"]) {
            this.chain.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["component"]) {
            this.component.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=SearchParameter.js.map