// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: Meta
import * as fhir from '../fhir.js';
import { SecurityLabelsValueSet, } from '../fhirValueSets/SecurityLabelsValueSet.js';
import { CommonTagsValueSet, } from '../fhirValueSets/CommonTagsValueSet.js';
/**
 * The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 */
export class Meta extends fhir.FhirElement {
    /**
     * Default constructor for Meta - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'Meta';
        /**
         * It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time.  The list of profile URLs is a set.
         */
        this.profile = [];
        /**
         * The security labels can be updated without changing the stated version of the resource. The list of security labels is a set. Uniqueness is based the system/code, and version and display are ignored.
         */
        this.security = [];
        /**
         * The tags can be updated without changing the stated version of the resource. The list of tags is a set. Uniqueness is based the system/code, and version and display are ignored.
         */
        this.tag = [];
        if (source['versionId']) {
            this.versionId = new fhir.FhirId({ value: source.versionId });
        }
        if (source['lastUpdated']) {
            this.lastUpdated = new fhir.FhirInstant({ value: source.lastUpdated });
        }
        if (source['source']) {
            this.source = new fhir.FhirUri({ value: source.source });
        }
        if (source['profile']) {
            this.profile = source.profile.map((x) => new fhir.FhirCanonical({ value: x }));
        }
        if (source['security']) {
            this.security = source.security.map((x) => new fhir.Coding(x));
        }
        if (source['tag']) {
            this.tag = source.tag.map((x) => new fhir.Coding(x));
        }
    }
    /**
     * Extensible-bound Value Set for security
     */
    static securityExtensibleValueSet() {
        return SecurityLabelsValueSet;
    }
    /**
     * Example-bound Value Set for tag
     */
    static tagExampleValueSet() {
        return CommonTagsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["versionId"]) {
            outcome.issue.push(...this.versionId.doModelValidation().issue);
        }
        if (this["lastUpdated"]) {
            outcome.issue.push(...this.lastUpdated.doModelValidation().issue);
        }
        if (this["source"]) {
            outcome.issue.push(...this.source.doModelValidation().issue);
        }
        if (this["profile"]) {
            this.profile.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["security"]) {
            this.security.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["tag"]) {
            this.tag.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=Meta.js.map