// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir';
/**
 * The purpose of this element is to define the profile of an origin element used elsewhere in the script.  Test engines could then use the origin-profile mapping to offer a filtered list of test systems that can serve as the sender for the interaction.
 */
export class TestScriptOrigin extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptOrigin - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.index = null;
        if (source["index"]) {
            this.index = source.index;
        }
        if (this.index === undefined) {
            this.index = null;
        }
        if (source["_index"]) {
            this._index = new fhir.FhirElement(source._index);
        }
        this.profile = null;
        if (source["profile"]) {
            this.profile = new fhir.Coding(source.profile);
        }
        if (this.profile === undefined) {
            this.profile = null;
        }
    }
    /**
     * Check if the current TestScriptOrigin contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["index"] === undefined) {
            missingElements.push("index");
        }
        if (this["profile"] === undefined) {
            missingElements.push("profile");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptOrigin from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptOrigin(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptOrigin is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The purpose of this element is to define the profile of a destination element used elsewhere in the script.  Test engines could then use the destination-profile mapping to offer a filtered list of test systems that can serve as the receiver for the interaction.
 */
export class TestScriptDestination extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptDestination - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.index = null;
        if (source["index"]) {
            this.index = source.index;
        }
        if (this.index === undefined) {
            this.index = null;
        }
        if (source["_index"]) {
            this._index = new fhir.FhirElement(source._index);
        }
        this.profile = null;
        if (source["profile"]) {
            this.profile = new fhir.Coding(source.profile);
        }
        if (this.profile === undefined) {
            this.profile = null;
        }
    }
    /**
     * Check if the current TestScriptDestination contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["index"] === undefined) {
            missingElements.push("index");
        }
        if (this["profile"] === undefined) {
            missingElements.push("profile");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptDestination from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptDestination(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptDestination is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A link to the FHIR specification that this test is covering.
 */
export class TestScriptMetadataLink extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadataLink - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        this.url = null;
        if (source["url"]) {
            this.url = source.url;
        }
        if (this.url === undefined) {
            this.url = null;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Check if the current TestScriptMetadataLink contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["url"] === undefined) {
            missingElements.push("url");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptMetadataLink from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptMetadataLink(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptMetadataLink is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * When the metadata capabilities section is defined at TestScript.metadata or at TestScript.setup.metadata, and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then all the tests in the TestScript are skipped.  When the metadata capabilities section is defined at TestScript.test.metadata and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then only that test is skipped.  The "metadata.capabilities.required" and "metadata.capabilities.validated" elements only indicate whether the capabilities are the primary focus of the test script or not.  They do not impact the skipping logic.  Capabilities whose "metadata.capabilities.validated" flag is true are the primary focus of the test script.
 */
export class TestScriptMetadataCapability extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadataCapability - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.capabilities = null;
        if (source["capabilities"]) {
            this.capabilities = source.capabilities;
        }
        if (this.capabilities === undefined) {
            this.capabilities = null;
        }
        if (source["_capabilities"]) {
            this._capabilities = new fhir.FhirElement(source._capabilities);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["destination"]) {
            this.destination = source.destination;
        }
        if (source["_destination"]) {
            this._destination = new fhir.FhirElement(source._destination);
        }
        if (source["link"]) {
            this.link = source.link.map((x) => (x));
        }
        if (source["_link"]) {
            this._link = source._link.map((x) => new fhir.FhirElement(x));
        }
        if (source["origin"]) {
            this.origin = source.origin.map((x) => (x));
        }
        if (source["_origin"]) {
            this._origin = source._origin.map((x) => new fhir.FhirElement(x));
        }
        this.required = null;
        if (source["required"]) {
            this.required = source.required;
        }
        if (this.required === undefined) {
            this.required = null;
        }
        if (source["_required"]) {
            this._required = new fhir.FhirElement(source._required);
        }
        this.validated = null;
        if (source["validated"]) {
            this.validated = source.validated;
        }
        if (this.validated === undefined) {
            this.validated = null;
        }
        if (source["_validated"]) {
            this._validated = new fhir.FhirElement(source._validated);
        }
    }
    /**
     * Check if the current TestScriptMetadataCapability contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["capabilities"] === undefined) {
            missingElements.push("capabilities");
        }
        if (this["required"] === undefined) {
            missingElements.push("required");
        }
        if (this["validated"] === undefined) {
            missingElements.push("validated");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptMetadataCapability from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptMetadataCapability(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptMetadataCapability is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The required capability must exist and are assumed to function correctly on the FHIR server being tested.
 */
export class TestScriptMetadata extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadata - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.capability = null;
        if (source["capability"]) {
            this.capability = source.capability.map((x) => new fhir.TestScriptMetadataCapability(x));
        }
        if (this.capability === undefined) {
            this.capability = null;
        }
        if (source["link"]) {
            this.link = source.link.map((x) => new fhir.TestScriptMetadataLink(x));
        }
    }
    /**
     * Check if the current TestScriptMetadata contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["capability"]) || (this["capability"].length === 0)) {
            missingElements.push("capability");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptMetadata from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptMetadata(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptMetadata is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
 */
export class TestScriptFixture extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptFixture - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.autocreate = null;
        if (source["autocreate"]) {
            this.autocreate = source.autocreate;
        }
        if (this.autocreate === undefined) {
            this.autocreate = null;
        }
        if (source["_autocreate"]) {
            this._autocreate = new fhir.FhirElement(source._autocreate);
        }
        this.autodelete = null;
        if (source["autodelete"]) {
            this.autodelete = source.autodelete;
        }
        if (this.autodelete === undefined) {
            this.autodelete = null;
        }
        if (source["_autodelete"]) {
            this._autodelete = new fhir.FhirElement(source._autodelete);
        }
        if (source["resource"]) {
            this.resource = new fhir.Reference(source.resource);
        }
    }
    /**
     * Check if the current TestScriptFixture contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["autocreate"] === undefined) {
            missingElements.push("autocreate");
        }
        if (this["autodelete"] === undefined) {
            missingElements.push("autodelete");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptFixture from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptFixture(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptFixture is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Variables would be set based either on XPath/JSONPath expressions against fixtures (static and response), or headerField evaluations against response headers. If variable evaluates to nodelist or anything other than a primitive value, then test engine would report an error.  Variables would be used to perform clean replacements in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations. This limits the places that test engines would need to look for placeholders "${}".  Variables are scoped to the whole script. They are NOT evaluated at declaration. They are evaluated by test engine when used for substitutions in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations.  See example testscript-search.xml.
 */
export class TestScriptVariable extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptVariable - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["defaultValue"]) {
            this.defaultValue = source.defaultValue;
        }
        if (source["_defaultValue"]) {
            this._defaultValue = new fhir.FhirElement(source._defaultValue);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["expression"]) {
            this.expression = source.expression;
        }
        if (source["_expression"]) {
            this._expression = new fhir.FhirElement(source._expression);
        }
        if (source["headerField"]) {
            this.headerField = source.headerField;
        }
        if (source["_headerField"]) {
            this._headerField = new fhir.FhirElement(source._headerField);
        }
        if (source["hint"]) {
            this.hint = source.hint;
        }
        if (source["_hint"]) {
            this._hint = new fhir.FhirElement(source._hint);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["path"]) {
            this.path = source.path;
        }
        if (source["_path"]) {
            this._path = new fhir.FhirElement(source._path);
        }
        if (source["sourceId"]) {
            this.sourceId = source.sourceId;
        }
        if (source["_sourceId"]) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
    }
    /**
     * Check if the current TestScriptVariable contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptVariable from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptVariable(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptVariable is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * This gives control to test-script writers to set headers explicitly based on test requirements.  It will allow for testing using:  - "If-Modified-Since" and "If-None-Match" headers.  See http://build.fhir.org/http.html#2.1.0.5.1 - "If-Match" header.  See http://build.fhir.org/http.html#2.1.0.11 - Conditional Create using "If-None-Exist".  See http://build.fhir.org/http.html#2.1.0.13.1 - Invalid "Content-Type" header for negative testing. - etc.
 */
export class TestScriptSetupActionOperationRequestHeader extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionOperationRequestHeader - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.field = null;
        if (source["field"]) {
            this.field = source.field;
        }
        if (this.field === undefined) {
            this.field = null;
        }
        if (source["_field"]) {
            this._field = new fhir.FhirElement(source._field);
        }
        this.value = null;
        if (source["value"]) {
            this.value = source.value;
        }
        if (this.value === undefined) {
            this.value = null;
        }
        if (source["_value"]) {
            this._value = new fhir.FhirElement(source._value);
        }
    }
    /**
     * Check if the current TestScriptSetupActionOperationRequestHeader contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["field"] === undefined) {
            missingElements.push("field");
        }
        if (this["value"] === undefined) {
            missingElements.push("value");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptSetupActionOperationRequestHeader from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptSetupActionOperationRequestHeader(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptSetupActionOperationRequestHeader is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * The operation to perform.
 */
export class TestScriptSetupActionOperation extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["accept"]) {
            this.accept = source.accept;
        }
        if (source["_accept"]) {
            this._accept = new fhir.FhirElement(source._accept);
        }
        if (source["contentType"]) {
            this.contentType = source.contentType;
        }
        if (source["_contentType"]) {
            this._contentType = new fhir.FhirElement(source._contentType);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["destination"]) {
            this.destination = source.destination;
        }
        if (source["_destination"]) {
            this._destination = new fhir.FhirElement(source._destination);
        }
        this.encodeRequestUrl = null;
        if (source["encodeRequestUrl"]) {
            this.encodeRequestUrl = source.encodeRequestUrl;
        }
        if (this.encodeRequestUrl === undefined) {
            this.encodeRequestUrl = null;
        }
        if (source["_encodeRequestUrl"]) {
            this._encodeRequestUrl = new fhir.FhirElement(source._encodeRequestUrl);
        }
        if (source["label"]) {
            this.label = source.label;
        }
        if (source["_label"]) {
            this._label = new fhir.FhirElement(source._label);
        }
        if (source["method"]) {
            this.method = source.method;
        }
        if (source["_method"]) {
            this._method = new fhir.FhirElement(source._method);
        }
        if (source["origin"]) {
            this.origin = source.origin;
        }
        if (source["_origin"]) {
            this._origin = new fhir.FhirElement(source._origin);
        }
        if (source["params"]) {
            this.params = source.params;
        }
        if (source["_params"]) {
            this._params = new fhir.FhirElement(source._params);
        }
        if (source["requestHeader"]) {
            this.requestHeader = source.requestHeader.map((x) => new fhir.TestScriptSetupActionOperationRequestHeader(x));
        }
        if (source["requestId"]) {
            this.requestId = source.requestId;
        }
        if (source["_requestId"]) {
            this._requestId = new fhir.FhirElement(source._requestId);
        }
        if (source["resource"]) {
            this.resource = source.resource;
        }
        if (source["_resource"]) {
            this._resource = new fhir.FhirElement(source._resource);
        }
        if (source["responseId"]) {
            this.responseId = source.responseId;
        }
        if (source["_responseId"]) {
            this._responseId = new fhir.FhirElement(source._responseId);
        }
        if (source["sourceId"]) {
            this.sourceId = source.sourceId;
        }
        if (source["_sourceId"]) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
        if (source["targetId"]) {
            this.targetId = source.targetId;
        }
        if (source["_targetId"]) {
            this._targetId = new fhir.FhirElement(source._targetId);
        }
        if (source["type"]) {
            this.type = new fhir.Coding(source.type);
        }
        if (source["url"]) {
            this.url = source.url;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Check if the current TestScriptSetupActionOperation contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["encodeRequestUrl"] === undefined) {
            missingElements.push("encodeRequestUrl");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptSetupActionOperation from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptSetupActionOperation(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptSetupActionOperation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * In order to evaluate an assertion, the request, response, and results of the most recently executed operation must always be maintained by the test engine.
 */
export class TestScriptSetupActionAssert extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionAssert - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["compareToSourceExpression"]) {
            this.compareToSourceExpression = source.compareToSourceExpression;
        }
        if (source["_compareToSourceExpression"]) {
            this._compareToSourceExpression = new fhir.FhirElement(source._compareToSourceExpression);
        }
        if (source["compareToSourceId"]) {
            this.compareToSourceId = source.compareToSourceId;
        }
        if (source["_compareToSourceId"]) {
            this._compareToSourceId = new fhir.FhirElement(source._compareToSourceId);
        }
        if (source["compareToSourcePath"]) {
            this.compareToSourcePath = source.compareToSourcePath;
        }
        if (source["_compareToSourcePath"]) {
            this._compareToSourcePath = new fhir.FhirElement(source._compareToSourcePath);
        }
        if (source["contentType"]) {
            this.contentType = source.contentType;
        }
        if (source["_contentType"]) {
            this._contentType = new fhir.FhirElement(source._contentType);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["direction"]) {
            this.direction = source.direction;
        }
        if (source["_direction"]) {
            this._direction = new fhir.FhirElement(source._direction);
        }
        if (source["expression"]) {
            this.expression = source.expression;
        }
        if (source["_expression"]) {
            this._expression = new fhir.FhirElement(source._expression);
        }
        if (source["headerField"]) {
            this.headerField = source.headerField;
        }
        if (source["_headerField"]) {
            this._headerField = new fhir.FhirElement(source._headerField);
        }
        if (source["label"]) {
            this.label = source.label;
        }
        if (source["_label"]) {
            this._label = new fhir.FhirElement(source._label);
        }
        if (source["minimumId"]) {
            this.minimumId = source.minimumId;
        }
        if (source["_minimumId"]) {
            this._minimumId = new fhir.FhirElement(source._minimumId);
        }
        if (source["navigationLinks"]) {
            this.navigationLinks = source.navigationLinks;
        }
        if (source["_navigationLinks"]) {
            this._navigationLinks = new fhir.FhirElement(source._navigationLinks);
        }
        if (source["operator"]) {
            this.operator = source.operator;
        }
        if (source["_operator"]) {
            this._operator = new fhir.FhirElement(source._operator);
        }
        if (source["path"]) {
            this.path = source.path;
        }
        if (source["_path"]) {
            this._path = new fhir.FhirElement(source._path);
        }
        if (source["requestMethod"]) {
            this.requestMethod = source.requestMethod;
        }
        if (source["_requestMethod"]) {
            this._requestMethod = new fhir.FhirElement(source._requestMethod);
        }
        if (source["requestURL"]) {
            this.requestURL = source.requestURL;
        }
        if (source["_requestURL"]) {
            this._requestURL = new fhir.FhirElement(source._requestURL);
        }
        if (source["resource"]) {
            this.resource = source.resource;
        }
        if (source["_resource"]) {
            this._resource = new fhir.FhirElement(source._resource);
        }
        if (source["response"]) {
            this.response = source.response;
        }
        if (source["_response"]) {
            this._response = new fhir.FhirElement(source._response);
        }
        if (source["responseCode"]) {
            this.responseCode = source.responseCode;
        }
        if (source["_responseCode"]) {
            this._responseCode = new fhir.FhirElement(source._responseCode);
        }
        if (source["sourceId"]) {
            this.sourceId = source.sourceId;
        }
        if (source["_sourceId"]) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
        if (source["validateProfileId"]) {
            this.validateProfileId = source.validateProfileId;
        }
        if (source["_validateProfileId"]) {
            this._validateProfileId = new fhir.FhirElement(source._validateProfileId);
        }
        if (source["value"]) {
            this.value = source.value;
        }
        if (source["_value"]) {
            this._value = new fhir.FhirElement(source._value);
        }
        this.warningOnly = null;
        if (source["warningOnly"]) {
            this.warningOnly = source.warningOnly;
        }
        if (this.warningOnly === undefined) {
            this.warningOnly = null;
        }
        if (source["_warningOnly"]) {
            this._warningOnly = new fhir.FhirElement(source._warningOnly);
        }
    }
    /**
     * Check if the current TestScriptSetupActionAssert contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["warningOnly"] === undefined) {
            missingElements.push("warningOnly");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptSetupActionAssert from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptSetupActionAssert(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptSetupActionAssert is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptSetupAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["assert"]) {
            this.assert = new fhir.TestScriptSetupActionAssert(source.assert);
        }
        if (source["operation"]) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
    }
    /**
     * Check if the current TestScriptSetupAction contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptSetupAction from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptSetupAction(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptSetupAction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A series of required setup operations before tests are executed.
 */
export class TestScriptSetup extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.action = null;
        if (source["action"]) {
            this.action = source.action.map((x) => new fhir.TestScriptSetupAction(x));
        }
        if (this.action === undefined) {
            this.action = null;
        }
    }
    /**
     * Check if the current TestScriptSetup contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["action"]) || (this["action"].length === 0)) {
            missingElements.push("action");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptSetup from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptSetup(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptSetup is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptTestAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTestAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source["assert"]) {
            this.assert = new fhir.TestScriptSetupActionAssert(source.assert);
        }
        if (source["operation"]) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
    }
    /**
     * Check if the current TestScriptTestAction contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptTestAction from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptTestAction(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptTestAction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A test in this script.
 */
export class TestScriptTest extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.action = null;
        if (source["action"]) {
            this.action = source.action.map((x) => new fhir.TestScriptTestAction(x));
        }
        if (this.action === undefined) {
            this.action = null;
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["name"]) {
            this.name = source.name;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
    }
    /**
     * Check if the current TestScriptTest contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["action"]) || (this["action"].length === 0)) {
            missingElements.push("action");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptTest from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptTest(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptTest is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptTeardownAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTeardownAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.operation = null;
        if (source["operation"]) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        if (this.operation === undefined) {
            this.operation = null;
        }
    }
    /**
     * Check if the current TestScriptTeardownAction contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["operation"] === undefined) {
            missingElements.push("operation");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptTeardownAction from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptTeardownAction(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptTeardownAction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A series of operations required to clean up after all the tests are executed (successfully or otherwise).
 */
export class TestScriptTeardown extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTeardown - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.action = null;
        if (source["action"]) {
            this.action = source.action.map((x) => new fhir.TestScriptTeardownAction(x));
        }
        if (this.action === undefined) {
            this.action = null;
        }
    }
    /**
     * Check if the current TestScriptTeardown contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if ((!this["action"]) || (this["action"].length === 0)) {
            missingElements.push("action");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScriptTeardown from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScriptTeardown(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScriptTeardown is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification.
 */
export class TestScript extends fhir.DomainResource {
    /**
     * Default constructor for TestScript - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'TestScript';
        if (source["contact"]) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source["copyright"]) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"]) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source["date"]) {
            this.date = source.date;
        }
        if (source["_date"]) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source["description"]) {
            this.description = source.description;
        }
        if (source["_description"]) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source["destination"]) {
            this.destination = source.destination.map((x) => new fhir.TestScriptDestination(x));
        }
        if (source["experimental"]) {
            this.experimental = source.experimental;
        }
        if (source["_experimental"]) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source["fixture"]) {
            this.fixture = source.fixture.map((x) => new fhir.TestScriptFixture(x));
        }
        if (source["identifier"]) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source["jurisdiction"]) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source["metadata"]) {
            this.metadata = new fhir.TestScriptMetadata(source.metadata);
        }
        this.name = null;
        if (source["name"]) {
            this.name = source.name;
        }
        if (this.name === undefined) {
            this.name = null;
        }
        if (source["_name"]) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source["origin"]) {
            this.origin = source.origin.map((x) => new fhir.TestScriptOrigin(x));
        }
        if (source["profile"]) {
            this.profile = source.profile.map((x) => new fhir.Reference(x));
        }
        if (source["publisher"]) {
            this.publisher = source.publisher;
        }
        if (source["_publisher"]) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source["purpose"]) {
            this.purpose = source.purpose;
        }
        if (source["_purpose"]) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source["setup"]) {
            this.setup = new fhir.TestScriptSetup(source.setup);
        }
        this.status = null;
        if (source["status"]) {
            this.status = source.status;
        }
        if (this.status === undefined) {
            this.status = null;
        }
        if (source["_status"]) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source["teardown"]) {
            this.teardown = new fhir.TestScriptTeardown(source.teardown);
        }
        if (source["test"]) {
            this.test = source.test.map((x) => new fhir.TestScriptTest(x));
        }
        if (source["title"]) {
            this.title = source.title;
        }
        if (source["_title"]) {
            this._title = new fhir.FhirElement(source._title);
        }
        this.url = null;
        if (source["url"]) {
            this.url = source.url;
        }
        if (this.url === undefined) {
            this.url = null;
        }
        if (source["_url"]) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source["useContext"]) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source["variable"]) {
            this.variable = source.variable.map((x) => new fhir.TestScriptVariable(x));
        }
        if (source["version"]) {
            this.version = source.version;
        }
        if (source["_version"]) {
            this._version = new fhir.FhirElement(source._version);
        }
    }
    /**
     * Check if the current TestScript contains all required elements.
     */
    CheckRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        if (this["url"] === undefined) {
            missingElements.push("url");
        }
        var parentMissing = super.CheckRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
    /**
     * Factory function to create a TestScript from an object that MUST contain all required elements.
     */
    static FromStrict(source) {
        var dest = new TestScript(source);
        var missingElements = dest.CheckRequiredElements();
        if (missingElements.length !== 0) {
            throw `TestScript is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
}
/**
 * Code Values for the TestScript.setup.action.operation.method field
 */
export var TestScriptSetupActionOperationMethodEnum;
(function (TestScriptSetupActionOperationMethodEnum) {
    TestScriptSetupActionOperationMethodEnum["DELETE"] = "delete";
    TestScriptSetupActionOperationMethodEnum["GET"] = "get";
    TestScriptSetupActionOperationMethodEnum["OPTIONS"] = "options";
    TestScriptSetupActionOperationMethodEnum["PATCH"] = "patch";
    TestScriptSetupActionOperationMethodEnum["POST"] = "post";
    TestScriptSetupActionOperationMethodEnum["PUT"] = "put";
    TestScriptSetupActionOperationMethodEnum["HEAD"] = "head";
})(TestScriptSetupActionOperationMethodEnum || (TestScriptSetupActionOperationMethodEnum = {}));
/**
 * Code Values for the TestScript.setup.action.assert.direction field
 */
export var TestScriptSetupActionAssertDirectionEnum;
(function (TestScriptSetupActionAssertDirectionEnum) {
    TestScriptSetupActionAssertDirectionEnum["RESPONSE"] = "response";
    TestScriptSetupActionAssertDirectionEnum["REQUEST"] = "request";
})(TestScriptSetupActionAssertDirectionEnum || (TestScriptSetupActionAssertDirectionEnum = {}));
/**
 * Code Values for the TestScript.setup.action.assert.operator field
 */
export var TestScriptSetupActionAssertOperatorEnum;
(function (TestScriptSetupActionAssertOperatorEnum) {
    TestScriptSetupActionAssertOperatorEnum["EQUALS"] = "equals";
    TestScriptSetupActionAssertOperatorEnum["NOTEQUALS"] = "notEquals";
    TestScriptSetupActionAssertOperatorEnum["IN"] = "in";
    TestScriptSetupActionAssertOperatorEnum["NOTIN"] = "notIn";
    TestScriptSetupActionAssertOperatorEnum["GREATERTHAN"] = "greaterThan";
    TestScriptSetupActionAssertOperatorEnum["LESSTHAN"] = "lessThan";
    TestScriptSetupActionAssertOperatorEnum["EMPTY"] = "empty";
    TestScriptSetupActionAssertOperatorEnum["NOTEMPTY"] = "notEmpty";
    TestScriptSetupActionAssertOperatorEnum["CONTAINS"] = "contains";
    TestScriptSetupActionAssertOperatorEnum["NOTCONTAINS"] = "notContains";
    TestScriptSetupActionAssertOperatorEnum["EVAL"] = "eval";
})(TestScriptSetupActionAssertOperatorEnum || (TestScriptSetupActionAssertOperatorEnum = {}));
/**
 * Code Values for the TestScript.setup.action.assert.requestMethod field
 */
export var TestScriptSetupActionAssertRequestMethodEnum;
(function (TestScriptSetupActionAssertRequestMethodEnum) {
    TestScriptSetupActionAssertRequestMethodEnum["DELETE"] = "delete";
    TestScriptSetupActionAssertRequestMethodEnum["GET"] = "get";
    TestScriptSetupActionAssertRequestMethodEnum["OPTIONS"] = "options";
    TestScriptSetupActionAssertRequestMethodEnum["PATCH"] = "patch";
    TestScriptSetupActionAssertRequestMethodEnum["POST"] = "post";
    TestScriptSetupActionAssertRequestMethodEnum["PUT"] = "put";
    TestScriptSetupActionAssertRequestMethodEnum["HEAD"] = "head";
})(TestScriptSetupActionAssertRequestMethodEnum || (TestScriptSetupActionAssertRequestMethodEnum = {}));
/**
 * Code Values for the TestScript.setup.action.assert.response field
 */
export var TestScriptSetupActionAssertResponseEnum;
(function (TestScriptSetupActionAssertResponseEnum) {
    TestScriptSetupActionAssertResponseEnum["OKAY"] = "okay";
    TestScriptSetupActionAssertResponseEnum["CREATED"] = "created";
    TestScriptSetupActionAssertResponseEnum["NOCONTENT"] = "noContent";
    TestScriptSetupActionAssertResponseEnum["NOTMODIFIED"] = "notModified";
    TestScriptSetupActionAssertResponseEnum["BAD"] = "bad";
    TestScriptSetupActionAssertResponseEnum["FORBIDDEN"] = "forbidden";
    TestScriptSetupActionAssertResponseEnum["NOTFOUND"] = "notFound";
    TestScriptSetupActionAssertResponseEnum["METHODNOTALLOWED"] = "methodNotAllowed";
    TestScriptSetupActionAssertResponseEnum["CONFLICT"] = "conflict";
    TestScriptSetupActionAssertResponseEnum["GONE"] = "gone";
    TestScriptSetupActionAssertResponseEnum["PRECONDITIONFAILED"] = "preconditionFailed";
    TestScriptSetupActionAssertResponseEnum["UNPROCESSABLE"] = "unprocessable";
})(TestScriptSetupActionAssertResponseEnum || (TestScriptSetupActionAssertResponseEnum = {}));
/**
 * Code Values for the TestScript.status field
 */
export var TestScriptStatusEnum;
(function (TestScriptStatusEnum) {
    TestScriptStatusEnum["DRAFT"] = "draft";
    TestScriptStatusEnum["ACTIVE"] = "active";
    TestScriptStatusEnum["RETIRED"] = "retired";
    TestScriptStatusEnum["UNKNOWN"] = "unknown";
})(TestScriptStatusEnum || (TestScriptStatusEnum = {}));
//# sourceMappingURL=TestScript.js.map