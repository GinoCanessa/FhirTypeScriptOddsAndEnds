// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: TestScript
import * as fhir from '../fhir.js';
import { TestscriptProfileOriginTypesValueSet } from '../fhirValueSets/TestscriptProfileOriginTypesValueSet.js';
import { TestscriptProfileDestinationTypesValueSet } from '../fhirValueSets/TestscriptProfileDestinationTypesValueSet.js';
import { TestscriptOperationCodesValueSet } from '../fhirValueSets/TestscriptOperationCodesValueSet.js';
import { DefinedTypesValueSet } from '../fhirValueSets/DefinedTypesValueSet.js';
import { HttpOperationsValueSet } from '../fhirValueSets/HttpOperationsValueSet.js';
import { AssertDirectionCodesValueSet } from '../fhirValueSets/AssertDirectionCodesValueSet.js';
import { AssertOperatorCodesValueSet } from '../fhirValueSets/AssertOperatorCodesValueSet.js';
import { AssertResponseCodeTypesValueSet } from '../fhirValueSets/AssertResponseCodeTypesValueSet.js';
import { PublicationStatusValueSet } from '../fhirValueSets/PublicationStatusValueSet.js';
/**
 * The purpose of this element is to define the profile of an origin element used elsewhere in the script.  Test engines could then use the origin-profile mapping to offer a filtered list of test systems that can serve as the sender for the interaction.
 */
export class TestScriptOrigin extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptOrigin - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['index']) {
            this.index = source.index;
        }
        else {
            this.index = null;
        }
        if (source['_index']) {
            this._index = new fhir.FhirElement(source._index);
        }
        if (source['profile']) {
            this.profile = new fhir.Coding(source.profile);
        }
        else {
            this.profile = null;
        }
    }
    /**
     * Extensible-bound Value Set for profile
     */
    static profileExtensibleValueSet() {
        return TestscriptProfileOriginTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["index"]) {
            results.push(["index", 'Missing required element: TestScript.origin.index']);
        }
        if (this["_index"]) {
            results.push(...this._index.doModelValidation());
        }
        if (!this["profile"]) {
            results.push(["profile", 'Missing required element: TestScript.origin.profile']);
        }
        if (this["profile"]) {
            results.push(...this.profile.doModelValidation());
        }
        return results;
    }
}
/**
 * The purpose of this element is to define the profile of a destination element used elsewhere in the script.  Test engines could then use the destination-profile mapping to offer a filtered list of test systems that can serve as the receiver for the interaction.
 */
export class TestScriptDestination extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptDestination - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['index']) {
            this.index = source.index;
        }
        else {
            this.index = null;
        }
        if (source['_index']) {
            this._index = new fhir.FhirElement(source._index);
        }
        if (source['profile']) {
            this.profile = new fhir.Coding(source.profile);
        }
        else {
            this.profile = null;
        }
    }
    /**
     * Extensible-bound Value Set for profile
     */
    static profileExtensibleValueSet() {
        return TestscriptProfileDestinationTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["index"]) {
            results.push(["index", 'Missing required element: TestScript.destination.index']);
        }
        if (this["_index"]) {
            results.push(...this._index.doModelValidation());
        }
        if (!this["profile"]) {
            results.push(["profile", 'Missing required element: TestScript.destination.profile']);
        }
        if (this["profile"]) {
            results.push(...this.profile.doModelValidation());
        }
        return results;
    }
}
/**
 * A link to the FHIR specification that this test is covering.
 */
export class TestScriptMetadataLink extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadataLink - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['url']) {
            this.url = source.url;
        }
        else {
            this.url = null;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["url"]) {
            results.push(["url", 'Missing required element: TestScript.metadata.link.url']);
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        return results;
    }
}
/**
 * When the metadata capabilities section is defined at TestScript.metadata or at TestScript.setup.metadata, and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then all the tests in the TestScript are skipped.  When the metadata capabilities section is defined at TestScript.test.metadata and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then only that test is skipped.  The "metadata.capabilities.required" and "metadata.capabilities.validated" elements only indicate whether the capabilities are the primary focus of the test script or not.  They do not impact the skipping logic.  Capabilities whose "metadata.capabilities.validated" flag is true are the primary focus of the test script.
 */
export class TestScriptMetadataCapability extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadataCapability - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['required']) {
            this.required = source.required;
        }
        else {
            this.required = null;
        }
        if (source['_required']) {
            this._required = new fhir.FhirElement(source._required);
        }
        if (source['validated']) {
            this.validated = source.validated;
        }
        else {
            this.validated = null;
        }
        if (source['_validated']) {
            this._validated = new fhir.FhirElement(source._validated);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['origin']) {
            this.origin = source.origin.map((x) => (x));
        }
        if (source['_origin']) {
            this._origin = source._origin.map((x) => new fhir.FhirElement(x));
        }
        if (source['destination']) {
            this.destination = source.destination;
        }
        if (source['_destination']) {
            this._destination = new fhir.FhirElement(source._destination);
        }
        if (source['link']) {
            this.link = source.link.map((x) => (x));
        }
        if (source['_link']) {
            this._link = source._link.map((x) => new fhir.FhirElement(x));
        }
        if (source['capabilities']) {
            this.capabilities = source.capabilities;
        }
        else {
            this.capabilities = null;
        }
        if (source['_capabilities']) {
            this._capabilities = new fhir.FhirElement(source._capabilities);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["required"]) {
            results.push(["required", 'Missing required element: TestScript.metadata.capability.required']);
        }
        if (this["_required"]) {
            results.push(...this._required.doModelValidation());
        }
        if (!this["validated"]) {
            results.push(["validated", 'Missing required element: TestScript.metadata.capability.validated']);
        }
        if (this["_validated"]) {
            results.push(...this._validated.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["_origin"]) {
            this._origin.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_destination"]) {
            results.push(...this._destination.doModelValidation());
        }
        if (this["_link"]) {
            this._link.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (!this["capabilities"]) {
            results.push(["capabilities", 'Missing required element: TestScript.metadata.capability.capabilities']);
        }
        if (this["_capabilities"]) {
            results.push(...this._capabilities.doModelValidation());
        }
        return results;
    }
}
/**
 * The required capability must exist and are assumed to function correctly on the FHIR server being tested.
 */
export class TestScriptMetadata extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadata - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['link']) {
            this.link = source.link.map((x) => new fhir.TestScriptMetadataLink(x));
        }
        if (source['capability']) {
            this.capability = source.capability.map((x) => new fhir.TestScriptMetadataCapability(x));
        }
        else {
            this.capability = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["link"]) {
            this.link.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if ((!this["capability"]) || (this["capability"].length === 0)) {
            results.push(["capability", 'Missing required element: TestScript.metadata.capability']);
        }
        if (this["capability"]) {
            this.capability.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
 */
export class TestScriptFixture extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptFixture - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['autocreate']) {
            this.autocreate = source.autocreate;
        }
        else {
            this.autocreate = null;
        }
        if (source['_autocreate']) {
            this._autocreate = new fhir.FhirElement(source._autocreate);
        }
        if (source['autodelete']) {
            this.autodelete = source.autodelete;
        }
        else {
            this.autodelete = null;
        }
        if (source['_autodelete']) {
            this._autodelete = new fhir.FhirElement(source._autodelete);
        }
        if (source['resource']) {
            this.resource = new fhir.Reference(source.resource);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["autocreate"]) {
            results.push(["autocreate", 'Missing required element: TestScript.fixture.autocreate']);
        }
        if (this["_autocreate"]) {
            results.push(...this._autocreate.doModelValidation());
        }
        if (!this["autodelete"]) {
            results.push(["autodelete", 'Missing required element: TestScript.fixture.autodelete']);
        }
        if (this["_autodelete"]) {
            results.push(...this._autodelete.doModelValidation());
        }
        if (this["resource"]) {
            results.push(...this.resource.doModelValidation());
        }
        return results;
    }
}
/**
 * Variables would be set based either on XPath/JSONPath expressions against fixtures (static and response), or headerField evaluations against response headers. If variable evaluates to nodelist or anything other than a primitive value, then test engine would report an error.  Variables would be used to perform clean replacements in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations. This limits the places that test engines would need to look for placeholders "${}".  Variables are scoped to the whole script. They are NOT evaluated at declaration. They are evaluated by test engine when used for substitutions in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations.  See example testscript-search.xml.
 */
export class TestScriptVariable extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptVariable - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['defaultValue']) {
            this.defaultValue = source.defaultValue;
        }
        if (source['_defaultValue']) {
            this._defaultValue = new fhir.FhirElement(source._defaultValue);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['expression']) {
            this.expression = source.expression;
        }
        if (source['_expression']) {
            this._expression = new fhir.FhirElement(source._expression);
        }
        if (source['headerField']) {
            this.headerField = source.headerField;
        }
        if (source['_headerField']) {
            this._headerField = new fhir.FhirElement(source._headerField);
        }
        if (source['hint']) {
            this.hint = source.hint;
        }
        if (source['_hint']) {
            this._hint = new fhir.FhirElement(source._hint);
        }
        if (source['path']) {
            this.path = source.path;
        }
        if (source['_path']) {
            this._path = new fhir.FhirElement(source._path);
        }
        if (source['sourceId']) {
            this.sourceId = source.sourceId;
        }
        if (source['_sourceId']) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["name"]) {
            results.push(["name", 'Missing required element: TestScript.variable.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_defaultValue"]) {
            results.push(...this._defaultValue.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["_expression"]) {
            results.push(...this._expression.doModelValidation());
        }
        if (this["_headerField"]) {
            results.push(...this._headerField.doModelValidation());
        }
        if (this["_hint"]) {
            results.push(...this._hint.doModelValidation());
        }
        if (this["_path"]) {
            results.push(...this._path.doModelValidation());
        }
        if (this["_sourceId"]) {
            results.push(...this._sourceId.doModelValidation());
        }
        return results;
    }
}
/**
 * This gives control to test-script writers to set headers explicitly based on test requirements.  It will allow for testing using:  - "If-Modified-Since" and "If-None-Match" headers.  See http://build.fhir.org/http.html#2.1.0.5.1 - "If-Match" header.  See http://build.fhir.org/http.html#2.1.0.11 - Conditional Create using "If-None-Exist".  See http://build.fhir.org/http.html#2.1.0.13.1 - Invalid "Content-Type" header for negative testing. - etc.
 */
export class TestScriptSetupActionOperationRequestHeader extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionOperationRequestHeader - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['field']) {
            this.field = source.field;
        }
        else {
            this.field = null;
        }
        if (source['_field']) {
            this._field = new fhir.FhirElement(source._field);
        }
        if (source['value']) {
            this.value = source.value;
        }
        else {
            this.value = null;
        }
        if (source['_value']) {
            this._value = new fhir.FhirElement(source._value);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["field"]) {
            results.push(["field", 'Missing required element: TestScript.setup.action.operation.requestHeader.field']);
        }
        if (this["_field"]) {
            results.push(...this._field.doModelValidation());
        }
        if (!this["value"]) {
            results.push(["value", 'Missing required element: TestScript.setup.action.operation.requestHeader.value']);
        }
        if (this["_value"]) {
            results.push(...this._value.doModelValidation());
        }
        return results;
    }
}
/**
 * The operation to perform.
 */
export class TestScriptSetupActionOperation extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        if (source['resource']) {
            this.resource = source.resource;
        }
        if (source['_resource']) {
            this._resource = new fhir.FhirElement(source._resource);
        }
        if (source['label']) {
            this.label = source.label;
        }
        if (source['_label']) {
            this._label = new fhir.FhirElement(source._label);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['accept']) {
            this.accept = source.accept;
        }
        if (source['_accept']) {
            this._accept = new fhir.FhirElement(source._accept);
        }
        if (source['contentType']) {
            this.contentType = source.contentType;
        }
        if (source['_contentType']) {
            this._contentType = new fhir.FhirElement(source._contentType);
        }
        if (source['destination']) {
            this.destination = source.destination;
        }
        if (source['_destination']) {
            this._destination = new fhir.FhirElement(source._destination);
        }
        if (source['encodeRequestUrl']) {
            this.encodeRequestUrl = source.encodeRequestUrl;
        }
        else {
            this.encodeRequestUrl = null;
        }
        if (source['_encodeRequestUrl']) {
            this._encodeRequestUrl = new fhir.FhirElement(source._encodeRequestUrl);
        }
        if (source['method']) {
            this.method = source.method;
        }
        if (source['_method']) {
            this._method = new fhir.FhirElement(source._method);
        }
        if (source['origin']) {
            this.origin = source.origin;
        }
        if (source['_origin']) {
            this._origin = new fhir.FhirElement(source._origin);
        }
        if (source['params']) {
            this.params = source.params;
        }
        if (source['_params']) {
            this._params = new fhir.FhirElement(source._params);
        }
        if (source['requestHeader']) {
            this.requestHeader = source.requestHeader.map((x) => new fhir.TestScriptSetupActionOperationRequestHeader(x));
        }
        if (source['requestId']) {
            this.requestId = source.requestId;
        }
        if (source['_requestId']) {
            this._requestId = new fhir.FhirElement(source._requestId);
        }
        if (source['responseId']) {
            this.responseId = source.responseId;
        }
        if (source['_responseId']) {
            this._responseId = new fhir.FhirElement(source._responseId);
        }
        if (source['sourceId']) {
            this.sourceId = source.sourceId;
        }
        if (source['_sourceId']) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
        if (source['targetId']) {
            this.targetId = source.targetId;
        }
        if (source['_targetId']) {
            this._targetId = new fhir.FhirElement(source._targetId);
        }
        if (source['url']) {
            this.url = source.url;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return TestscriptOperationCodesValueSet;
    }
    /**
     * Required-bound Value Set for resource
     */
    static resourceRequiredValueSet() {
        return DefinedTypesValueSet;
    }
    /**
     * Required-bound Value Set for method
     */
    static methodRequiredValueSet() {
        return HttpOperationsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (this["_resource"]) {
            results.push(...this._resource.doModelValidation());
        }
        if (this["_label"]) {
            results.push(...this._label.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["_accept"]) {
            results.push(...this._accept.doModelValidation());
        }
        if (this["_contentType"]) {
            results.push(...this._contentType.doModelValidation());
        }
        if (this["_destination"]) {
            results.push(...this._destination.doModelValidation());
        }
        if (!this["encodeRequestUrl"]) {
            results.push(["encodeRequestUrl", 'Missing required element: TestScript.setup.action.operation.encodeRequestUrl']);
        }
        if (this["_encodeRequestUrl"]) {
            results.push(...this._encodeRequestUrl.doModelValidation());
        }
        if (this["_method"]) {
            results.push(...this._method.doModelValidation());
        }
        if (this["_origin"]) {
            results.push(...this._origin.doModelValidation());
        }
        if (this["_params"]) {
            results.push(...this._params.doModelValidation());
        }
        if (this["requestHeader"]) {
            this.requestHeader.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_requestId"]) {
            results.push(...this._requestId.doModelValidation());
        }
        if (this["_responseId"]) {
            results.push(...this._responseId.doModelValidation());
        }
        if (this["_sourceId"]) {
            results.push(...this._sourceId.doModelValidation());
        }
        if (this["_targetId"]) {
            results.push(...this._targetId.doModelValidation());
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        return results;
    }
}
/**
 * In order to evaluate an assertion, the request, response, and results of the most recently executed operation must always be maintained by the test engine.
 */
export class TestScriptSetupActionAssert extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionAssert - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['label']) {
            this.label = source.label;
        }
        if (source['_label']) {
            this._label = new fhir.FhirElement(source._label);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['direction']) {
            this.direction = source.direction;
        }
        if (source['_direction']) {
            this._direction = new fhir.FhirElement(source._direction);
        }
        if (source['compareToSourceId']) {
            this.compareToSourceId = source.compareToSourceId;
        }
        if (source['_compareToSourceId']) {
            this._compareToSourceId = new fhir.FhirElement(source._compareToSourceId);
        }
        if (source['compareToSourceExpression']) {
            this.compareToSourceExpression = source.compareToSourceExpression;
        }
        if (source['_compareToSourceExpression']) {
            this._compareToSourceExpression = new fhir.FhirElement(source._compareToSourceExpression);
        }
        if (source['compareToSourcePath']) {
            this.compareToSourcePath = source.compareToSourcePath;
        }
        if (source['_compareToSourcePath']) {
            this._compareToSourcePath = new fhir.FhirElement(source._compareToSourcePath);
        }
        if (source['contentType']) {
            this.contentType = source.contentType;
        }
        if (source['_contentType']) {
            this._contentType = new fhir.FhirElement(source._contentType);
        }
        if (source['expression']) {
            this.expression = source.expression;
        }
        if (source['_expression']) {
            this._expression = new fhir.FhirElement(source._expression);
        }
        if (source['headerField']) {
            this.headerField = source.headerField;
        }
        if (source['_headerField']) {
            this._headerField = new fhir.FhirElement(source._headerField);
        }
        if (source['minimumId']) {
            this.minimumId = source.minimumId;
        }
        if (source['_minimumId']) {
            this._minimumId = new fhir.FhirElement(source._minimumId);
        }
        if (source['navigationLinks']) {
            this.navigationLinks = source.navigationLinks;
        }
        if (source['_navigationLinks']) {
            this._navigationLinks = new fhir.FhirElement(source._navigationLinks);
        }
        if (source['operator']) {
            this.operator = source.operator;
        }
        if (source['_operator']) {
            this._operator = new fhir.FhirElement(source._operator);
        }
        if (source['path']) {
            this.path = source.path;
        }
        if (source['_path']) {
            this._path = new fhir.FhirElement(source._path);
        }
        if (source['requestMethod']) {
            this.requestMethod = source.requestMethod;
        }
        if (source['_requestMethod']) {
            this._requestMethod = new fhir.FhirElement(source._requestMethod);
        }
        if (source['requestURL']) {
            this.requestURL = source.requestURL;
        }
        if (source['_requestURL']) {
            this._requestURL = new fhir.FhirElement(source._requestURL);
        }
        if (source['resource']) {
            this.resource = source.resource;
        }
        if (source['_resource']) {
            this._resource = new fhir.FhirElement(source._resource);
        }
        if (source['response']) {
            this.response = source.response;
        }
        if (source['_response']) {
            this._response = new fhir.FhirElement(source._response);
        }
        if (source['responseCode']) {
            this.responseCode = source.responseCode;
        }
        if (source['_responseCode']) {
            this._responseCode = new fhir.FhirElement(source._responseCode);
        }
        if (source['sourceId']) {
            this.sourceId = source.sourceId;
        }
        if (source['_sourceId']) {
            this._sourceId = new fhir.FhirElement(source._sourceId);
        }
        if (source['validateProfileId']) {
            this.validateProfileId = source.validateProfileId;
        }
        if (source['_validateProfileId']) {
            this._validateProfileId = new fhir.FhirElement(source._validateProfileId);
        }
        if (source['value']) {
            this.value = source.value;
        }
        if (source['_value']) {
            this._value = new fhir.FhirElement(source._value);
        }
        if (source['warningOnly']) {
            this.warningOnly = source.warningOnly;
        }
        else {
            this.warningOnly = null;
        }
        if (source['_warningOnly']) {
            this._warningOnly = new fhir.FhirElement(source._warningOnly);
        }
    }
    /**
     * Required-bound Value Set for direction
     */
    static directionRequiredValueSet() {
        return AssertDirectionCodesValueSet;
    }
    /**
     * Required-bound Value Set for operator
     */
    static operatorRequiredValueSet() {
        return AssertOperatorCodesValueSet;
    }
    /**
     * Required-bound Value Set for requestMethod
     */
    static requestMethodRequiredValueSet() {
        return HttpOperationsValueSet;
    }
    /**
     * Required-bound Value Set for resource
     */
    static resourceRequiredValueSet() {
        return DefinedTypesValueSet;
    }
    /**
     * Required-bound Value Set for response
     */
    static responseRequiredValueSet() {
        return AssertResponseCodeTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_label"]) {
            results.push(...this._label.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["_direction"]) {
            results.push(...this._direction.doModelValidation());
        }
        if (this["_compareToSourceId"]) {
            results.push(...this._compareToSourceId.doModelValidation());
        }
        if (this["_compareToSourceExpression"]) {
            results.push(...this._compareToSourceExpression.doModelValidation());
        }
        if (this["_compareToSourcePath"]) {
            results.push(...this._compareToSourcePath.doModelValidation());
        }
        if (this["_contentType"]) {
            results.push(...this._contentType.doModelValidation());
        }
        if (this["_expression"]) {
            results.push(...this._expression.doModelValidation());
        }
        if (this["_headerField"]) {
            results.push(...this._headerField.doModelValidation());
        }
        if (this["_minimumId"]) {
            results.push(...this._minimumId.doModelValidation());
        }
        if (this["_navigationLinks"]) {
            results.push(...this._navigationLinks.doModelValidation());
        }
        if (this["_operator"]) {
            results.push(...this._operator.doModelValidation());
        }
        if (this["_path"]) {
            results.push(...this._path.doModelValidation());
        }
        if (this["_requestMethod"]) {
            results.push(...this._requestMethod.doModelValidation());
        }
        if (this["_requestURL"]) {
            results.push(...this._requestURL.doModelValidation());
        }
        if (this["_resource"]) {
            results.push(...this._resource.doModelValidation());
        }
        if (this["_response"]) {
            results.push(...this._response.doModelValidation());
        }
        if (this["_responseCode"]) {
            results.push(...this._responseCode.doModelValidation());
        }
        if (this["_sourceId"]) {
            results.push(...this._sourceId.doModelValidation());
        }
        if (this["_validateProfileId"]) {
            results.push(...this._validateProfileId.doModelValidation());
        }
        if (this["_value"]) {
            results.push(...this._value.doModelValidation());
        }
        if (!this["warningOnly"]) {
            results.push(["warningOnly", 'Missing required element: TestScript.setup.action.assert.warningOnly']);
        }
        if (this["_warningOnly"]) {
            results.push(...this._warningOnly.doModelValidation());
        }
        return results;
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptSetupAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['operation']) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        if (source['assert']) {
            this.assert = new fhir.TestScriptSetupActionAssert(source.assert);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["operation"]) {
            results.push(...this.operation.doModelValidation());
        }
        if (this["assert"]) {
            results.push(...this.assert.doModelValidation());
        }
        return results;
    }
}
/**
 * A series of required setup operations before tests are executed.
 */
export class TestScriptSetup extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.TestScriptSetupAction(x));
        }
        else {
            this.action = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if ((!this["action"]) || (this["action"].length === 0)) {
            results.push(["action", 'Missing required element: TestScript.setup.action']);
        }
        if (this["action"]) {
            this.action.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptTestAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTestAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['operation']) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        if (source['assert']) {
            this.assert = new fhir.TestScriptSetupActionAssert(source.assert);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["operation"]) {
            results.push(...this.operation.doModelValidation());
        }
        if (this["assert"]) {
            results.push(...this.assert.doModelValidation());
        }
        return results;
    }
}
/**
 * A test in this script.
 */
export class TestScriptTest extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['name']) {
            this.name = source.name;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.TestScriptTestAction(x));
        }
        else {
            this.action = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if ((!this["action"]) || (this["action"].length === 0)) {
            results.push(["action", 'Missing required element: TestScript.test.action']);
        }
        if (this["action"]) {
            this.action.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptTeardownAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTeardownAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['operation']) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        else {
            this.operation = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["operation"]) {
            results.push(["operation", 'Missing required element: TestScript.teardown.action.operation']);
        }
        if (this["operation"]) {
            results.push(...this.operation.doModelValidation());
        }
        return results;
    }
}
/**
 * A series of operations required to clean up after all the tests are executed (successfully or otherwise).
 */
export class TestScriptTeardown extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTeardown - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.TestScriptTeardownAction(x));
        }
        else {
            this.action = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if ((!this["action"]) || (this["action"].length === 0)) {
            results.push(["action", 'Missing required element: TestScript.teardown.action']);
        }
        if (this["action"]) {
            this.action.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
/**
 * A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification.
 */
export class TestScript extends fhir.DomainResource {
    /**
     * Default constructor for TestScript - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'TestScript';
        if (source['url']) {
            this.url = source.url;
        }
        else {
            this.url = null;
        }
        if (source['_url']) {
            this._url = new fhir.FhirElement(source._url);
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['version']) {
            this.version = source.version;
        }
        if (source['_version']) {
            this._version = new fhir.FhirElement(source._version);
        }
        if (source['name']) {
            this.name = source.name;
        }
        else {
            this.name = null;
        }
        if (source['_name']) {
            this._name = new fhir.FhirElement(source._name);
        }
        if (source['title']) {
            this.title = source.title;
        }
        if (source['_title']) {
            this._title = new fhir.FhirElement(source._title);
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['experimental']) {
            this.experimental = source.experimental;
        }
        if (source['_experimental']) {
            this._experimental = new fhir.FhirElement(source._experimental);
        }
        if (source['date']) {
            this.date = source.date;
        }
        if (source['_date']) {
            this._date = new fhir.FhirElement(source._date);
        }
        if (source['publisher']) {
            this.publisher = source.publisher;
        }
        if (source['_publisher']) {
            this._publisher = new fhir.FhirElement(source._publisher);
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = source.description;
        }
        if (source['_description']) {
            this._description = new fhir.FhirElement(source._description);
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = source.purpose;
        }
        if (source['_purpose']) {
            this._purpose = new fhir.FhirElement(source._purpose);
        }
        if (source['copyright']) {
            this.copyright = source.copyright;
        }
        if (source['_copyright']) {
            this._copyright = new fhir.FhirElement(source._copyright);
        }
        if (source['origin']) {
            this.origin = source.origin.map((x) => new fhir.TestScriptOrigin(x));
        }
        if (source['destination']) {
            this.destination = source.destination.map((x) => new fhir.TestScriptDestination(x));
        }
        if (source['metadata']) {
            this.metadata = new fhir.TestScriptMetadata(source.metadata);
        }
        if (source['fixture']) {
            this.fixture = source.fixture.map((x) => new fhir.TestScriptFixture(x));
        }
        if (source['profile']) {
            this.profile = source.profile.map((x) => new fhir.Reference(x));
        }
        if (source['variable']) {
            this.variable = source.variable.map((x) => new fhir.TestScriptVariable(x));
        }
        if (source['setup']) {
            this.setup = new fhir.TestScriptSetup(source.setup);
        }
        if (source['test']) {
            this.test = source.test.map((x) => new fhir.TestScriptTest(x));
        }
        if (source['teardown']) {
            this.teardown = new fhir.TestScriptTeardown(source.teardown);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: TestScript.resourceType']);
        }
        if (!this["url"]) {
            results.push(["url", 'Missing required element: TestScript.url']);
        }
        if (this["_url"]) {
            results.push(...this._url.doModelValidation());
        }
        if (this["identifier"]) {
            results.push(...this.identifier.doModelValidation());
        }
        if (this["_version"]) {
            results.push(...this._version.doModelValidation());
        }
        if (!this["name"]) {
            results.push(["name", 'Missing required element: TestScript.name']);
        }
        if (this["_name"]) {
            results.push(...this._name.doModelValidation());
        }
        if (this["_title"]) {
            results.push(...this._title.doModelValidation());
        }
        if (!this["status"]) {
            results.push(["status", 'Missing required element: TestScript.status']);
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["_experimental"]) {
            results.push(...this._experimental.doModelValidation());
        }
        if (this["_date"]) {
            results.push(...this._date.doModelValidation());
        }
        if (this["_publisher"]) {
            results.push(...this._publisher.doModelValidation());
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_description"]) {
            results.push(...this._description.doModelValidation());
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_purpose"]) {
            results.push(...this._purpose.doModelValidation());
        }
        if (this["_copyright"]) {
            results.push(...this._copyright.doModelValidation());
        }
        if (this["origin"]) {
            this.origin.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["destination"]) {
            this.destination.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["metadata"]) {
            results.push(...this.metadata.doModelValidation());
        }
        if (this["fixture"]) {
            this.fixture.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["profile"]) {
            this.profile.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["variable"]) {
            this.variable.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["setup"]) {
            results.push(...this.setup.doModelValidation());
        }
        if (this["test"]) {
            this.test.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["teardown"]) {
            results.push(...this.teardown.doModelValidation());
        }
        return results;
    }
}
//# sourceMappingURL=TestScript.js.map