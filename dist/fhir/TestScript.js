// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: TestScript
import * as fhir from '../fhir.js';
import { TestscriptProfileOriginTypesValueSet, } from '../fhirValueSets/TestscriptProfileOriginTypesValueSet.js';
import { TestscriptProfileDestinationTypesValueSet, } from '../fhirValueSets/TestscriptProfileDestinationTypesValueSet.js';
import { TestscriptOperationCodesValueSet, } from '../fhirValueSets/TestscriptOperationCodesValueSet.js';
import { DefinedTypesValueSet, } from '../fhirValueSets/DefinedTypesValueSet.js';
import { HttpOperationsValueSet, } from '../fhirValueSets/HttpOperationsValueSet.js';
import { AssertDirectionCodesValueSet, } from '../fhirValueSets/AssertDirectionCodesValueSet.js';
import { AssertOperatorCodesValueSet, } from '../fhirValueSets/AssertOperatorCodesValueSet.js';
import { AssertResponseCodeTypesValueSet, } from '../fhirValueSets/AssertResponseCodeTypesValueSet.js';
import { PublicationStatusValueSet, } from '../fhirValueSets/PublicationStatusValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * The purpose of this element is to define the profile of an origin element used elsewhere in the script.  Test engines could then use the origin-profile mapping to offer a filtered list of test systems that can serve as the sender for the interaction.
 */
export class TestScriptOrigin extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptOrigin - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptOrigin';
        if (source['index']) {
            this.index = new fhir.FhirInteger({ value: source.index });
        }
        else {
            this.index = null;
        }
        if (source['profile']) {
            this.profile = new fhir.Coding(source.profile);
        }
        else {
            this.profile = null;
        }
    }
    /**
     * Extensible-bound Value Set for profile
     */
    static profileExtensibleValueSet() {
        return TestscriptProfileOriginTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['index']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property index:fhir.FhirInteger fhir: TestScript.origin.index:integer", }));
        }
        if (this["index"]) {
            outcome.issue.push(...this.index.doModelValidation().issue);
        }
        if (!this['profile']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property profile:fhir.Coding fhir: TestScript.origin.profile:Coding", }));
        }
        if (this["profile"]) {
            outcome.issue.push(...this.profile.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The purpose of this element is to define the profile of a destination element used elsewhere in the script.  Test engines could then use the destination-profile mapping to offer a filtered list of test systems that can serve as the receiver for the interaction.
 */
export class TestScriptDestination extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptDestination - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptDestination';
        if (source['index']) {
            this.index = new fhir.FhirInteger({ value: source.index });
        }
        else {
            this.index = null;
        }
        if (source['profile']) {
            this.profile = new fhir.Coding(source.profile);
        }
        else {
            this.profile = null;
        }
    }
    /**
     * Extensible-bound Value Set for profile
     */
    static profileExtensibleValueSet() {
        return TestscriptProfileDestinationTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['index']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property index:fhir.FhirInteger fhir: TestScript.destination.index:integer", }));
        }
        if (this["index"]) {
            outcome.issue.push(...this.index.doModelValidation().issue);
        }
        if (!this['profile']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property profile:fhir.Coding fhir: TestScript.destination.profile:Coding", }));
        }
        if (this["profile"]) {
            outcome.issue.push(...this.profile.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A link to the FHIR specification that this test is covering.
 */
export class TestScriptMetadataLink extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadataLink - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptMetadataLink';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: TestScript.metadata.link.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * When the metadata capabilities section is defined at TestScript.metadata or at TestScript.setup.metadata, and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then all the tests in the TestScript are skipped.  When the metadata capabilities section is defined at TestScript.test.metadata and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then only that test is skipped.  The "metadata.capabilities.required" and "metadata.capabilities.validated" elements only indicate whether the capabilities are the primary focus of the test script or not.  They do not impact the skipping logic.  Capabilities whose "metadata.capabilities.validated" flag is true are the primary focus of the test script.
 */
export class TestScriptMetadataCapability extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadataCapability - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptMetadataCapability';
        /**
         * Which origin server these requirements apply to.
         */
        this.origin = [];
        /**
         * Links to the FHIR specification that describes this interaction and the resources involved in more detail.
         */
        this.link = [];
        if (source['required']) {
            this.required = new fhir.FhirBoolean({ value: source.required });
        }
        else {
            this.required = null;
        }
        if (source['validated']) {
            this.validated = new fhir.FhirBoolean({ value: source.validated });
        }
        else {
            this.validated = null;
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['origin']) {
            this.origin = source.origin.map((x) => new fhir.FhirInteger({ value: x }));
        }
        if (source['destination']) {
            this.destination = new fhir.FhirInteger({ value: source.destination });
        }
        if (source['link']) {
            this.link = source.link.map((x) => new fhir.FhirUri({ value: x }));
        }
        if (source['capabilities']) {
            this.capabilities = new fhir.FhirCanonical({ value: source.capabilities });
        }
        else {
            this.capabilities = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['required']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property required:fhir.FhirBoolean fhir: TestScript.metadata.capability.required:boolean", }));
        }
        if (this["required"]) {
            outcome.issue.push(...this.required.doModelValidation().issue);
        }
        if (!this['validated']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property validated:fhir.FhirBoolean fhir: TestScript.metadata.capability.validated:boolean", }));
        }
        if (this["validated"]) {
            outcome.issue.push(...this.validated.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["origin"]) {
            this.origin.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["destination"]) {
            outcome.issue.push(...this.destination.doModelValidation().issue);
        }
        if (this["link"]) {
            this.link.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['capabilities']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property capabilities:fhir.FhirCanonical fhir: TestScript.metadata.capability.capabilities:canonical", }));
        }
        if (this["capabilities"]) {
            outcome.issue.push(...this.capabilities.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The required capability must exist and are assumed to function correctly on the FHIR server being tested.
 */
export class TestScriptMetadata extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptMetadata - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptMetadata';
        /**
         * A link to the FHIR specification that this test is covering.
         */
        this.link = [];
        /**
         * When the metadata capabilities section is defined at TestScript.metadata or at TestScript.setup.metadata, and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then all the tests in the TestScript are skipped.  When the metadata capabilities section is defined at TestScript.test.metadata and the server's conformance statement does not contain the elements defined in the minimal conformance statement, then only that test is skipped.  The "metadata.capabilities.required" and "metadata.capabilities.validated" elements only indicate whether the capabilities are the primary focus of the test script or not.  They do not impact the skipping logic.  Capabilities whose "metadata.capabilities.validated" flag is true are the primary focus of the test script.
         */
        this.capability = [];
        if (source['link']) {
            this.link = source.link.map((x) => new fhir.TestScriptMetadataLink(x));
        }
        if (source['capability']) {
            this.capability = source.capability.map((x) => new fhir.TestScriptMetadataCapability(x));
        }
        else {
            this.capability = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["link"]) {
            this.link.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (!this['capability']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property capability:fhir.TestScriptMetadataCapability[] fhir: TestScript.metadata.capability:capability", }));
        }
        else if (!Array.isArray(this.capability)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property capability:fhir.TestScriptMetadataCapability[] fhir: TestScript.metadata.capability:capability", }));
        }
        else if (this.capability.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property capability:fhir.TestScriptMetadataCapability[] fhir: TestScript.metadata.capability:capability", }));
        }
        if (this["capability"]) {
            this.capability.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
 */
export class TestScriptFixture extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptFixture - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptFixture';
        if (source['autocreate']) {
            this.autocreate = new fhir.FhirBoolean({ value: source.autocreate });
        }
        else {
            this.autocreate = null;
        }
        if (source['autodelete']) {
            this.autodelete = new fhir.FhirBoolean({ value: source.autodelete });
        }
        else {
            this.autodelete = null;
        }
        if (source['resource']) {
            this.resource = new fhir.Reference(source.resource);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['autocreate']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property autocreate:fhir.FhirBoolean fhir: TestScript.fixture.autocreate:boolean", }));
        }
        if (this["autocreate"]) {
            outcome.issue.push(...this.autocreate.doModelValidation().issue);
        }
        if (!this['autodelete']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property autodelete:fhir.FhirBoolean fhir: TestScript.fixture.autodelete:boolean", }));
        }
        if (this["autodelete"]) {
            outcome.issue.push(...this.autodelete.doModelValidation().issue);
        }
        if (this["resource"]) {
            outcome.issue.push(...this.resource.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Variables would be set based either on XPath/JSONPath expressions against fixtures (static and response), or headerField evaluations against response headers. If variable evaluates to nodelist or anything other than a primitive value, then test engine would report an error.  Variables would be used to perform clean replacements in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations. This limits the places that test engines would need to look for placeholders "${}".  Variables are scoped to the whole script. They are NOT evaluated at declaration. They are evaluated by test engine when used for substitutions in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations.  See example testscript-search.xml.
 */
export class TestScriptVariable extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptVariable - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptVariable';
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['defaultValue']) {
            this.defaultValue = new fhir.FhirString({ value: source.defaultValue });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['expression']) {
            this.expression = new fhir.FhirString({ value: source.expression });
        }
        if (source['headerField']) {
            this.headerField = new fhir.FhirString({ value: source.headerField });
        }
        if (source['hint']) {
            this.hint = new fhir.FhirString({ value: source.hint });
        }
        if (source['path']) {
            this.path = new fhir.FhirString({ value: source.path });
        }
        if (source['sourceId']) {
            this.sourceId = new fhir.FhirId({ value: source.sourceId });
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: TestScript.variable.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["defaultValue"]) {
            outcome.issue.push(...this.defaultValue.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        if (this["headerField"]) {
            outcome.issue.push(...this.headerField.doModelValidation().issue);
        }
        if (this["hint"]) {
            outcome.issue.push(...this.hint.doModelValidation().issue);
        }
        if (this["path"]) {
            outcome.issue.push(...this.path.doModelValidation().issue);
        }
        if (this["sourceId"]) {
            outcome.issue.push(...this.sourceId.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * This gives control to test-script writers to set headers explicitly based on test requirements.  It will allow for testing using:  - "If-Modified-Since" and "If-None-Match" headers.  See http://build.fhir.org/http.html#2.1.0.5.1 - "If-Match" header.  See http://build.fhir.org/http.html#2.1.0.11 - Conditional Create using "If-None-Exist".  See http://build.fhir.org/http.html#2.1.0.13.1 - Invalid "Content-Type" header for negative testing. - etc.
 */
export class TestScriptSetupActionOperationRequestHeader extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionOperationRequestHeader - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptSetupActionOperationRequestHeader';
        if (source['field']) {
            this.field = new fhir.FhirString({ value: source.field });
        }
        else {
            this.field = null;
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        else {
            this.value = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['field']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property field:fhir.FhirString fhir: TestScript.setup.action.operation.requestHeader.field:string", }));
        }
        if (this["field"]) {
            outcome.issue.push(...this.field.doModelValidation().issue);
        }
        if (!this['value']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property value:fhir.FhirString fhir: TestScript.setup.action.operation.requestHeader.value:string", }));
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * The operation to perform.
 */
export class TestScriptSetupActionOperation extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionOperation - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptSetupActionOperation';
        /**
         * This gives control to test-script writers to set headers explicitly based on test requirements.  It will allow for testing using:  - "If-Modified-Since" and "If-None-Match" headers.  See http://build.fhir.org/http.html#2.1.0.5.1 - "If-Match" header.  See http://build.fhir.org/http.html#2.1.0.11 - Conditional Create using "If-None-Exist".  See http://build.fhir.org/http.html#2.1.0.13.1 - Invalid "Content-Type" header for negative testing. - etc.
         */
        this.requestHeader = [];
        if (source['type']) {
            this.type = new fhir.Coding(source.type);
        }
        if (source['resource']) {
            this.resource = new fhir.FhirCode({ value: source.resource });
        }
        if (source['label']) {
            this.label = new fhir.FhirString({ value: source.label });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['accept']) {
            this.accept = new fhir.FhirCode({ value: source.accept });
        }
        if (source['contentType']) {
            this.contentType = new fhir.FhirCode({ value: source.contentType });
        }
        if (source['destination']) {
            this.destination = new fhir.FhirInteger({ value: source.destination });
        }
        if (source['encodeRequestUrl']) {
            this.encodeRequestUrl = new fhir.FhirBoolean({ value: source.encodeRequestUrl });
        }
        else {
            this.encodeRequestUrl = null;
        }
        if (source['method']) {
            this.method = source.method;
        }
        if (source['origin']) {
            this.origin = new fhir.FhirInteger({ value: source.origin });
        }
        if (source['params']) {
            this.params = new fhir.FhirString({ value: source.params });
        }
        if (source['requestHeader']) {
            this.requestHeader = source.requestHeader.map((x) => new fhir.TestScriptSetupActionOperationRequestHeader(x));
        }
        if (source['requestId']) {
            this.requestId = new fhir.FhirId({ value: source.requestId });
        }
        if (source['responseId']) {
            this.responseId = new fhir.FhirId({ value: source.responseId });
        }
        if (source['sourceId']) {
            this.sourceId = new fhir.FhirId({ value: source.sourceId });
        }
        if (source['targetId']) {
            this.targetId = new fhir.FhirId({ value: source.targetId });
        }
        if (source['url']) {
            this.url = new fhir.FhirString({ value: source.url });
        }
    }
    /**
     * Extensible-bound Value Set for type
     */
    static typeExtensibleValueSet() {
        return TestscriptOperationCodesValueSet;
    }
    /**
     * Required-bound Value Set for resource
     */
    static resourceRequiredValueSet() {
        return DefinedTypesValueSet;
    }
    /**
     * Required-bound Value Set for method
     */
    static methodRequiredValueSet() {
        return HttpOperationsValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["type"]) {
            outcome.issue.push(...this.type.doModelValidation().issue);
        }
        if (this["resource"]) {
            outcome.issue.push(...this.resource.doModelValidation().issue);
        }
        if (this["label"]) {
            outcome.issue.push(...this.label.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["accept"]) {
            outcome.issue.push(...this.accept.doModelValidation().issue);
        }
        if (this["contentType"]) {
            outcome.issue.push(...this.contentType.doModelValidation().issue);
        }
        if (this["destination"]) {
            outcome.issue.push(...this.destination.doModelValidation().issue);
        }
        if (!this['encodeRequestUrl']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property encodeRequestUrl:fhir.FhirBoolean fhir: TestScript.setup.action.operation.encodeRequestUrl:boolean", }));
        }
        if (this["encodeRequestUrl"]) {
            outcome.issue.push(...this.encodeRequestUrl.doModelValidation().issue);
        }
        if (this["origin"]) {
            outcome.issue.push(...this.origin.doModelValidation().issue);
        }
        if (this["params"]) {
            outcome.issue.push(...this.params.doModelValidation().issue);
        }
        if (this["requestHeader"]) {
            this.requestHeader.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["requestId"]) {
            outcome.issue.push(...this.requestId.doModelValidation().issue);
        }
        if (this["responseId"]) {
            outcome.issue.push(...this.responseId.doModelValidation().issue);
        }
        if (this["sourceId"]) {
            outcome.issue.push(...this.sourceId.doModelValidation().issue);
        }
        if (this["targetId"]) {
            outcome.issue.push(...this.targetId.doModelValidation().issue);
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * In order to evaluate an assertion, the request, response, and results of the most recently executed operation must always be maintained by the test engine.
 */
export class TestScriptSetupActionAssert extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupActionAssert - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptSetupActionAssert';
        if (source['label']) {
            this.label = new fhir.FhirString({ value: source.label });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['direction']) {
            this.direction = source.direction;
        }
        if (source['compareToSourceId']) {
            this.compareToSourceId = new fhir.FhirString({ value: source.compareToSourceId });
        }
        if (source['compareToSourceExpression']) {
            this.compareToSourceExpression = new fhir.FhirString({ value: source.compareToSourceExpression });
        }
        if (source['compareToSourcePath']) {
            this.compareToSourcePath = new fhir.FhirString({ value: source.compareToSourcePath });
        }
        if (source['contentType']) {
            this.contentType = new fhir.FhirCode({ value: source.contentType });
        }
        if (source['expression']) {
            this.expression = new fhir.FhirString({ value: source.expression });
        }
        if (source['headerField']) {
            this.headerField = new fhir.FhirString({ value: source.headerField });
        }
        if (source['minimumId']) {
            this.minimumId = new fhir.FhirString({ value: source.minimumId });
        }
        if (source['navigationLinks']) {
            this.navigationLinks = new fhir.FhirBoolean({ value: source.navigationLinks });
        }
        if (source['operator']) {
            this.operator = source.operator;
        }
        if (source['path']) {
            this.path = new fhir.FhirString({ value: source.path });
        }
        if (source['requestMethod']) {
            this.requestMethod = source.requestMethod;
        }
        if (source['requestURL']) {
            this.requestURL = new fhir.FhirString({ value: source.requestURL });
        }
        if (source['resource']) {
            this.resource = new fhir.FhirCode({ value: source.resource });
        }
        if (source['response']) {
            this.response = source.response;
        }
        if (source['responseCode']) {
            this.responseCode = new fhir.FhirString({ value: source.responseCode });
        }
        if (source['sourceId']) {
            this.sourceId = new fhir.FhirId({ value: source.sourceId });
        }
        if (source['validateProfileId']) {
            this.validateProfileId = new fhir.FhirId({ value: source.validateProfileId });
        }
        if (source['value']) {
            this.value = new fhir.FhirString({ value: source.value });
        }
        if (source['warningOnly']) {
            this.warningOnly = new fhir.FhirBoolean({ value: source.warningOnly });
        }
        else {
            this.warningOnly = null;
        }
    }
    /**
     * Required-bound Value Set for direction
     */
    static directionRequiredValueSet() {
        return AssertDirectionCodesValueSet;
    }
    /**
     * Required-bound Value Set for operator
     */
    static operatorRequiredValueSet() {
        return AssertOperatorCodesValueSet;
    }
    /**
     * Required-bound Value Set for requestMethod
     */
    static requestMethodRequiredValueSet() {
        return HttpOperationsValueSet;
    }
    /**
     * Required-bound Value Set for resource
     */
    static resourceRequiredValueSet() {
        return DefinedTypesValueSet;
    }
    /**
     * Required-bound Value Set for response
     */
    static responseRequiredValueSet() {
        return AssertResponseCodeTypesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["label"]) {
            outcome.issue.push(...this.label.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["compareToSourceId"]) {
            outcome.issue.push(...this.compareToSourceId.doModelValidation().issue);
        }
        if (this["compareToSourceExpression"]) {
            outcome.issue.push(...this.compareToSourceExpression.doModelValidation().issue);
        }
        if (this["compareToSourcePath"]) {
            outcome.issue.push(...this.compareToSourcePath.doModelValidation().issue);
        }
        if (this["contentType"]) {
            outcome.issue.push(...this.contentType.doModelValidation().issue);
        }
        if (this["expression"]) {
            outcome.issue.push(...this.expression.doModelValidation().issue);
        }
        if (this["headerField"]) {
            outcome.issue.push(...this.headerField.doModelValidation().issue);
        }
        if (this["minimumId"]) {
            outcome.issue.push(...this.minimumId.doModelValidation().issue);
        }
        if (this["navigationLinks"]) {
            outcome.issue.push(...this.navigationLinks.doModelValidation().issue);
        }
        if (this["path"]) {
            outcome.issue.push(...this.path.doModelValidation().issue);
        }
        if (this["requestURL"]) {
            outcome.issue.push(...this.requestURL.doModelValidation().issue);
        }
        if (this["resource"]) {
            outcome.issue.push(...this.resource.doModelValidation().issue);
        }
        if (this["responseCode"]) {
            outcome.issue.push(...this.responseCode.doModelValidation().issue);
        }
        if (this["sourceId"]) {
            outcome.issue.push(...this.sourceId.doModelValidation().issue);
        }
        if (this["validateProfileId"]) {
            outcome.issue.push(...this.validateProfileId.doModelValidation().issue);
        }
        if (this["value"]) {
            outcome.issue.push(...this.value.doModelValidation().issue);
        }
        if (!this['warningOnly']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property warningOnly:fhir.FhirBoolean fhir: TestScript.setup.action.assert.warningOnly:boolean", }));
        }
        if (this["warningOnly"]) {
            outcome.issue.push(...this.warningOnly.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptSetupAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetupAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptSetupAction';
        if (source['operation']) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        if (source['assert']) {
            this.assert = new fhir.TestScriptSetupActionAssert(source.assert);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["operation"]) {
            outcome.issue.push(...this.operation.doModelValidation().issue);
        }
        if (this["assert"]) {
            outcome.issue.push(...this.assert.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A series of required setup operations before tests are executed.
 */
export class TestScriptSetup extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptSetup - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptSetup';
        /**
         * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
         */
        this.action = [];
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.TestScriptSetupAction(x));
        }
        else {
            this.action = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['action']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.TestScriptSetupAction[] fhir: TestScript.setup.action:action", }));
        }
        else if (!Array.isArray(this.action)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property action:fhir.TestScriptSetupAction[] fhir: TestScript.setup.action:action", }));
        }
        else if (this.action.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.TestScriptSetupAction[] fhir: TestScript.setup.action:action", }));
        }
        if (this["action"]) {
            this.action.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptTestAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTestAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptTestAction';
        if (source['operation']) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        if (source['assert']) {
            this.assert = new fhir.TestScriptSetupActionAssert(source.assert);
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["operation"]) {
            outcome.issue.push(...this.operation.doModelValidation().issue);
        }
        if (this["assert"]) {
            outcome.issue.push(...this.assert.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A test in this script.
 */
export class TestScriptTest extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTest - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptTest';
        /**
         * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
         */
        this.action = [];
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        if (source['description']) {
            this.description = new fhir.FhirString({ value: source.description });
        }
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.TestScriptTestAction(x));
        }
        else {
            this.action = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (!this['action']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.TestScriptTestAction[] fhir: TestScript.test.action:action", }));
        }
        else if (!Array.isArray(this.action)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property action:fhir.TestScriptTestAction[] fhir: TestScript.test.action:action", }));
        }
        else if (this.action.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.TestScriptTestAction[] fhir: TestScript.test.action:action", }));
        }
        if (this["action"]) {
            this.action.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestScriptTeardownAction extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTeardownAction - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptTeardownAction';
        if (source['operation']) {
            this.operation = new fhir.TestScriptSetupActionOperation(source.operation);
        }
        else {
            this.operation = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['operation']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property operation:fhir.TestScriptSetupActionOperation fhir: TestScript.teardown.action.operation:TestScript.setup.action.operation", }));
        }
        if (this["operation"]) {
            outcome.issue.push(...this.operation.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A series of operations required to clean up after all the tests are executed (successfully or otherwise).
 */
export class TestScriptTeardown extends fhir.BackboneElement {
    /**
     * Default constructor for TestScriptTeardown - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScriptTeardown';
        /**
         * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
         */
        this.action = [];
        if (source['action']) {
            this.action = source.action.map((x) => new fhir.TestScriptTeardownAction(x));
        }
        else {
            this.action = null;
        }
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['action']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.TestScriptTeardownAction[] fhir: TestScript.teardown.action:action", }));
        }
        else if (!Array.isArray(this.action)) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue, diagnostics: "Found scalar in array property action:fhir.TestScriptTeardownAction[] fhir: TestScript.teardown.action:action", }));
        }
        else if (this.action.length === 0) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property action:fhir.TestScriptTeardownAction[] fhir: TestScript.teardown.action:action", }));
        }
        if (this["action"]) {
            this.action.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification.
 */
export class TestScript extends fhir.DomainResource {
    /**
     * Default constructor for TestScript - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'TestScript';
        /**
         * May be a web site, an email address, a telephone number, etc.
         */
        this.contact = [];
        /**
         * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
         */
        this.useContext = [];
        /**
         * It may be possible for the test script to be used in jurisdictions other than those for which it was originally designed or intended.
         */
        this.jurisdiction = [];
        /**
         * The purpose of this element is to define the profile of an origin element used elsewhere in the script.  Test engines could then use the origin-profile mapping to offer a filtered list of test systems that can serve as the sender for the interaction.
         */
        this.origin = [];
        /**
         * The purpose of this element is to define the profile of a destination element used elsewhere in the script.  Test engines could then use the destination-profile mapping to offer a filtered list of test systems that can serve as the receiver for the interaction.
         */
        this.destination = [];
        /**
         * Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
         */
        this.fixture = [];
        /**
         * See http://build.fhir.org/resourcelist.html for complete list of resource types.
         */
        this.profile = [];
        /**
         * Variables would be set based either on XPath/JSONPath expressions against fixtures (static and response), or headerField evaluations against response headers. If variable evaluates to nodelist or anything other than a primitive value, then test engine would report an error.  Variables would be used to perform clean replacements in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations. This limits the places that test engines would need to look for placeholders "${}".  Variables are scoped to the whole script. They are NOT evaluated at declaration. They are evaluated by test engine when used for substitutions in "operation.params", "operation.requestHeader.value", and "operation.url" element values during operation calls and in "assert.value" during assertion evaluations.  See example testscript-search.xml.
         */
        this.variable = [];
        /**
         * A test in this script.
         */
        this.test = [];
        this.resourceType = 'TestScript';
        if (source['url']) {
            this.url = new fhir.FhirUri({ value: source.url });
        }
        else {
            this.url = null;
        }
        if (source['identifier']) {
            this.identifier = new fhir.Identifier(source.identifier);
        }
        if (source['version']) {
            this.version = new fhir.FhirString({ value: source.version });
        }
        if (source['name']) {
            this.name = new fhir.FhirString({ value: source.name });
        }
        else {
            this.name = null;
        }
        if (source['title']) {
            this.title = new fhir.FhirString({ value: source.title });
        }
        if (source['status']) {
            this.status = source.status;
        }
        else {
            this.status = null;
        }
        if (source['experimental']) {
            this.experimental = new fhir.FhirBoolean({ value: source.experimental });
        }
        if (source['date']) {
            this.date = new fhir.FhirDateTime({ value: source.date });
        }
        if (source['publisher']) {
            this.publisher = new fhir.FhirString({ value: source.publisher });
        }
        if (source['contact']) {
            this.contact = source.contact.map((x) => new fhir.ContactDetail(x));
        }
        if (source['description']) {
            this.description = new fhir.FhirMarkdown({ value: source.description });
        }
        if (source['useContext']) {
            this.useContext = source.useContext.map((x) => new fhir.UsageContext(x));
        }
        if (source['jurisdiction']) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['purpose']) {
            this.purpose = new fhir.FhirMarkdown({ value: source.purpose });
        }
        if (source['copyright']) {
            this.copyright = new fhir.FhirMarkdown({ value: source.copyright });
        }
        if (source['origin']) {
            this.origin = source.origin.map((x) => new fhir.TestScriptOrigin(x));
        }
        if (source['destination']) {
            this.destination = source.destination.map((x) => new fhir.TestScriptDestination(x));
        }
        if (source['metadata']) {
            this.metadata = new fhir.TestScriptMetadata(source.metadata);
        }
        if (source['fixture']) {
            this.fixture = source.fixture.map((x) => new fhir.TestScriptFixture(x));
        }
        if (source['profile']) {
            this.profile = source.profile.map((x) => new fhir.Reference(x));
        }
        if (source['variable']) {
            this.variable = source.variable.map((x) => new fhir.TestScriptVariable(x));
        }
        if (source['setup']) {
            this.setup = new fhir.TestScriptSetup(source.setup);
        }
        if (source['test']) {
            this.test = source.test.map((x) => new fhir.TestScriptTest(x));
        }
        if (source['teardown']) {
            this.teardown = new fhir.TestScriptTeardown(source.teardown);
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'TestScript' fhir: TestScript.resourceType:'TestScript'", }));
        }
        if (!this['url']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property url:fhir.FhirUri fhir: TestScript.url:uri", }));
        }
        if (this["url"]) {
            outcome.issue.push(...this.url.doModelValidation().issue);
        }
        if (this["identifier"]) {
            outcome.issue.push(...this.identifier.doModelValidation().issue);
        }
        if (this["version"]) {
            outcome.issue.push(...this.version.doModelValidation().issue);
        }
        if (!this['name']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property name:fhir.FhirString fhir: TestScript.name:string", }));
        }
        if (this["name"]) {
            outcome.issue.push(...this.name.doModelValidation().issue);
        }
        if (this["title"]) {
            outcome.issue.push(...this.title.doModelValidation().issue);
        }
        if (!this['status']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property status:PublicationStatusValueSetEnum fhir: TestScript.status:code", }));
        }
        if (this["experimental"]) {
            outcome.issue.push(...this.experimental.doModelValidation().issue);
        }
        if (this["date"]) {
            outcome.issue.push(...this.date.doModelValidation().issue);
        }
        if (this["publisher"]) {
            outcome.issue.push(...this.publisher.doModelValidation().issue);
        }
        if (this["contact"]) {
            this.contact.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["description"]) {
            outcome.issue.push(...this.description.doModelValidation().issue);
        }
        if (this["useContext"]) {
            this.useContext.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["jurisdiction"]) {
            this.jurisdiction.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["purpose"]) {
            outcome.issue.push(...this.purpose.doModelValidation().issue);
        }
        if (this["copyright"]) {
            outcome.issue.push(...this.copyright.doModelValidation().issue);
        }
        if (this["origin"]) {
            this.origin.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["destination"]) {
            this.destination.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["metadata"]) {
            outcome.issue.push(...this.metadata.doModelValidation().issue);
        }
        if (this["fixture"]) {
            this.fixture.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["profile"]) {
            this.profile.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["variable"]) {
            this.variable.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["setup"]) {
            outcome.issue.push(...this.setup.doModelValidation().issue);
        }
        if (this["test"]) {
            this.test.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["teardown"]) {
            outcome.issue.push(...this.teardown.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=TestScript.js.map