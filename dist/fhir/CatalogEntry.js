// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: CatalogEntry
import * as fhir from '../fhir.js';
import { RelationTypeValueSet } from '../fhirValueSets/RelationTypeValueSet.js';
import { PublicationStatusValueSet } from '../fhirValueSets/PublicationStatusValueSet.js';
/**
 * Used for example, to point to a substance, or to a device used to administer a medication.
 */
export class CatalogEntryRelatedEntry extends fhir.BackboneElement {
    /**
     * Default constructor for CatalogEntryRelatedEntry - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        if (source['relationtype']) {
            this.relationtype = source.relationtype;
        }
        else {
            this.relationtype = null;
        }
        if (source['_relationtype']) {
            this._relationtype = new fhir.FhirElement(source._relationtype);
        }
        if (source['item']) {
            this.item = new fhir.Reference(source.item);
        }
        else {
            this.item = null;
        }
    }
    /**
     * Required-bound Value Set for relationtype
     */
    static relationtypeRequiredValueSet() {
        return RelationTypeValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["relationtype"]) {
            results.push(["relationtype", 'Missing required element: CatalogEntry.relatedEntry.relationtype']);
        }
        if (this["_relationtype"]) {
            results.push(...this._relationtype.doModelValidation());
        }
        if (!this["item"]) {
            results.push(["item", 'Missing required element: CatalogEntry.relatedEntry.item']);
        }
        if (this["item"]) {
            results.push(...this.item.doModelValidation());
        }
        return results;
    }
}
/**
 * Catalog entries are wrappers that contextualize items included in a catalog.
 */
export class CatalogEntry extends fhir.DomainResource {
    /**
     * Default constructor for CatalogEntry - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}) {
        super(source);
        this.resourceType = 'CatalogEntry';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['type']) {
            this.type = new fhir.CodeableConcept(source.type);
        }
        if (source['orderable']) {
            this.orderable = source.orderable;
        }
        else {
            this.orderable = null;
        }
        if (source['_orderable']) {
            this._orderable = new fhir.FhirElement(source._orderable);
        }
        if (source['referencedItem']) {
            this.referencedItem = new fhir.Reference(source.referencedItem);
        }
        else {
            this.referencedItem = null;
        }
        if (source['additionalIdentifier']) {
            this.additionalIdentifier = source.additionalIdentifier.map((x) => new fhir.Identifier(x));
        }
        if (source['classification']) {
            this.classification = source.classification.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['status']) {
            this.status = source.status;
        }
        if (source['_status']) {
            this._status = new fhir.FhirElement(source._status);
        }
        if (source['validityPeriod']) {
            this.validityPeriod = new fhir.Period(source.validityPeriod);
        }
        if (source['validTo']) {
            this.validTo = source.validTo;
        }
        if (source['_validTo']) {
            this._validTo = new fhir.FhirElement(source._validTo);
        }
        if (source['lastUpdated']) {
            this.lastUpdated = source.lastUpdated;
        }
        if (source['_lastUpdated']) {
            this._lastUpdated = new fhir.FhirElement(source._lastUpdated);
        }
        if (source['additionalCharacteristic']) {
            this.additionalCharacteristic = source.additionalCharacteristic.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['additionalClassification']) {
            this.additionalClassification = source.additionalClassification.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['relatedEntry']) {
            this.relatedEntry = source.relatedEntry.map((x) => new fhir.CatalogEntryRelatedEntry(x));
        }
    }
    /**
     * Required-bound Value Set for status
     */
    static statusRequiredValueSet() {
        return PublicationStatusValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var results = super.doModelValidation();
        if (!this["resourceType"]) {
            results.push(["resourceType", 'Missing required element: CatalogEntry.resourceType']);
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["type"]) {
            results.push(...this.type.doModelValidation());
        }
        if (!this["orderable"]) {
            results.push(["orderable", 'Missing required element: CatalogEntry.orderable']);
        }
        if (this["_orderable"]) {
            results.push(...this._orderable.doModelValidation());
        }
        if (!this["referencedItem"]) {
            results.push(["referencedItem", 'Missing required element: CatalogEntry.referencedItem']);
        }
        if (this["referencedItem"]) {
            results.push(...this.referencedItem.doModelValidation());
        }
        if (this["additionalIdentifier"]) {
            this.additionalIdentifier.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["classification"]) {
            this.classification.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["_status"]) {
            results.push(...this._status.doModelValidation());
        }
        if (this["validityPeriod"]) {
            results.push(...this.validityPeriod.doModelValidation());
        }
        if (this["_validTo"]) {
            results.push(...this._validTo.doModelValidation());
        }
        if (this["_lastUpdated"]) {
            results.push(...this._lastUpdated.doModelValidation());
        }
        if (this["additionalCharacteristic"]) {
            this.additionalCharacteristic.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["additionalClassification"]) {
            this.additionalClassification.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        if (this["relatedEntry"]) {
            this.relatedEntry.forEach((x) => { results.push(...x.doModelValidation()); });
        }
        return results;
    }
}
//# sourceMappingURL=CatalogEntry.js.map