// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: RelatedPerson
import * as fhir from '../fhir.js';
import { LanguagesValueSet, } from '../fhirValueSets/LanguagesValueSet.js';
import { RelatedpersonRelationshiptypeValueSet, } from '../fhirValueSets/RelatedpersonRelationshiptypeValueSet.js';
import { AdministrativeGenderValueSet, } from '../fhirValueSets/AdministrativeGenderValueSet.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple RelatedPerson.Communication associations.   If the RelatedPerson does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
 */
export class RelatedPersonCommunication extends fhir.BackboneElement {
    /**
     * Default constructor for RelatedPersonCommunication - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'RelatedPersonCommunication';
        if (source['language']) {
            this.language = new fhir.CodeableConcept(source.language);
        }
        else {
            this.language = null;
        }
        if (source['preferred']) {
            this.preferred = new fhir.FhirBoolean({ value: source.preferred });
        }
    }
    /**
     * Preferred-bound Value Set for language
     */
    static languagePreferredValueSet() {
        return LanguagesValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['language']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property language:fhir.CodeableConcept fhir: RelatedPerson.communication.language:CodeableConcept", }));
        }
        if (this["language"]) {
            outcome.issue.push(...this.language.doModelValidation().issue);
        }
        if (this["preferred"]) {
            outcome.issue.push(...this.preferred.doModelValidation().issue);
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
/**
 * Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
 */
export class RelatedPerson extends fhir.DomainResource {
    /**
     * Default constructor for RelatedPerson - initializes any required elements to null if a value is not provided.
     */
    constructor(source = {}, options = {}) {
        super(source, options);
        this.__dataType = 'RelatedPerson';
        /**
         * Identifier for a person within a particular scope.
         */
        this.identifier = [];
        /**
         * The nature of the relationship between a patient and the related person.
         */
        this.relationship = [];
        /**
         * A name associated with the person.
         */
        this.name = [];
        /**
         * Person may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently, and also to help with identification.
         */
        this.telecom = [];
        /**
         * Address where the related person can be contacted or visited.
         */
        this.address = [];
        /**
         * Image of the person.
         */
        this.photo = [];
        /**
         * If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple RelatedPerson.Communication associations.   If the RelatedPerson does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
         */
        this.communication = [];
        this.resourceType = 'RelatedPerson';
        if (source['identifier']) {
            this.identifier = source.identifier.map((x) => new fhir.Identifier(x));
        }
        if (source['active']) {
            this.active = new fhir.FhirBoolean({ value: source.active });
        }
        if (source['patient']) {
            this.patient = new fhir.Reference(source.patient);
        }
        else {
            this.patient = null;
        }
        if (source['relationship']) {
            this.relationship = source.relationship.map((x) => new fhir.CodeableConcept(x));
        }
        if (source['name']) {
            this.name = source.name.map((x) => new fhir.HumanName(x));
        }
        if (source['telecom']) {
            this.telecom = source.telecom.map((x) => new fhir.ContactPoint(x));
        }
        if (source['gender']) {
            this.gender = source.gender;
        }
        if (source['birthDate']) {
            this.birthDate = new fhir.FhirDate({ value: source.birthDate });
        }
        if (source['address']) {
            this.address = source.address.map((x) => new fhir.Address(x));
        }
        if (source['photo']) {
            this.photo = source.photo.map((x) => new fhir.Attachment(x));
        }
        if (source['period']) {
            this.period = new fhir.Period(source.period);
        }
        if (source['communication']) {
            this.communication = source.communication.map((x) => new fhir.RelatedPersonCommunication(x));
        }
    }
    /**
     * Preferred-bound Value Set for relationship
     */
    static relationshipPreferredValueSet() {
        return RelatedpersonRelationshiptypeValueSet;
    }
    /**
     * Required-bound Value Set for gender
     */
    static genderRequiredValueSet() {
        return AdministrativeGenderValueSet;
    }
    /**
     * Function to perform basic model validation (e.g., check if required elements are present).
     */
    doModelValidation() {
        var outcome = super.doModelValidation();
        if (!this['resourceType']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property resourceType:'RelatedPerson' fhir: RelatedPerson.resourceType:'RelatedPerson'", }));
        }
        if (this["identifier"]) {
            this.identifier.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["active"]) {
            outcome.issue.push(...this.active.doModelValidation().issue);
        }
        if (!this['patient']) {
            outcome.issue.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing, diagnostics: "Missing required property patient:fhir.Reference fhir: RelatedPerson.patient:Reference", }));
        }
        if (this["patient"]) {
            outcome.issue.push(...this.patient.doModelValidation().issue);
        }
        if (this["relationship"]) {
            this.relationship.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["name"]) {
            this.name.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["telecom"]) {
            this.telecom.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["birthDate"]) {
            outcome.issue.push(...this.birthDate.doModelValidation().issue);
        }
        if (this["address"]) {
            this.address.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["photo"]) {
            this.photo.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        if (this["period"]) {
            outcome.issue.push(...this.period.doModelValidation().issue);
        }
        if (this["communication"]) {
            this.communication.forEach((x) => { outcome.issue.push(...x.doModelValidation().issue); });
        }
        return outcome;
    }
    /**
     * Function to strip invalid element values for serialization.
     */
    toJSON() {
        return fhir.fhirToJson(this);
    }
}
//# sourceMappingURL=RelatedPerson.js.map