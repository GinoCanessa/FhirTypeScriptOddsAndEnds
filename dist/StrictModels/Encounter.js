"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncounterStatusEnum = exports.Encounter = exports.EncounterLocationStatusEnum = exports.EncounterLocation = exports.EncounterHospitalization = exports.EncounterDiagnosis = exports.EncounterParticipant = exports.EncounterClassHistory = exports.EncounterStatusHistoryStatusEnum = exports.EncounterStatusHistory = void 0;
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
const fhirModels = __importStar(require("../strictmodels"));
/**
 * The current status is always found in the current version of the resource, not the status history.
 */
class EncounterStatusHistory extends fhirModels.BackboneElement {
    /**
     * Default constructor for EncounterStatusHistory from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        {
            this.period = new fhirModels.Period(source.period);
        }
        {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
    }
}
exports.EncounterStatusHistory = EncounterStatusHistory;
/**
 * Code Values for the Encounter.statusHistory.status field
 */
var EncounterStatusHistoryStatusEnum;
(function (EncounterStatusHistoryStatusEnum) {
    EncounterStatusHistoryStatusEnum["PLANNED"] = "planned";
    EncounterStatusHistoryStatusEnum["ARRIVED"] = "arrived";
    EncounterStatusHistoryStatusEnum["TRIAGED"] = "triaged";
    EncounterStatusHistoryStatusEnum["IN_PROGRESS"] = "in-progress";
    EncounterStatusHistoryStatusEnum["ONLEAVE"] = "onleave";
    EncounterStatusHistoryStatusEnum["FINISHED"] = "finished";
    EncounterStatusHistoryStatusEnum["CANCELLED"] = "cancelled";
    EncounterStatusHistoryStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    EncounterStatusHistoryStatusEnum["UNKNOWN"] = "unknown";
})(EncounterStatusHistoryStatusEnum = exports.EncounterStatusHistoryStatusEnum || (exports.EncounterStatusHistoryStatusEnum = {}));
/**
 * The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
 */
class EncounterClassHistory extends fhirModels.BackboneElement {
    /**
     * Default constructor for EncounterClassHistory from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        {
            this.class = new fhirModels.Coding(source.class);
        }
        {
            this.period = new fhirModels.Period(source.period);
        }
    }
}
exports.EncounterClassHistory = EncounterClassHistory;
/**
 * The list of people responsible for providing the service.
 */
class EncounterParticipant extends fhirModels.BackboneElement {
    /**
     * Default constructor for EncounterParticipant from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["individual"] !== undefined) {
            this.individual = new fhirModels.Reference(source.individual);
        }
        if (source["period"] !== undefined) {
            this.period = new fhirModels.Period(source.period);
        }
        if (source["type"] !== undefined) {
            this.type = source.type.map((x) => new fhirModels.CodeableConcept(x));
        }
    }
}
exports.EncounterParticipant = EncounterParticipant;
/**
 * The list of diagnosis relevant to this encounter.
 */
class EncounterDiagnosis extends fhirModels.BackboneElement {
    /**
     * Default constructor for EncounterDiagnosis from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        {
            this.condition = new fhirModels.Reference(source.condition);
        }
        if (source["rank"] !== undefined) {
            this.rank = source.rank;
        }
        if (source["_rank"] !== undefined) {
            this._rank = new fhirModels.Element(source._rank);
        }
        if (source["use"] !== undefined) {
            this.use = new fhirModels.CodeableConcept(source.use);
        }
    }
}
exports.EncounterDiagnosis = EncounterDiagnosis;
/**
 * An Encounter may cover more than just the inpatient stay. Contexts such as outpatients, community clinics, and aged care facilities are also included.
 * The duration recorded in the period of this encounter covers the entire scope of this hospitalization record.
 */
class EncounterHospitalization extends fhirModels.BackboneElement {
    /**
     * Default constructor for EncounterHospitalization from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["admitSource"] !== undefined) {
            this.admitSource = new fhirModels.CodeableConcept(source.admitSource);
        }
        if (source["destination"] !== undefined) {
            this.destination = new fhirModels.Reference(source.destination);
        }
        if (source["dietPreference"] !== undefined) {
            this.dietPreference = source.dietPreference.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["dischargeDisposition"] !== undefined) {
            this.dischargeDisposition = new fhirModels.CodeableConcept(source.dischargeDisposition);
        }
        if (source["origin"] !== undefined) {
            this.origin = new fhirModels.Reference(source.origin);
        }
        if (source["preAdmissionIdentifier"] !== undefined) {
            this.preAdmissionIdentifier = new fhirModels.Identifier(source.preAdmissionIdentifier);
        }
        if (source["reAdmission"] !== undefined) {
            this.reAdmission = new fhirModels.CodeableConcept(source.reAdmission);
        }
        if (source["specialArrangement"] !== undefined) {
            this.specialArrangement = source.specialArrangement.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["specialCourtesy"] !== undefined) {
            this.specialCourtesy = source.specialCourtesy.map((x) => new fhirModels.CodeableConcept(x));
        }
    }
}
exports.EncounterHospitalization = EncounterHospitalization;
/**
 * Virtual encounters can be recorded in the Encounter by specifying a location reference to a location of type "kind" such as "client's home" and an encounter.class = "virtual".
 */
class EncounterLocation extends fhirModels.BackboneElement {
    /**
     * Default constructor for EncounterLocation from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        {
            this.location = new fhirModels.Reference(source.location);
        }
        if (source["period"] !== undefined) {
            this.period = new fhirModels.Period(source.period);
        }
        if (source["physicalType"] !== undefined) {
            this.physicalType = new fhirModels.CodeableConcept(source.physicalType);
        }
        if (source["status"] !== undefined) {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
    }
}
exports.EncounterLocation = EncounterLocation;
/**
 * Code Values for the Encounter.location.status field
 */
var EncounterLocationStatusEnum;
(function (EncounterLocationStatusEnum) {
    EncounterLocationStatusEnum["PLANNED"] = "planned";
    EncounterLocationStatusEnum["ACTIVE"] = "active";
    EncounterLocationStatusEnum["RESERVED"] = "reserved";
    EncounterLocationStatusEnum["COMPLETED"] = "completed";
})(EncounterLocationStatusEnum = exports.EncounterLocationStatusEnum || (exports.EncounterLocationStatusEnum = {}));
/**
 * An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
 */
class Encounter extends fhirModels.DomainResource {
    /**
     * Default constructor for Encounter from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        /**
         * Resource Type Name
         */
        this.resourceType = "Encounter";
        if ((source['resourceType'] !== "Encounter") || (source['resourceType'] !== undefined)) {
            throw 'Invalid resourceType for a Encounter';
        }
        if (source["account"] !== undefined) {
            this.account = source.account.map((x) => new fhirModels.Reference(x));
        }
        if (source["appointment"] !== undefined) {
            this.appointment = source.appointment.map((x) => new fhirModels.Reference(x));
        }
        if (source["basedOn"] !== undefined) {
            this.basedOn = source.basedOn.map((x) => new fhirModels.Reference(x));
        }
        {
            this.class = new fhirModels.Coding(source.class);
        }
        if (source["classHistory"] !== undefined) {
            this.classHistory = source.classHistory.map((x) => new fhirModels.EncounterClassHistory(x));
        }
        if (source["diagnosis"] !== undefined) {
            this.diagnosis = source.diagnosis.map((x) => new fhirModels.EncounterDiagnosis(x));
        }
        if (source["episodeOfCare"] !== undefined) {
            this.episodeOfCare = source.episodeOfCare.map((x) => new fhirModels.Reference(x));
        }
        if (source["hospitalization"] !== undefined) {
            this.hospitalization = new fhirModels.EncounterHospitalization(source.hospitalization);
        }
        if (source["identifier"] !== undefined) {
            this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x));
        }
        if (source["length"] !== undefined) {
            this.length = new fhirModels.Duration(source.length);
        }
        if (source["location"] !== undefined) {
            this.location = source.location.map((x) => new fhirModels.EncounterLocation(x));
        }
        if (source["participant"] !== undefined) {
            this.participant = source.participant.map((x) => new fhirModels.EncounterParticipant(x));
        }
        if (source["partOf"] !== undefined) {
            this.partOf = new fhirModels.Reference(source.partOf);
        }
        if (source["period"] !== undefined) {
            this.period = new fhirModels.Period(source.period);
        }
        if (source["priority"] !== undefined) {
            this.priority = new fhirModels.CodeableConcept(source.priority);
        }
        if (source["reasonCode"] !== undefined) {
            this.reasonCode = source.reasonCode.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["reasonReference"] !== undefined) {
            this.reasonReference = source.reasonReference.map((x) => new fhirModels.Reference(x));
        }
        if (source["serviceProvider"] !== undefined) {
            this.serviceProvider = new fhirModels.Reference(source.serviceProvider);
        }
        if (source["serviceType"] !== undefined) {
            this.serviceType = new fhirModels.CodeableConcept(source.serviceType);
        }
        {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
        if (source["statusHistory"] !== undefined) {
            this.statusHistory = source.statusHistory.map((x) => new fhirModels.EncounterStatusHistory(x));
        }
        if (source["subject"] !== undefined) {
            this.subject = new fhirModels.Reference(source.subject);
        }
        if (source["type"] !== undefined) {
            this.type = source.type.map((x) => new fhirModels.CodeableConcept(x));
        }
    }
}
exports.Encounter = Encounter;
/**
 * Code Values for the Encounter.status field
 */
var EncounterStatusEnum;
(function (EncounterStatusEnum) {
    EncounterStatusEnum["PLANNED"] = "planned";
    EncounterStatusEnum["ARRIVED"] = "arrived";
    EncounterStatusEnum["TRIAGED"] = "triaged";
    EncounterStatusEnum["IN_PROGRESS"] = "in-progress";
    EncounterStatusEnum["ONLEAVE"] = "onleave";
    EncounterStatusEnum["FINISHED"] = "finished";
    EncounterStatusEnum["CANCELLED"] = "cancelled";
    EncounterStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    EncounterStatusEnum["UNKNOWN"] = "unknown";
})(EncounterStatusEnum = exports.EncounterStatusEnum || (exports.EncounterStatusEnum = {}));
//# sourceMappingURL=Encounter.js.map