"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timing = exports.TimingRepeatPeriodUnitEnum = exports.TimingRepeatDurationUnitEnum = exports.TimingRepeatDayOfWeekEnum = exports.TimingRepeat = void 0;
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
const fhirModels = __importStar(require("../optionalmodels"));
/**
 * A set of rules that describe when the event is scheduled.
 */
class TimingRepeat extends fhirModels.Element {
    /**
     * Default constructor for TimingRepeat from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["boundsDuration"] !== undefined) {
            this.boundsDuration = new fhirModels.Duration(source.boundsDuration);
        }
        if (source["boundsRange"] !== undefined) {
            this.boundsRange = new fhirModels.Range(source.boundsRange);
        }
        if (source["boundsPeriod"] !== undefined) {
            this.boundsPeriod = new fhirModels.Period(source.boundsPeriod);
        }
        if (source["count"] !== undefined) {
            this.count = source.count;
        }
        if (source["_count"] !== undefined) {
            this._count = new fhirModels.Element(source._count);
        }
        if (source["countMax"] !== undefined) {
            this.countMax = source.countMax;
        }
        if (source["_countMax"] !== undefined) {
            this._countMax = new fhirModels.Element(source._countMax);
        }
        if (source["dayOfWeek"] !== undefined) {
            this.dayOfWeek = source.dayOfWeek.map((x) => (x));
        }
        if (source["_dayOfWeek"] !== undefined) {
            this._dayOfWeek = source._dayOfWeek.map((x) => new fhirModels.Element(x));
        }
        if (source["duration"] !== undefined) {
            this.duration = source.duration;
        }
        if (source["_duration"] !== undefined) {
            this._duration = new fhirModels.Element(source._duration);
        }
        if (source["durationMax"] !== undefined) {
            this.durationMax = source.durationMax;
        }
        if (source["_durationMax"] !== undefined) {
            this._durationMax = new fhirModels.Element(source._durationMax);
        }
        if (source["durationUnit"] !== undefined) {
            this.durationUnit = source.durationUnit;
        }
        if (source["_durationUnit"] !== undefined) {
            this._durationUnit = new fhirModels.Element(source._durationUnit);
        }
        if (source["frequency"] !== undefined) {
            this.frequency = source.frequency;
        }
        if (source["_frequency"] !== undefined) {
            this._frequency = new fhirModels.Element(source._frequency);
        }
        if (source["frequencyMax"] !== undefined) {
            this.frequencyMax = source.frequencyMax;
        }
        if (source["_frequencyMax"] !== undefined) {
            this._frequencyMax = new fhirModels.Element(source._frequencyMax);
        }
        if (source["offset"] !== undefined) {
            this.offset = source.offset;
        }
        if (source["_offset"] !== undefined) {
            this._offset = new fhirModels.Element(source._offset);
        }
        if (source["period"] !== undefined) {
            this.period = source.period;
        }
        if (source["_period"] !== undefined) {
            this._period = new fhirModels.Element(source._period);
        }
        if (source["periodMax"] !== undefined) {
            this.periodMax = source.periodMax;
        }
        if (source["_periodMax"] !== undefined) {
            this._periodMax = new fhirModels.Element(source._periodMax);
        }
        if (source["periodUnit"] !== undefined) {
            this.periodUnit = source.periodUnit;
        }
        if (source["_periodUnit"] !== undefined) {
            this._periodUnit = new fhirModels.Element(source._periodUnit);
        }
        if (source["timeOfDay"] !== undefined) {
            this.timeOfDay = source.timeOfDay.map((x) => (x));
        }
        if (source["_timeOfDay"] !== undefined) {
            this._timeOfDay = source._timeOfDay.map((x) => new fhirModels.Element(x));
        }
        if (source["when"] !== undefined) {
            this.when = source.when.map((x) => (x));
        }
        if (source["_when"] !== undefined) {
            this._when = source._when.map((x) => new fhirModels.Element(x));
        }
    }
    /**
     * Factory function to create a TimingRepeat from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new TimingRepeat(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `TimingRepeat is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current TimingRepeat contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.TimingRepeat = TimingRepeat;
/**
 * Code Values for the Timing.repeat.dayOfWeek field
 */
var TimingRepeatDayOfWeekEnum;
(function (TimingRepeatDayOfWeekEnum) {
    TimingRepeatDayOfWeekEnum["MON"] = "mon";
    TimingRepeatDayOfWeekEnum["TUE"] = "tue";
    TimingRepeatDayOfWeekEnum["WED"] = "wed";
    TimingRepeatDayOfWeekEnum["THU"] = "thu";
    TimingRepeatDayOfWeekEnum["FRI"] = "fri";
    TimingRepeatDayOfWeekEnum["SAT"] = "sat";
    TimingRepeatDayOfWeekEnum["SUN"] = "sun";
})(TimingRepeatDayOfWeekEnum = exports.TimingRepeatDayOfWeekEnum || (exports.TimingRepeatDayOfWeekEnum = {}));
/**
 * Code Values for the Timing.repeat.durationUnit field
 */
var TimingRepeatDurationUnitEnum;
(function (TimingRepeatDurationUnitEnum) {
    TimingRepeatDurationUnitEnum["S"] = "s";
    TimingRepeatDurationUnitEnum["MIN"] = "min";
    TimingRepeatDurationUnitEnum["H"] = "h";
    TimingRepeatDurationUnitEnum["D"] = "d";
    TimingRepeatDurationUnitEnum["WK"] = "wk";
    TimingRepeatDurationUnitEnum["MO"] = "mo";
    TimingRepeatDurationUnitEnum["A"] = "a";
})(TimingRepeatDurationUnitEnum = exports.TimingRepeatDurationUnitEnum || (exports.TimingRepeatDurationUnitEnum = {}));
/**
 * Code Values for the Timing.repeat.periodUnit field
 */
var TimingRepeatPeriodUnitEnum;
(function (TimingRepeatPeriodUnitEnum) {
    TimingRepeatPeriodUnitEnum["S"] = "s";
    TimingRepeatPeriodUnitEnum["MIN"] = "min";
    TimingRepeatPeriodUnitEnum["H"] = "h";
    TimingRepeatPeriodUnitEnum["D"] = "d";
    TimingRepeatPeriodUnitEnum["WK"] = "wk";
    TimingRepeatPeriodUnitEnum["MO"] = "mo";
    TimingRepeatPeriodUnitEnum["A"] = "a";
})(TimingRepeatPeriodUnitEnum = exports.TimingRepeatPeriodUnitEnum || (exports.TimingRepeatPeriodUnitEnum = {}));
/**
 * Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 */
class Timing extends fhirModels.BackboneElement {
    /**
     * Default constructor for Timing from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["code"] !== undefined) {
            this.code = new fhirModels.CodeableConcept(source.code);
        }
        if (source["event"] !== undefined) {
            this.event = source.event.map((x) => (x));
        }
        if (source["_event"] !== undefined) {
            this._event = source._event.map((x) => new fhirModels.Element(x));
        }
        if (source["repeat"] !== undefined) {
            this.repeat = new fhirModels.TimingRepeat(source.repeat);
        }
    }
    /**
     * Factory function to create a Timing from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new Timing(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `Timing is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current Timing contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.Timing = Timing;
//# sourceMappingURL=Timing.js.map