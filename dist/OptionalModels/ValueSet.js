"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetStatusEnum = exports.ValueSet = exports.ValueSetExpansion = exports.ValueSetExpansionContains = exports.ValueSetExpansionParameter = exports.ValueSetCompose = exports.ValueSetComposeInclude = exports.ValueSetComposeIncludeFilterOpEnum = exports.ValueSetComposeIncludeFilter = exports.ValueSetComposeIncludeConcept = exports.ValueSetComposeIncludeConceptDesignation = void 0;
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
const fhirModels = __importStar(require("../optionalmodels"));
/**
 * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
 */
class ValueSetComposeIncludeConceptDesignation extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeConceptDesignation from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["language"] !== undefined) {
            this.language = source.language;
        }
        if (source["_language"] !== undefined) {
            this._language = new fhirModels.Element(source._language);
        }
        if (source["use"] !== undefined) {
            this.use = new fhirModels.Coding(source.use);
        }
        if (source["value"] !== undefined) {
            this.value = source.value;
        }
        if (source["_value"] !== undefined) {
            this._value = new fhirModels.Element(source._value);
        }
    }
    /**
     * Factory function to create a ValueSetComposeIncludeConceptDesignation from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetComposeIncludeConceptDesignation(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeIncludeConceptDesignation is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetComposeIncludeConceptDesignation contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["value"] === undefined) {
            missingElements.push("value");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetComposeIncludeConceptDesignation = ValueSetComposeIncludeConceptDesignation;
/**
 * The list of concepts is considered ordered, though the order might not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
 */
class ValueSetComposeIncludeConcept extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeConcept from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["code"] !== undefined) {
            this.code = source.code;
        }
        if (source["_code"] !== undefined) {
            this._code = new fhirModels.Element(source._code);
        }
        if (source["designation"] !== undefined) {
            this.designation = source.designation.map((x) => new fhirModels.ValueSetComposeIncludeConceptDesignation(x));
        }
        if (source["display"] !== undefined) {
            this.display = source.display;
        }
        if (source["_display"] !== undefined) {
            this._display = new fhirModels.Element(source._display);
        }
    }
    /**
     * Factory function to create a ValueSetComposeIncludeConcept from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetComposeIncludeConcept(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeIncludeConcept is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetComposeIncludeConcept contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["code"] === undefined) {
            missingElements.push("code");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetComposeIncludeConcept = ValueSetComposeIncludeConcept;
/**
 * Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
 */
class ValueSetComposeIncludeFilter extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetComposeIncludeFilter from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["op"] !== undefined) {
            this.op = source.op;
        }
        if (source["_op"] !== undefined) {
            this._op = new fhirModels.Element(source._op);
        }
        if (source["property"] !== undefined) {
            this.property = source.property;
        }
        if (source["_property"] !== undefined) {
            this._property = new fhirModels.Element(source._property);
        }
        if (source["value"] !== undefined) {
            this.value = source.value;
        }
        if (source["_value"] !== undefined) {
            this._value = new fhirModels.Element(source._value);
        }
    }
    /**
     * Factory function to create a ValueSetComposeIncludeFilter from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetComposeIncludeFilter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeIncludeFilter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetComposeIncludeFilter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["op"] === undefined) {
            missingElements.push("op");
        }
        if (this["property"] === undefined) {
            missingElements.push("property");
        }
        if (this["value"] === undefined) {
            missingElements.push("value");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetComposeIncludeFilter = ValueSetComposeIncludeFilter;
/**
 * Code Values for the ValueSet.compose.include.filter.op field
 */
var ValueSetComposeIncludeFilterOpEnum;
(function (ValueSetComposeIncludeFilterOpEnum) {
    ValueSetComposeIncludeFilterOpEnum["EQUALS"] = "=";
    ValueSetComposeIncludeFilterOpEnum["IS_A"] = "is-a";
    ValueSetComposeIncludeFilterOpEnum["DESCENDENT_OF"] = "descendent-of";
    ValueSetComposeIncludeFilterOpEnum["IS_NOT_A"] = "is-not-a";
    ValueSetComposeIncludeFilterOpEnum["REGEX"] = "regex";
    ValueSetComposeIncludeFilterOpEnum["IN"] = "in";
    ValueSetComposeIncludeFilterOpEnum["NOT_IN"] = "not-in";
    ValueSetComposeIncludeFilterOpEnum["GENERALIZES"] = "generalizes";
    ValueSetComposeIncludeFilterOpEnum["EXISTS"] = "exists";
})(ValueSetComposeIncludeFilterOpEnum = exports.ValueSetComposeIncludeFilterOpEnum || (exports.ValueSetComposeIncludeFilterOpEnum = {}));
/**
 * All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
 */
class ValueSetComposeInclude extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetComposeInclude from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["concept"] !== undefined) {
            this.concept = source.concept.map((x) => new fhirModels.ValueSetComposeIncludeConcept(x));
        }
        if (source["filter"] !== undefined) {
            this.filter = source.filter.map((x) => new fhirModels.ValueSetComposeIncludeFilter(x));
        }
        if (source["system"] !== undefined) {
            this.system = source.system;
        }
        if (source["_system"] !== undefined) {
            this._system = new fhirModels.Element(source._system);
        }
        if (source["valueSet"] !== undefined) {
            this.valueSet = source.valueSet.map((x) => (x));
        }
        if (source["_valueSet"] !== undefined) {
            this._valueSet = source._valueSet.map((x) => new fhirModels.Element(x));
        }
        if (source["version"] !== undefined) {
            this.version = source.version;
        }
        if (source["_version"] !== undefined) {
            this._version = new fhirModels.Element(source._version);
        }
    }
    /**
     * Factory function to create a ValueSetComposeInclude from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetComposeInclude(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetComposeInclude is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetComposeInclude contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetComposeInclude = ValueSetComposeInclude;
/**
 * A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
 */
class ValueSetCompose extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetCompose from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["exclude"] !== undefined) {
            this.exclude = source.exclude.map((x) => new fhirModels.ValueSetComposeInclude(x));
        }
        if (source["inactive"] !== undefined) {
            this.inactive = source.inactive;
        }
        if (source["_inactive"] !== undefined) {
            this._inactive = new fhirModels.Element(source._inactive);
        }
        if (source["include"] !== undefined) {
            this.include = source.include.map((x) => new fhirModels.ValueSetComposeInclude(x));
        }
        if (source["lockedDate"] !== undefined) {
            this.lockedDate = source.lockedDate;
        }
        if (source["_lockedDate"] !== undefined) {
            this._lockedDate = new fhirModels.Element(source._lockedDate);
        }
    }
    /**
     * Factory function to create a ValueSetCompose from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetCompose(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetCompose is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetCompose contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if ((this["include"] === undefined) || (this["include"].length === 0)) {
            missingElements.push("include");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetCompose = ValueSetCompose;
/**
 * The server decides which parameters to include here, but at a minimum, the list SHOULD include all of the parameters that affect the $expand operation. If the expansion will be persisted all of these parameters SHALL be included. If the codeSystem on the server has a specified version then this version SHALL be provided as a parameter in the expansion (note that not all code systems have a version).
 */
class ValueSetExpansionParameter extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetExpansionParameter from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["name"] !== undefined) {
            this.name = source.name;
        }
        if (source["_name"] !== undefined) {
            this._name = new fhirModels.Element(source._name);
        }
        if (source["valueString"] !== undefined) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"] !== undefined) {
            this._valueString = new fhirModels.Element(source._valueString);
        }
        if (source["valueBoolean"] !== undefined) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"] !== undefined) {
            this._valueBoolean = new fhirModels.Element(source._valueBoolean);
        }
        if (source["valueInteger"] !== undefined) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"] !== undefined) {
            this._valueInteger = new fhirModels.Element(source._valueInteger);
        }
        if (source["valueDecimal"] !== undefined) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"] !== undefined) {
            this._valueDecimal = new fhirModels.Element(source._valueDecimal);
        }
        if (source["valueUri"] !== undefined) {
            this.valueUri = source.valueUri;
        }
        if (source["_valueUri"] !== undefined) {
            this._valueUri = new fhirModels.Element(source._valueUri);
        }
        if (source["valueCode"] !== undefined) {
            this.valueCode = source.valueCode;
        }
        if (source["_valueCode"] !== undefined) {
            this._valueCode = new fhirModels.Element(source._valueCode);
        }
        if (source["valueDateTime"] !== undefined) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source["_valueDateTime"] !== undefined) {
            this._valueDateTime = new fhirModels.Element(source._valueDateTime);
        }
    }
    /**
     * Factory function to create a ValueSetExpansionParameter from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetExpansionParameter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetExpansionParameter is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetExpansionParameter contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["name"] === undefined) {
            missingElements.push("name");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetExpansionParameter = ValueSetExpansionParameter;
/**
 * The codes that are contained in the value set expansion.
 */
class ValueSetExpansionContains extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetExpansionContains from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["abstract"] !== undefined) {
            this.abstract = source.abstract;
        }
        if (source["_abstract"] !== undefined) {
            this._abstract = new fhirModels.Element(source._abstract);
        }
        if (source["code"] !== undefined) {
            this.code = source.code;
        }
        if (source["_code"] !== undefined) {
            this._code = new fhirModels.Element(source._code);
        }
        if (source["contains"] !== undefined) {
            this.contains = source.contains.map((x) => new fhirModels.ValueSetExpansionContains(x));
        }
        if (source["designation"] !== undefined) {
            this.designation = source.designation.map((x) => new fhirModels.ValueSetComposeIncludeConceptDesignation(x));
        }
        if (source["display"] !== undefined) {
            this.display = source.display;
        }
        if (source["_display"] !== undefined) {
            this._display = new fhirModels.Element(source._display);
        }
        if (source["inactive"] !== undefined) {
            this.inactive = source.inactive;
        }
        if (source["_inactive"] !== undefined) {
            this._inactive = new fhirModels.Element(source._inactive);
        }
        if (source["system"] !== undefined) {
            this.system = source.system;
        }
        if (source["_system"] !== undefined) {
            this._system = new fhirModels.Element(source._system);
        }
        if (source["version"] !== undefined) {
            this.version = source.version;
        }
        if (source["_version"] !== undefined) {
            this._version = new fhirModels.Element(source._version);
        }
    }
    /**
     * Factory function to create a ValueSetExpansionContains from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetExpansionContains(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetExpansionContains is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetExpansionContains contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetExpansionContains = ValueSetExpansionContains;
/**
 * Expansion is performed to produce a collection of codes that are ready to use for data entry or validation. Value set expansions are always considered to be stateless - they are a record of the set of codes in the value set at a point in time under a given set of conditions, and are not subject to ongoing maintenance.
 * Expansion.parameter is  a simplified list of parameters - a subset of the features of the [Parameters](parameters.html) resource.
 */
class ValueSetExpansion extends fhirModels.BackboneElement {
    /**
     * Default constructor for ValueSetExpansion from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["contains"] !== undefined) {
            this.contains = source.contains.map((x) => new fhirModels.ValueSetExpansionContains(x));
        }
        if (source["identifier"] !== undefined) {
            this.identifier = source.identifier;
        }
        if (source["_identifier"] !== undefined) {
            this._identifier = new fhirModels.Element(source._identifier);
        }
        if (source["offset"] !== undefined) {
            this.offset = source.offset;
        }
        if (source["_offset"] !== undefined) {
            this._offset = new fhirModels.Element(source._offset);
        }
        if (source["parameter"] !== undefined) {
            this.parameter = source.parameter.map((x) => new fhirModels.ValueSetExpansionParameter(x));
        }
        if (source["timestamp"] !== undefined) {
            this.timestamp = source.timestamp;
        }
        if (source["_timestamp"] !== undefined) {
            this._timestamp = new fhirModels.Element(source._timestamp);
        }
        if (source["total"] !== undefined) {
            this.total = source.total;
        }
        if (source["_total"] !== undefined) {
            this._total = new fhirModels.Element(source._total);
        }
    }
    /**
     * Factory function to create a ValueSetExpansion from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSetExpansion(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSetExpansion is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSetExpansion contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["timestamp"] === undefined) {
            missingElements.push("timestamp");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSetExpansion = ValueSetExpansion;
/**
 * A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
 */
class ValueSet extends fhirModels.DomainResource {
    /**
     * Default constructor for ValueSet from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        /**
         * Resource Type Name
         */
        this.resourceType = "ValueSet";
        if ((source['resourceType'] !== "ValueSet") || (source['resourceType'] !== undefined)) {
            throw 'Invalid resourceType for a ValueSet';
        }
        if (source["compose"] !== undefined) {
            this.compose = new fhirModels.ValueSetCompose(source.compose);
        }
        if (source["contact"] !== undefined) {
            this.contact = source.contact.map((x) => new fhirModels.ContactDetail(x));
        }
        if (source["copyright"] !== undefined) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"] !== undefined) {
            this._copyright = new fhirModels.Element(source._copyright);
        }
        if (source["date"] !== undefined) {
            this.date = source.date;
        }
        if (source["_date"] !== undefined) {
            this._date = new fhirModels.Element(source._date);
        }
        if (source["description"] !== undefined) {
            this.description = source.description;
        }
        if (source["_description"] !== undefined) {
            this._description = new fhirModels.Element(source._description);
        }
        if (source["expansion"] !== undefined) {
            this.expansion = new fhirModels.ValueSetExpansion(source.expansion);
        }
        if (source["experimental"] !== undefined) {
            this.experimental = source.experimental;
        }
        if (source["_experimental"] !== undefined) {
            this._experimental = new fhirModels.Element(source._experimental);
        }
        if (source["identifier"] !== undefined) {
            this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x));
        }
        if (source["immutable"] !== undefined) {
            this.immutable = source.immutable;
        }
        if (source["_immutable"] !== undefined) {
            this._immutable = new fhirModels.Element(source._immutable);
        }
        if (source["jurisdiction"] !== undefined) {
            this.jurisdiction = source.jurisdiction.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["name"] !== undefined) {
            this.name = source.name;
        }
        if (source["_name"] !== undefined) {
            this._name = new fhirModels.Element(source._name);
        }
        if (source["publisher"] !== undefined) {
            this.publisher = source.publisher;
        }
        if (source["_publisher"] !== undefined) {
            this._publisher = new fhirModels.Element(source._publisher);
        }
        if (source["purpose"] !== undefined) {
            this.purpose = source.purpose;
        }
        if (source["_purpose"] !== undefined) {
            this._purpose = new fhirModels.Element(source._purpose);
        }
        if (source["status"] !== undefined) {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
        if (source["title"] !== undefined) {
            this.title = source.title;
        }
        if (source["_title"] !== undefined) {
            this._title = new fhirModels.Element(source._title);
        }
        if (source["url"] !== undefined) {
            this.url = source.url;
        }
        if (source["_url"] !== undefined) {
            this._url = new fhirModels.Element(source._url);
        }
        if (source["useContext"] !== undefined) {
            this.useContext = source.useContext.map((x) => new fhirModels.UsageContext(x));
        }
        if (source["version"] !== undefined) {
            this.version = source.version;
        }
        if (source["_version"] !== undefined) {
            this._version = new fhirModels.Element(source._version);
        }
    }
    /**
     * Factory function to create a ValueSet from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ValueSet(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ValueSet is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ValueSet contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ValueSet = ValueSet;
/**
 * Code Values for the ValueSet.status field
 */
var ValueSetStatusEnum;
(function (ValueSetStatusEnum) {
    ValueSetStatusEnum["DRAFT"] = "draft";
    ValueSetStatusEnum["ACTIVE"] = "active";
    ValueSetStatusEnum["RETIRED"] = "retired";
    ValueSetStatusEnum["UNKNOWN"] = "unknown";
})(ValueSetStatusEnum = exports.ValueSetStatusEnum || (exports.ValueSetStatusEnum = {}));
//# sourceMappingURL=ValueSet.js.map