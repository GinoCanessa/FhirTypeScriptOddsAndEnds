// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../optionalmodels'
import * as fhirInterfaces from '../optionalinterfaces'
/**
 * Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
 */
export class SubstanceInstance extends fhirModels.BackboneElement implements fhirInterfaces.ISubstanceInstance {
  /**
   * When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
   */
  expiry?: string|undefined;
  _expiry?: fhirModels.Element|undefined;
  /**
   * Identifier associated with the package/container (usually a label affixed directly).
   */
  identifier?: fhirModels.Identifier|undefined;
  /**
   * The amount of the substance.
   */
  quantity?: fhirModels.Quantity|undefined;
  /**
   * Default constructor for SubstanceInstance from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.ISubstanceInstance>) {
    super(source);
    if (source["expiry"] !== undefined) { this.expiry = source.expiry; }
    if (source["_expiry"] !== undefined) { this._expiry = new fhirModels.Element(source._expiry); }
    if (source["identifier"] !== undefined) { this.identifier = new fhirModels.Identifier(source.identifier); }
    if (source["quantity"] !== undefined) { this.quantity = new fhirModels.Quantity(source.quantity); }
  }
  /**
   * Factory function to create a SubstanceInstance from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.ISubstanceInstance):SubstanceInstance {
    var dest:SubstanceInstance = new SubstanceInstance(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `SubstanceInstance is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
  /**
   * Check if the current SubstanceInstance contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
}
/**
 * A substance can be composed of other substances.
 */
export class SubstanceIngredient extends fhirModels.BackboneElement implements fhirInterfaces.ISubstanceIngredient {
  /**
   * The amount of the ingredient in the substance - a concentration ratio.
   */
  quantity?: fhirModels.Ratio|undefined;
  /**
   * Another substance that is a component of this substance.
   */
  substanceCodeableConcept?: fhirModels.CodeableConcept|undefined;
  /**
   * Another substance that is a component of this substance.
   */
  substanceReference?: fhirModels.Reference|undefined;
  /**
   * Default constructor for SubstanceIngredient from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.ISubstanceIngredient>) {
    super(source);
    if (source["quantity"] !== undefined) { this.quantity = new fhirModels.Ratio(source.quantity); }
    if (source["substanceCodeableConcept"] !== undefined) { this.substanceCodeableConcept = new fhirModels.CodeableConcept(source.substanceCodeableConcept); }
    if (source["substanceReference"] !== undefined) { this.substanceReference = new fhirModels.Reference(source.substanceReference); }
  }
  /**
   * Factory function to create a SubstanceIngredient from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.ISubstanceIngredient):SubstanceIngredient {
    var dest:SubstanceIngredient = new SubstanceIngredient(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `SubstanceIngredient is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
  /**
   * Check if the current SubstanceIngredient contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
}
/**
 * A homogeneous material with a definite composition.
 */
export class Substance extends fhirModels.DomainResource implements fhirInterfaces.ISubstance {
  /**
   * Resource Type Name
   */
  readonly resourceType = "Substance";
  /**
   * The level of granularity is defined by the category concepts in the value set.   More fine-grained filtering can be performed using the metadata and/or terminology hierarchy in Substance.code.
   */
  category?: fhirModels.CodeableConcept[]|undefined;
  /**
   * This could be a reference to an externally defined code.  It could also be a locally assigned code (e.g. a formulary),  optionally with translations to the standard drug codes.
   */
  code?: fhirModels.CodeableConcept|undefined;
  /**
   * A description of the substance - its appearance, handling requirements, and other usage notes.
   */
  description?: string|undefined;
  _description?: fhirModels.Element|undefined;
  /**
   * This identifier is associated with the kind of substance in contrast to the  Substance.instance.identifier which is associated with the package/container.
   */
  identifier?: fhirModels.Identifier[]|undefined;
  /**
   * A substance can be composed of other substances.
   */
  ingredient?: fhirModels.SubstanceIngredient[]|undefined;
  /**
   * Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
   */
  instance?: fhirModels.SubstanceInstance[]|undefined;
  /**
   * A code to indicate if the substance is actively used.
   */
  status?: SubstanceStatusEnum|undefined;
  _status?: fhirModels.Element|undefined;
  /**
   * Default constructor for Substance from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.ISubstance>) {
    super(source);
    if ((source['resourceType'] !== "Substance") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a Substance'; }
    if (source["category"] !== undefined) { this.category = source.category.map((x) => new fhirModels.CodeableConcept(x)); }
    if (source["code"] !== undefined) { this.code = new fhirModels.CodeableConcept(source.code); }
    if (source["description"] !== undefined) { this.description = source.description; }
    if (source["_description"] !== undefined) { this._description = new fhirModels.Element(source._description); }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x)); }
    if (source["ingredient"] !== undefined) { this.ingredient = source.ingredient.map((x) => new fhirModels.SubstanceIngredient(x)); }
    if (source["instance"] !== undefined) { this.instance = source.instance.map((x) => new fhirModels.SubstanceInstance(x)); }
    if (source["status"] !== undefined) { this.status = source.status; }
    if (source["_status"] !== undefined) { this._status = new fhirModels.Element(source._status); }
  }
  /**
   * Factory function to create a Substance from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.ISubstance):Substance {
    var dest:Substance = new Substance(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `Substance is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
  /**
   * Check if the current Substance contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
}
/**
 * Code Values for the Substance.status field
 */
export enum SubstanceStatusEnum {
  ACTIVE = "active",
  INACTIVE = "inactive",
  ENTERED_IN_ERROR = "entered-in-error",
}
