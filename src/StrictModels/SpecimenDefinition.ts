// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../strictmodels'
import * as fhirInterfaces from '../strictinterfaces'
/**
 * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
 */
export class SpecimenDefinitionTypeTestedContainerAdditive extends fhirModels.BackboneElement implements fhirInterfaces.ISpecimenDefinitionTypeTestedContainerAdditive {
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveCodeableConcept?: fhirModels.CodeableConcept|undefined;
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveReference?: fhirModels.Reference|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTestedContainerAdditive from an object that MAY NOT contain all required elements.
   */
  constructor(source:fhirInterfaces.ISpecimenDefinitionTypeTestedContainerAdditive) {
    super(source);
    if (source["additiveCodeableConcept"] !== undefined) {
      this.additiveCodeableConcept = new fhirModels.CodeableConcept(source.additiveCodeableConcept);
    }
    if (source["additiveReference"] !== undefined) {
      this.additiveReference = new fhirModels.Reference(source.additiveReference);
    }
  }
}
/**
 * The specimen's container.
 */
export class SpecimenDefinitionTypeTestedContainer extends fhirModels.BackboneElement implements fhirInterfaces.ISpecimenDefinitionTypeTestedContainer {
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additive?: fhirModels.SpecimenDefinitionTypeTestedContainerAdditive[]|undefined;
  /**
   * Color of container cap.
   */
  cap?: fhirModels.CodeableConcept|undefined;
  /**
   * The capacity (volume or other measure) of this kind of container.
   */
  capacity?: fhirModels.Quantity|undefined;
  /**
   * The textual description of the kind of container.
   */
  description?: string|undefined;
  _description?: fhirModels.Element|undefined;
  /**
   * The type of material of the container.
   */
  material?: fhirModels.CodeableConcept|undefined;
  /**
   * The minimum volume to be conditioned in the container.
   */
  minimumVolumeQuantity?: fhirModels.Quantity|undefined;
  /**
   * The minimum volume to be conditioned in the container.
   */
  minimumVolumeString?: string|undefined;
  _minimumVolumeString?: fhirModels.Element|undefined;
  /**
   * Special processing that should be applied to the container for this kind of specimen.
   */
  preparation?: string|undefined;
  _preparation?: fhirModels.Element|undefined;
  /**
   * The type of container used to contain this kind of specimen.
   */
  type?: fhirModels.CodeableConcept|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTestedContainer from an object that MAY NOT contain all required elements.
   */
  constructor(source:fhirInterfaces.ISpecimenDefinitionTypeTestedContainer) {
    super(source);
    if (source["additive"] !== undefined) {
      this.additive = source.additive.map((x) => new fhirModels.SpecimenDefinitionTypeTestedContainerAdditive(x));
    }
    if (source["cap"] !== undefined) {
      this.cap = new fhirModels.CodeableConcept(source.cap);
    }
    if (source["capacity"] !== undefined) {
      this.capacity = new fhirModels.Quantity(source.capacity);
    }
    if (source["description"] !== undefined) {
      this.description = source.description;
    }
    if (source["_description"] !== undefined) {
      this._description = new fhirModels.Element(source._description);
    }
    if (source["material"] !== undefined) {
      this.material = new fhirModels.CodeableConcept(source.material);
    }
    if (source["minimumVolumeQuantity"] !== undefined) {
      this.minimumVolumeQuantity = new fhirModels.Quantity(source.minimumVolumeQuantity);
    }
    if (source["minimumVolumeString"] !== undefined) {
      this.minimumVolumeString = source.minimumVolumeString;
    }
    if (source["_minimumVolumeString"] !== undefined) {
      this._minimumVolumeString = new fhirModels.Element(source._minimumVolumeString);
    }
    if (source["preparation"] !== undefined) {
      this.preparation = source.preparation;
    }
    if (source["_preparation"] !== undefined) {
      this._preparation = new fhirModels.Element(source._preparation);
    }
    if (source["type"] !== undefined) {
      this.type = new fhirModels.CodeableConcept(source.type);
    }
  }
}
/**
 * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
 */
export class SpecimenDefinitionTypeTestedHandling extends fhirModels.BackboneElement implements fhirInterfaces.ISpecimenDefinitionTypeTestedHandling {
  /**
   * Additional textual instructions for the preservation or transport of the specimen. For instance, 'Protect from light exposure'.
   */
  instruction?: string|undefined;
  _instruction?: fhirModels.Element|undefined;
  /**
   * The maximum time interval of preservation of the specimen with these conditions.
   */
  maxDuration?: fhirModels.Duration|undefined;
  /**
   * It qualifies the interval of temperature, which characterizes an occurrence of handling. Conditions that are not related to temperature may be handled in the instruction element.
   */
  temperatureQualifier?: fhirModels.CodeableConcept|undefined;
  /**
   * The temperature interval for this set of handling instructions.
   */
  temperatureRange?: fhirModels.Range|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTestedHandling from an object that MAY NOT contain all required elements.
   */
  constructor(source:fhirInterfaces.ISpecimenDefinitionTypeTestedHandling) {
    super(source);
    if (source["instruction"] !== undefined) {
      this.instruction = source.instruction;
    }
    if (source["_instruction"] !== undefined) {
      this._instruction = new fhirModels.Element(source._instruction);
    }
    if (source["maxDuration"] !== undefined) {
      this.maxDuration = new fhirModels.Duration(source.maxDuration);
    }
    if (source["temperatureQualifier"] !== undefined) {
      this.temperatureQualifier = new fhirModels.CodeableConcept(source.temperatureQualifier);
    }
    if (source["temperatureRange"] !== undefined) {
      this.temperatureRange = new fhirModels.Range(source.temperatureRange);
    }
  }
}
/**
 * Specimen conditioned in a container as expected by the testing laboratory.
 */
export class SpecimenDefinitionTypeTested extends fhirModels.BackboneElement implements fhirInterfaces.ISpecimenDefinitionTypeTested {
  /**
   * The specimen's container.
   */
  container?: fhirModels.SpecimenDefinitionTypeTestedContainer|undefined;
  /**
   * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
   */
  handling?: fhirModels.SpecimenDefinitionTypeTestedHandling[]|undefined;
  /**
   * Primary of secondary specimen.
   */
  isDerived?: boolean|undefined;
  _isDerived?: fhirModels.Element|undefined;
  /**
   * The preference for this type of conditioned specimen.
   */
  preference: SpecimenDefinitionTypeTestedPreferenceEnum;
  _preference?: fhirModels.Element|undefined;
  /**
   * Criterion for rejection of the specimen in its container by the laboratory.
   */
  rejectionCriterion?: fhirModels.CodeableConcept[]|undefined;
  /**
   * Requirements for delivery and special handling of this kind of conditioned specimen.
   */
  requirement?: string|undefined;
  _requirement?: fhirModels.Element|undefined;
  /**
   * The usual time that a specimen of this kind is retained after the ordered tests are completed, for the purpose of additional testing.
   */
  retentionTime?: fhirModels.Duration|undefined;
  /**
   * The kind of specimen conditioned for testing expected by lab.
   */
  type?: fhirModels.CodeableConcept|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTested from an object that MAY NOT contain all required elements.
   */
  constructor(source:fhirInterfaces.ISpecimenDefinitionTypeTested) {
    super(source);
    if (source["container"] !== undefined) {
      this.container = new fhirModels.SpecimenDefinitionTypeTestedContainer(source.container);
    }
    if (source["handling"] !== undefined) {
      this.handling = source.handling.map((x) => new fhirModels.SpecimenDefinitionTypeTestedHandling(x));
    }
    if (source["isDerived"] !== undefined) {
      this.isDerived = source.isDerived;
    }
    if (source["_isDerived"] !== undefined) {
      this._isDerived = new fhirModels.Element(source._isDerived);
    }
    {
      this.preference = source.preference;
    }
    if (source["_preference"] !== undefined) {
      this._preference = new fhirModels.Element(source._preference);
    }
    if (source["rejectionCriterion"] !== undefined) {
      this.rejectionCriterion = source.rejectionCriterion.map((x) => new fhirModels.CodeableConcept(x));
    }
    if (source["requirement"] !== undefined) {
      this.requirement = source.requirement;
    }
    if (source["_requirement"] !== undefined) {
      this._requirement = new fhirModels.Element(source._requirement);
    }
    if (source["retentionTime"] !== undefined) {
      this.retentionTime = new fhirModels.Duration(source.retentionTime);
    }
    if (source["type"] !== undefined) {
      this.type = new fhirModels.CodeableConcept(source.type);
    }
  }
}
/**
 * Code Values for the SpecimenDefinition.typeTested.preference field
 */
export enum SpecimenDefinitionTypeTestedPreferenceEnum {
  PREFERRED = "preferred",
  ALTERNATE = "alternate",
}
/**
 * A kind of specimen with associated set of requirements.
 */
export class SpecimenDefinition extends fhirModels.DomainResource implements fhirInterfaces.ISpecimenDefinition {
  /**
   * Resource Type Name
   */
  readonly resourceType = "SpecimenDefinition";
  /**
   * The action to be performed for collecting the specimen.
   */
  collection?: fhirModels.CodeableConcept[]|undefined;
  /**
   * A business identifier associated with the kind of specimen.
   */
  identifier?: fhirModels.Identifier|undefined;
  /**
   * Preparation of the patient for specimen collection.
   */
  patientPreparation?: fhirModels.CodeableConcept[]|undefined;
  /**
   * Time aspect of specimen collection (duration or offset).
   */
  timeAspect?: string|undefined;
  _timeAspect?: fhirModels.Element|undefined;
  /**
   * The kind of material to be collected.
   */
  typeCollected?: fhirModels.CodeableConcept|undefined;
  /**
   * Specimen conditioned in a container as expected by the testing laboratory.
   */
  typeTested?: fhirModels.SpecimenDefinitionTypeTested[]|undefined;
  /**
   * Default constructor for SpecimenDefinition from an object that MAY NOT contain all required elements.
   */
  constructor(source:fhirInterfaces.ISpecimenDefinition) {
    super(source);
    if ((source['resourceType'] !== "SpecimenDefinition") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a SpecimenDefinition'; }
    if (source["collection"] !== undefined) {
      this.collection = source.collection.map((x) => new fhirModels.CodeableConcept(x));
    }
    if (source["identifier"] !== undefined) {
      this.identifier = new fhirModels.Identifier(source.identifier);
    }
    if (source["patientPreparation"] !== undefined) {
      this.patientPreparation = source.patientPreparation.map((x) => new fhirModels.CodeableConcept(x));
    }
    if (source["timeAspect"] !== undefined) {
      this.timeAspect = source.timeAspect;
    }
    if (source["_timeAspect"] !== undefined) {
      this._timeAspect = new fhirModels.Element(source._timeAspect);
    }
    if (source["typeCollected"] !== undefined) {
      this.typeCollected = new fhirModels.CodeableConcept(source.typeCollected);
    }
    if (source["typeTested"] !== undefined) {
      this.typeTested = source.typeTested.map((x) => new fhirModels.SpecimenDefinitionTypeTested(x));
    }
  }
}
