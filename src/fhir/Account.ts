// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Typically. this may be some form of insurance, internal charges, or self-pay.
 * Local or jurisdictional business rules may determine which coverage covers which types of billable items charged to the account, and in which order.
 * Where the order is important, a local/jurisdictional extension may be defined to specify the order for the type of charge.
 */
export type IAccountCoverage = fhir.IBackboneElement & {
  /**
   * The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).
   * A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing.
   */
  coverage: fhir.IReference|null;
  /**
   * It is common in some jurisdictions for there to be multiple coverages allocated to an account, and a sequence is required to order the settling of the account (often with insurance claiming).
   */
  priority?: number|undefined;
  _priority?: fhir.IFhirElement|undefined;
}
/**
 * The parties responsible for balancing the account if other payment options fall short.
 */
export type IAccountGuarantor = fhir.IBackboneElement & {
  /**
   * A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
   */
  onHold?: boolean|undefined;
  _onHold?: fhir.IFhirElement|undefined;
  /**
   * The entity who is responsible.
   */
  party: fhir.IReference|null;
  /**
   * The timeframe during which the guarantor accepts responsibility for the account.
   */
  period?: fhir.IPeriod|undefined;
}
/**
 * A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
 */
export type IAccount = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "Account";
  /**
   * Typically. this may be some form of insurance, internal charges, or self-pay.
   * Local or jurisdictional business rules may determine which coverage covers which types of billable items charged to the account, and in which order.
   * Where the order is important, a local/jurisdictional extension may be defined to specify the order for the type of charge.
   */
  coverage?: fhir.IAccountCoverage[]|undefined;
  /**
   * Provides additional information about what the account tracks and how it is used.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * The parties responsible for balancing the account if other payment options fall short.
   */
  guarantor?: fhir.IAccountGuarantor[]|undefined;
  /**
   * Unique identifier used to reference the account.  Might or might not be intended for human use (e.g. credit card number).
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * Name used for the account when displaying it to humans in reports, etc.
   */
  name?: string|undefined;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Indicates the service area, hospital, department, etc. with responsibility for managing the Account.
   */
  owner?: fhir.IReference|undefined;
  /**
   * Reference to a parent Account.
   */
  partOf?: fhir.IReference|undefined;
  /**
   * It is possible for transactions to be posted outside the service period, as long as the service was provided within the defined service period.
   */
  servicePeriod?: fhir.IPeriod|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes inactive and entered-in-error that mark the Account as not currently valid.
   */
  status: AccountStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
  /**
   * Accounts can be applied to non-patients for tracking other non-patient related activities, such as group services (patients not tracked, and costs charged to another body), or might not be allocated.
   */
  subject?: fhir.IReference[]|undefined;
  /**
   * Categorizes the account for reporting and searching purposes.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Typically. this may be some form of insurance, internal charges, or self-pay.
 * Local or jurisdictional business rules may determine which coverage covers which types of billable items charged to the account, and in which order.
 * Where the order is important, a local/jurisdictional extension may be defined to specify the order for the type of charge.
 */
export class AccountCoverage extends fhir.BackboneElement implements fhir.IAccountCoverage {
  /**
   * The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).
   * A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing.
   */
  public coverage: fhir.Reference|null;
  /**
   * It is common in some jurisdictions for there to be multiple coverages allocated to an account, and a sequence is required to order the settling of the account (often with insurance claiming).
   */
  public priority?: number|undefined;
  public _priority?: fhir.FhirElement|undefined;
  /**
   * Default constructor for AccountCoverage - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IAccountCoverage> = {}) {
    super(source);
    this.coverage = null;
    if (source["coverage"]) { this.coverage = new fhir.Reference(source.coverage!); }
    if (this.coverage === undefined) { this.coverage = null }
    if (source["priority"]) { this.priority = source.priority; }
    if (source["_priority"]) { this._priority = new fhir.FhirElement(source._priority!); }
  }
  /**
   * Check if the current AccountCoverage contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["coverage"] === undefined) { missingElements.push("coverage"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a AccountCoverage from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IAccountCoverage):AccountCoverage {
    var dest:AccountCoverage = new AccountCoverage(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `AccountCoverage is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The parties responsible for balancing the account if other payment options fall short.
 */
export class AccountGuarantor extends fhir.BackboneElement implements fhir.IAccountGuarantor {
  /**
   * A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
   */
  public onHold?: boolean|undefined;
  public _onHold?: fhir.FhirElement|undefined;
  /**
   * The entity who is responsible.
   */
  public party: fhir.Reference|null;
  /**
   * The timeframe during which the guarantor accepts responsibility for the account.
   */
  public period?: fhir.Period|undefined;
  /**
   * Default constructor for AccountGuarantor - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IAccountGuarantor> = {}) {
    super(source);
    if (source["onHold"]) { this.onHold = source.onHold; }
    if (source["_onHold"]) { this._onHold = new fhir.FhirElement(source._onHold!); }
    this.party = null;
    if (source["party"]) { this.party = new fhir.Reference(source.party!); }
    if (this.party === undefined) { this.party = null }
    if (source["period"]) { this.period = new fhir.Period(source.period!); }
  }
  /**
   * Check if the current AccountGuarantor contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["party"] === undefined) { missingElements.push("party"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a AccountGuarantor from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IAccountGuarantor):AccountGuarantor {
    var dest:AccountGuarantor = new AccountGuarantor(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `AccountGuarantor is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
 */
export class Account extends fhir.DomainResource implements fhir.IAccount {
  /**
   * Resource Type Name
   */
  public override resourceType: "Account";
  /**
   * Typically. this may be some form of insurance, internal charges, or self-pay.
   * Local or jurisdictional business rules may determine which coverage covers which types of billable items charged to the account, and in which order.
   * Where the order is important, a local/jurisdictional extension may be defined to specify the order for the type of charge.
   */
  public coverage?: fhir.AccountCoverage[]|undefined;
  /**
   * Provides additional information about what the account tracks and how it is used.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * The parties responsible for balancing the account if other payment options fall short.
   */
  public guarantor?: fhir.AccountGuarantor[]|undefined;
  /**
   * Unique identifier used to reference the account.  Might or might not be intended for human use (e.g. credit card number).
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * Name used for the account when displaying it to humans in reports, etc.
   */
  public name?: string|undefined;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Indicates the service area, hospital, department, etc. with responsibility for managing the Account.
   */
  public owner?: fhir.Reference|undefined;
  /**
   * Reference to a parent Account.
   */
  public partOf?: fhir.Reference|undefined;
  /**
   * It is possible for transactions to be posted outside the service period, as long as the service was provided within the defined service period.
   */
  public servicePeriod?: fhir.Period|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes inactive and entered-in-error that mark the Account as not currently valid.
   */
  public status: AccountStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * Accounts can be applied to non-patients for tracking other non-patient related activities, such as group services (patients not tracked, and costs charged to another body), or might not be allocated.
   */
  public subject?: fhir.Reference[]|undefined;
  /**
   * Categorizes the account for reporting and searching purposes.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for Account - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IAccount> = {}) {
    super(source);
    this.resourceType = 'Account';
    if (source["coverage"]) { this.coverage = source.coverage.map((x:Partial<fhir.IAccountCoverage>) => new fhir.AccountCoverage(x)); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["guarantor"]) { this.guarantor = source.guarantor.map((x:Partial<fhir.IAccountGuarantor>) => new fhir.AccountGuarantor(x)); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["name"]) { this.name = source.name; }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["owner"]) { this.owner = new fhir.Reference(source.owner!); }
    if (source["partOf"]) { this.partOf = new fhir.Reference(source.partOf!); }
    if (source["servicePeriod"]) { this.servicePeriod = new fhir.Period(source.servicePeriod!); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["subject"]) { this.subject = source.subject.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current Account contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["status"] === undefined) { missingElements.push("status"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Account from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IAccount):Account {
    var dest:Account = new Account(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `Account is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the Account.status field
 */
export enum AccountStatusEnum {
  ACTIVE = "active",
  INACTIVE = "inactive",
  ENTERED_IN_ERROR = "entered-in-error",
  ON_HOLD = "on-hold",
  UNKNOWN = "unknown",
}
