// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Moiety, for structural modifications.
 */
export type ISubstanceSpecificationMoiety = fhir.IBackboneElement & {
  /**
   * Quantitative value for this moiety.
   */
  amountQuantity?: fhir.IQuantity|undefined;
  /**
   * Quantitative value for this moiety.
   */
  amountString?: string|undefined;
  _amountString?: fhir.IFhirElement|undefined;
  /**
   * Identifier by which this moiety substance is known.
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * Molecular formula.
   */
  molecularFormula?: string|undefined;
  _molecularFormula?: fhir.IFhirElement|undefined;
  /**
   * Textual name for this moiety substance.
   */
  name?: string|undefined;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhir.ICodeableConcept|undefined;
  /**
   * Role that the moiety is playing.
   */
  role?: fhir.ICodeableConcept|undefined;
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhir.ICodeableConcept|undefined;
}
/**
 * General specifications for this substance, including how it is related to other substances.
 */
export type ISubstanceSpecificationProperty = fhir.IBackboneElement & {
  /**
   * Quantitative value for this property.
   */
  amountQuantity?: fhir.IQuantity|undefined;
  /**
   * Quantitative value for this property.
   */
  amountString?: string|undefined;
  _amountString?: fhir.IFhirElement|undefined;
  /**
   * A category for this property, e.g. Physical, Chemical, Enzymatic.
   */
  category?: fhir.ICodeableConcept|undefined;
  /**
   * Property type e.g. viscosity, pH, isoelectric point.
   */
  code?: fhir.ICodeableConcept|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstanceReference?: fhir.IReference|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstanceCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
   */
  parameters?: string|undefined;
  _parameters?: fhir.IFhirElement|undefined;
}
/**
 * The molecular weight or weight range (for proteins, polymers or nucleic acids).
 */
export type ISubstanceSpecificationStructureIsotopeMolecularWeight = fhir.IBackboneElement & {
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  amount?: fhir.IQuantity|undefined;
  /**
   * The method by which the molecular weight was determined.
   */
  method?: fhir.ICodeableConcept|undefined;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
 */
export type ISubstanceSpecificationStructureIsotope = fhir.IBackboneElement & {
  /**
   * Half life - for a non-natural nuclide.
   */
  halfLife?: fhir.IQuantity|undefined;
  /**
   * Substance identifier for each non-natural or radioisotope.
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight|undefined;
  /**
   * Substance name for each non-natural or radioisotope.
   */
  name?: fhir.ICodeableConcept|undefined;
  /**
   * The type of isotopic substitution present in a single substance.
   */
  substitution?: fhir.ICodeableConcept|undefined;
}
/**
 * Molecular structural representation.
 */
export type ISubstanceSpecificationStructureRepresentation = fhir.IBackboneElement & {
  /**
   * An attached file with the structural representation.
   */
  attachment?: fhir.IAttachment|undefined;
  /**
   * The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
   */
  representation?: string|undefined;
  _representation?: fhir.IFhirElement|undefined;
  /**
   * The type of structure (e.g. Full, Partial, Representative).
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Structural information.
 */
export type ISubstanceSpecificationStructure = fhir.IBackboneElement & {
  /**
   * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
   */
  isotope?: fhir.ISubstanceSpecificationStructureIsotope[]|undefined;
  /**
   * Molecular formula.
   */
  molecularFormula?: string|undefined;
  _molecularFormula?: fhir.IFhirElement|undefined;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  molecularFormulaByMoiety?: string|undefined;
  _molecularFormulaByMoiety?: fhir.IFhirElement|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight|undefined;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhir.ICodeableConcept|undefined;
  /**
   * Molecular structural representation.
   */
  representation?: fhir.ISubstanceSpecificationStructureRepresentation[]|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.IReference[]|undefined;
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhir.ICodeableConcept|undefined;
}
/**
 * Codes associated with the substance.
 */
export type ISubstanceSpecificationCode = fhir.IBackboneElement & {
  /**
   * The specific code.
   */
  code?: fhir.ICodeableConcept|undefined;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  comment?: string|undefined;
  _comment?: fhir.IFhirElement|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.IReference[]|undefined;
  /**
   * Status of the code assignment.
   */
  status?: fhir.ICodeableConcept|undefined;
  /**
   * The date at which the code status is changed as part of the terminology maintenance.
   */
  statusDate?: string|undefined;
  _statusDate?: fhir.IFhirElement|undefined;
}
/**
 * Details of the official nature of this name.
 */
export type ISubstanceSpecificationNameOfficial = fhir.IBackboneElement & {
  /**
   * Which authority uses this official name.
   */
  authority?: fhir.ICodeableConcept|undefined;
  /**
   * Date of official name change.
   */
  date?: string|undefined;
  _date?: fhir.IFhirElement|undefined;
  /**
   * The status of the official name.
   */
  status?: fhir.ICodeableConcept|undefined;
}
/**
 * Names applicable to this substance.
 */
export type ISubstanceSpecificationName = fhir.IBackboneElement & {
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  domain?: fhir.ICodeableConcept[]|undefined;
  /**
   * The jurisdiction where this name applies.
   */
  jurisdiction?: fhir.ICodeableConcept[]|undefined;
  /**
   * Language of the name.
   */
  language?: fhir.ICodeableConcept[]|undefined;
  /**
   * The actual name.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Details of the official nature of this name.
   */
  official?: fhir.ISubstanceSpecificationNameOfficial[]|undefined;
  /**
   * If this is the preferred name for this substance.
   */
  preferred?: boolean|undefined;
  _preferred?: fhir.IFhirElement|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.IReference[]|undefined;
  /**
   * The status of the name.
   */
  status?: fhir.ICodeableConcept|undefined;
  /**
   * A synonym of this name.
   */
  synonym?: fhir.ISubstanceSpecificationName[]|undefined;
  /**
   * A translation for this name.
   */
  translation?: fhir.ISubstanceSpecificationName[]|undefined;
  /**
   * Name type.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * A link between this substance and another, with details of the relationship.
 */
export type ISubstanceSpecificationRelationship = fhir.IBackboneElement & {
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountQuantity?: fhir.IQuantity|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRange?: fhir.IRange|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRatio?: fhir.IRatio|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountString?: string|undefined;
  _amountString?: fhir.IFhirElement|undefined;
  /**
   * For use when the numeric.
   */
  amountRatioLowLimit?: fhir.IRatio|undefined;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  amountType?: fhir.ICodeableConcept|undefined;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  isDefining?: boolean|undefined;
  _isDefining?: fhir.IFhirElement|undefined;
  /**
   * For example "salt to parent", "active moiety", "starting material".
   */
  relationship?: fhir.ICodeableConcept|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.IReference[]|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceReference?: fhir.IReference|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceCodeableConcept?: fhir.ICodeableConcept|undefined;
}
/**
 * The detailed description of a substance, typically at a level beyond what is used for prescribing.
 */
export type ISubstanceSpecification = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "SubstanceSpecification";
  /**
   * Codes associated with the substance.
   */
  code?: fhir.ISubstanceSpecificationCode[]|undefined;
  /**
   * Textual comment about this record of a substance.
   */
  comment?: string|undefined;
  _comment?: fhir.IFhirElement|undefined;
  /**
   * Textual description of the substance.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * If the substance applies to only human or veterinary use.
   */
  domain?: fhir.ICodeableConcept|undefined;
  /**
   * Identifier by which this substance is known.
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * Moiety, for structural modifications.
   */
  moiety?: fhir.ISubstanceSpecificationMoiety[]|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight[]|undefined;
  /**
   * Names applicable to this substance.
   */
  name?: fhir.ISubstanceSpecificationName[]|undefined;
  /**
   * Data items specific to nucleic acids.
   */
  nucleicAcid?: fhir.IReference|undefined;
  /**
   * Data items specific to polymers.
   */
  polymer?: fhir.IReference|undefined;
  /**
   * General specifications for this substance, including how it is related to other substances.
   */
  property?: fhir.ISubstanceSpecificationProperty[]|undefined;
  /**
   * Data items specific to proteins.
   */
  protein?: fhir.IReference|undefined;
  /**
   * General information detailing this substance.
   */
  referenceInformation?: fhir.IReference|undefined;
  /**
   * A link between this substance and another, with details of the relationship.
   */
  relationship?: fhir.ISubstanceSpecificationRelationship[]|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.IReference[]|undefined;
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  sourceMaterial?: fhir.IReference|undefined;
  /**
   * Status of substance within the catalogue e.g. approved.
   */
  status?: fhir.ICodeableConcept|undefined;
  /**
   * Structural information.
   */
  structure?: fhir.ISubstanceSpecificationStructure|undefined;
  /**
   * High level categorization, e.g. polymer or nucleic acid.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Moiety, for structural modifications.
 */
export class SubstanceSpecificationMoiety extends fhir.BackboneElement implements fhir.ISubstanceSpecificationMoiety {
  /**
   * Quantitative value for this moiety.
   */
  public amountQuantity?: fhir.Quantity|undefined;
  /**
   * Quantitative value for this moiety.
   */
  public amountString?: string|undefined;
  public _amountString?: fhir.FhirElement|undefined;
  /**
   * Identifier by which this moiety substance is known.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Molecular formula.
   */
  public molecularFormula?: string|undefined;
  public _molecularFormula?: fhir.FhirElement|undefined;
  /**
   * Textual name for this moiety substance.
   */
  public name?: string|undefined;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Optical activity type.
   */
  public opticalActivity?: fhir.CodeableConcept|undefined;
  /**
   * Role that the moiety is playing.
   */
  public role?: fhir.CodeableConcept|undefined;
  /**
   * Stereochemistry type.
   */
  public stereochemistry?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationMoiety - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationMoiety> = {}) {
    super(source);
    if (source["amountQuantity"]) { this.amountQuantity = new fhir.Quantity(source.amountQuantity!); }
    if (source["amountString"]) { this.amountString = source.amountString; }
    if (source["_amountString"]) { this._amountString = new fhir.FhirElement(source._amountString!); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["molecularFormula"]) { this.molecularFormula = source.molecularFormula; }
    if (source["_molecularFormula"]) { this._molecularFormula = new fhir.FhirElement(source._molecularFormula!); }
    if (source["name"]) { this.name = source.name; }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["opticalActivity"]) { this.opticalActivity = new fhir.CodeableConcept(source.opticalActivity!); }
    if (source["role"]) { this.role = new fhir.CodeableConcept(source.role!); }
    if (source["stereochemistry"]) { this.stereochemistry = new fhir.CodeableConcept(source.stereochemistry!); }
  }
  /**
   * Check if the current SubstanceSpecificationMoiety contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationMoiety from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationMoiety):SubstanceSpecificationMoiety {
    var dest:SubstanceSpecificationMoiety = new SubstanceSpecificationMoiety(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationMoiety is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * General specifications for this substance, including how it is related to other substances.
 */
export class SubstanceSpecificationProperty extends fhir.BackboneElement implements fhir.ISubstanceSpecificationProperty {
  /**
   * Quantitative value for this property.
   */
  public amountQuantity?: fhir.Quantity|undefined;
  /**
   * Quantitative value for this property.
   */
  public amountString?: string|undefined;
  public _amountString?: fhir.FhirElement|undefined;
  /**
   * A category for this property, e.g. Physical, Chemical, Enzymatic.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * Property type e.g. viscosity, pH, isoelectric point.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  public definingSubstanceReference?: fhir.Reference|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  public definingSubstanceCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
   */
  public parameters?: string|undefined;
  public _parameters?: fhir.FhirElement|undefined;
  /**
   * Default constructor for SubstanceSpecificationProperty - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationProperty> = {}) {
    super(source);
    if (source["amountQuantity"]) { this.amountQuantity = new fhir.Quantity(source.amountQuantity!); }
    if (source["amountString"]) { this.amountString = source.amountString; }
    if (source["_amountString"]) { this._amountString = new fhir.FhirElement(source._amountString!); }
    if (source["category"]) { this.category = new fhir.CodeableConcept(source.category!); }
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (source["definingSubstanceReference"]) { this.definingSubstanceReference = new fhir.Reference(source.definingSubstanceReference!); }
    if (source["definingSubstanceCodeableConcept"]) { this.definingSubstanceCodeableConcept = new fhir.CodeableConcept(source.definingSubstanceCodeableConcept!); }
    if (source["parameters"]) { this.parameters = source.parameters; }
    if (source["_parameters"]) { this._parameters = new fhir.FhirElement(source._parameters!); }
  }
  /**
   * Check if the current SubstanceSpecificationProperty contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationProperty from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationProperty):SubstanceSpecificationProperty {
    var dest:SubstanceSpecificationProperty = new SubstanceSpecificationProperty(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationProperty is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The molecular weight or weight range (for proteins, polymers or nucleic acids).
 */
export class SubstanceSpecificationStructureIsotopeMolecularWeight extends fhir.BackboneElement implements fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight {
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * The method by which the molecular weight was determined.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructureIsotopeMolecularWeight - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight> = {}) {
    super(source);
    if (source["amount"]) { this.amount = new fhir.Quantity(source.amount!); }
    if (source["method"]) { this.method = new fhir.CodeableConcept(source.method!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SubstanceSpecificationStructureIsotopeMolecularWeight contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationStructureIsotopeMolecularWeight from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight):SubstanceSpecificationStructureIsotopeMolecularWeight {
    var dest:SubstanceSpecificationStructureIsotopeMolecularWeight = new SubstanceSpecificationStructureIsotopeMolecularWeight(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationStructureIsotopeMolecularWeight is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
 */
export class SubstanceSpecificationStructureIsotope extends fhir.BackboneElement implements fhir.ISubstanceSpecificationStructureIsotope {
  /**
   * Half life - for a non-natural nuclide.
   */
  public halfLife?: fhir.Quantity|undefined;
  /**
   * Substance identifier for each non-natural or radioisotope.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeight|undefined;
  /**
   * Substance name for each non-natural or radioisotope.
   */
  public name?: fhir.CodeableConcept|undefined;
  /**
   * The type of isotopic substitution present in a single substance.
   */
  public substitution?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructureIsotope - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationStructureIsotope> = {}) {
    super(source);
    if (source["halfLife"]) { this.halfLife = new fhir.Quantity(source.halfLife!); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["molecularWeight"]) { this.molecularWeight = new fhir.SubstanceSpecificationStructureIsotopeMolecularWeight(source.molecularWeight!); }
    if (source["name"]) { this.name = new fhir.CodeableConcept(source.name!); }
    if (source["substitution"]) { this.substitution = new fhir.CodeableConcept(source.substitution!); }
  }
  /**
   * Check if the current SubstanceSpecificationStructureIsotope contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationStructureIsotope from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationStructureIsotope):SubstanceSpecificationStructureIsotope {
    var dest:SubstanceSpecificationStructureIsotope = new SubstanceSpecificationStructureIsotope(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationStructureIsotope is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Molecular structural representation.
 */
export class SubstanceSpecificationStructureRepresentation extends fhir.BackboneElement implements fhir.ISubstanceSpecificationStructureRepresentation {
  /**
   * An attached file with the structural representation.
   */
  public attachment?: fhir.Attachment|undefined;
  /**
   * The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
   */
  public representation?: string|undefined;
  public _representation?: fhir.FhirElement|undefined;
  /**
   * The type of structure (e.g. Full, Partial, Representative).
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructureRepresentation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationStructureRepresentation> = {}) {
    super(source);
    if (source["attachment"]) { this.attachment = new fhir.Attachment(source.attachment!); }
    if (source["representation"]) { this.representation = source.representation; }
    if (source["_representation"]) { this._representation = new fhir.FhirElement(source._representation!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SubstanceSpecificationStructureRepresentation contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationStructureRepresentation from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationStructureRepresentation):SubstanceSpecificationStructureRepresentation {
    var dest:SubstanceSpecificationStructureRepresentation = new SubstanceSpecificationStructureRepresentation(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationStructureRepresentation is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Structural information.
 */
export class SubstanceSpecificationStructure extends fhir.BackboneElement implements fhir.ISubstanceSpecificationStructure {
  /**
   * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
   */
  public isotope?: fhir.SubstanceSpecificationStructureIsotope[]|undefined;
  /**
   * Molecular formula.
   */
  public molecularFormula?: string|undefined;
  public _molecularFormula?: fhir.FhirElement|undefined;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  public molecularFormulaByMoiety?: string|undefined;
  public _molecularFormulaByMoiety?: fhir.FhirElement|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeight|undefined;
  /**
   * Optical activity type.
   */
  public opticalActivity?: fhir.CodeableConcept|undefined;
  /**
   * Molecular structural representation.
   */
  public representation?: fhir.SubstanceSpecificationStructureRepresentation[]|undefined;
  /**
   * Supporting literature.
   */
  public source?: fhir.Reference[]|undefined;
  /**
   * Stereochemistry type.
   */
  public stereochemistry?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationStructure> = {}) {
    super(source);
    if (source["isotope"]) { this.isotope = source.isotope.map((x:Partial<fhir.ISubstanceSpecificationStructureIsotope>) => new fhir.SubstanceSpecificationStructureIsotope(x)); }
    if (source["molecularFormula"]) { this.molecularFormula = source.molecularFormula; }
    if (source["_molecularFormula"]) { this._molecularFormula = new fhir.FhirElement(source._molecularFormula!); }
    if (source["molecularFormulaByMoiety"]) { this.molecularFormulaByMoiety = source.molecularFormulaByMoiety; }
    if (source["_molecularFormulaByMoiety"]) { this._molecularFormulaByMoiety = new fhir.FhirElement(source._molecularFormulaByMoiety!); }
    if (source["molecularWeight"]) { this.molecularWeight = new fhir.SubstanceSpecificationStructureIsotopeMolecularWeight(source.molecularWeight!); }
    if (source["opticalActivity"]) { this.opticalActivity = new fhir.CodeableConcept(source.opticalActivity!); }
    if (source["representation"]) { this.representation = source.representation.map((x:Partial<fhir.ISubstanceSpecificationStructureRepresentation>) => new fhir.SubstanceSpecificationStructureRepresentation(x)); }
    if (source["source"]) { this.source = source.source.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["stereochemistry"]) { this.stereochemistry = new fhir.CodeableConcept(source.stereochemistry!); }
  }
  /**
   * Check if the current SubstanceSpecificationStructure contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationStructure from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationStructure):SubstanceSpecificationStructure {
    var dest:SubstanceSpecificationStructure = new SubstanceSpecificationStructure(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationStructure is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Codes associated with the substance.
 */
export class SubstanceSpecificationCode extends fhir.BackboneElement implements fhir.ISubstanceSpecificationCode {
  /**
   * The specific code.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  public comment?: string|undefined;
  public _comment?: fhir.FhirElement|undefined;
  /**
   * Supporting literature.
   */
  public source?: fhir.Reference[]|undefined;
  /**
   * Status of the code assignment.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * The date at which the code status is changed as part of the terminology maintenance.
   */
  public statusDate?: string|undefined;
  public _statusDate?: fhir.FhirElement|undefined;
  /**
   * Default constructor for SubstanceSpecificationCode - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationCode> = {}) {
    super(source);
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (source["comment"]) { this.comment = source.comment; }
    if (source["_comment"]) { this._comment = new fhir.FhirElement(source._comment!); }
    if (source["source"]) { this.source = source.source.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["status"]) { this.status = new fhir.CodeableConcept(source.status!); }
    if (source["statusDate"]) { this.statusDate = source.statusDate; }
    if (source["_statusDate"]) { this._statusDate = new fhir.FhirElement(source._statusDate!); }
  }
  /**
   * Check if the current SubstanceSpecificationCode contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationCode from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationCode):SubstanceSpecificationCode {
    var dest:SubstanceSpecificationCode = new SubstanceSpecificationCode(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationCode is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Details of the official nature of this name.
 */
export class SubstanceSpecificationNameOfficial extends fhir.BackboneElement implements fhir.ISubstanceSpecificationNameOfficial {
  /**
   * Which authority uses this official name.
   */
  public authority?: fhir.CodeableConcept|undefined;
  /**
   * Date of official name change.
   */
  public date?: string|undefined;
  public _date?: fhir.FhirElement|undefined;
  /**
   * The status of the official name.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationNameOfficial - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationNameOfficial> = {}) {
    super(source);
    if (source["authority"]) { this.authority = new fhir.CodeableConcept(source.authority!); }
    if (source["date"]) { this.date = source.date; }
    if (source["_date"]) { this._date = new fhir.FhirElement(source._date!); }
    if (source["status"]) { this.status = new fhir.CodeableConcept(source.status!); }
  }
  /**
   * Check if the current SubstanceSpecificationNameOfficial contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationNameOfficial from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationNameOfficial):SubstanceSpecificationNameOfficial {
    var dest:SubstanceSpecificationNameOfficial = new SubstanceSpecificationNameOfficial(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationNameOfficial is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Names applicable to this substance.
 */
export class SubstanceSpecificationName extends fhir.BackboneElement implements fhir.ISubstanceSpecificationName {
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  public domain?: fhir.CodeableConcept[]|undefined;
  /**
   * The jurisdiction where this name applies.
   */
  public jurisdiction?: fhir.CodeableConcept[]|undefined;
  /**
   * Language of the name.
   */
  public language?: fhir.CodeableConcept[]|undefined;
  /**
   * The actual name.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Details of the official nature of this name.
   */
  public official?: fhir.SubstanceSpecificationNameOfficial[]|undefined;
  /**
   * If this is the preferred name for this substance.
   */
  public preferred?: boolean|undefined;
  public _preferred?: fhir.FhirElement|undefined;
  /**
   * Supporting literature.
   */
  public source?: fhir.Reference[]|undefined;
  /**
   * The status of the name.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * A synonym of this name.
   */
  public synonym?: fhir.SubstanceSpecificationName[]|undefined;
  /**
   * A translation for this name.
   */
  public translation?: fhir.SubstanceSpecificationName[]|undefined;
  /**
   * Name type.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationName - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationName> = {}) {
    super(source);
    if (source["domain"]) { this.domain = source.domain.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["jurisdiction"]) { this.jurisdiction = source.jurisdiction.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["language"]) { this.language = source.language.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["official"]) { this.official = source.official.map((x:Partial<fhir.ISubstanceSpecificationNameOfficial>) => new fhir.SubstanceSpecificationNameOfficial(x)); }
    if (source["preferred"]) { this.preferred = source.preferred; }
    if (source["_preferred"]) { this._preferred = new fhir.FhirElement(source._preferred!); }
    if (source["source"]) { this.source = source.source.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["status"]) { this.status = new fhir.CodeableConcept(source.status!); }
    if (source["synonym"]) { this.synonym = source.synonym.map((x:Partial<fhir.ISubstanceSpecificationName>) => new fhir.SubstanceSpecificationName(x)); }
    if (source["translation"]) { this.translation = source.translation.map((x:Partial<fhir.ISubstanceSpecificationName>) => new fhir.SubstanceSpecificationName(x)); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SubstanceSpecificationName contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["name"] === undefined) { missingElements.push("name"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationName from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationName):SubstanceSpecificationName {
    var dest:SubstanceSpecificationName = new SubstanceSpecificationName(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationName is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A link between this substance and another, with details of the relationship.
 */
export class SubstanceSpecificationRelationship extends fhir.BackboneElement implements fhir.ISubstanceSpecificationRelationship {
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  public amountQuantity?: fhir.Quantity|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  public amountRange?: fhir.Range|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  public amountRatio?: fhir.Ratio|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  public amountString?: string|undefined;
  public _amountString?: fhir.FhirElement|undefined;
  /**
   * For use when the numeric.
   */
  public amountRatioLowLimit?: fhir.Ratio|undefined;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  public amountType?: fhir.CodeableConcept|undefined;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  public isDefining?: boolean|undefined;
  public _isDefining?: fhir.FhirElement|undefined;
  /**
   * For example "salt to parent", "active moiety", "starting material".
   */
  public relationship?: fhir.CodeableConcept|undefined;
  /**
   * Supporting literature.
   */
  public source?: fhir.Reference[]|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  public substanceReference?: fhir.Reference|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  public substanceCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecificationRelationship - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecificationRelationship> = {}) {
    super(source);
    if (source["amountQuantity"]) { this.amountQuantity = new fhir.Quantity(source.amountQuantity!); }
    if (source["amountRange"]) { this.amountRange = new fhir.Range(source.amountRange!); }
    if (source["amountRatio"]) { this.amountRatio = new fhir.Ratio(source.amountRatio!); }
    if (source["amountString"]) { this.amountString = source.amountString; }
    if (source["_amountString"]) { this._amountString = new fhir.FhirElement(source._amountString!); }
    if (source["amountRatioLowLimit"]) { this.amountRatioLowLimit = new fhir.Ratio(source.amountRatioLowLimit!); }
    if (source["amountType"]) { this.amountType = new fhir.CodeableConcept(source.amountType!); }
    if (source["isDefining"]) { this.isDefining = source.isDefining; }
    if (source["_isDefining"]) { this._isDefining = new fhir.FhirElement(source._isDefining!); }
    if (source["relationship"]) { this.relationship = new fhir.CodeableConcept(source.relationship!); }
    if (source["source"]) { this.source = source.source.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["substanceReference"]) { this.substanceReference = new fhir.Reference(source.substanceReference!); }
    if (source["substanceCodeableConcept"]) { this.substanceCodeableConcept = new fhir.CodeableConcept(source.substanceCodeableConcept!); }
  }
  /**
   * Check if the current SubstanceSpecificationRelationship contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecificationRelationship from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecificationRelationship):SubstanceSpecificationRelationship {
    var dest:SubstanceSpecificationRelationship = new SubstanceSpecificationRelationship(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecificationRelationship is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The detailed description of a substance, typically at a level beyond what is used for prescribing.
 */
export class SubstanceSpecification extends fhir.DomainResource implements fhir.ISubstanceSpecification {
  /**
   * Resource Type Name
   */
  public override resourceType: "SubstanceSpecification";
  /**
   * Codes associated with the substance.
   */
  public code?: fhir.SubstanceSpecificationCode[]|undefined;
  /**
   * Textual comment about this record of a substance.
   */
  public comment?: string|undefined;
  public _comment?: fhir.FhirElement|undefined;
  /**
   * Textual description of the substance.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * If the substance applies to only human or veterinary use.
   */
  public domain?: fhir.CodeableConcept|undefined;
  /**
   * Identifier by which this substance is known.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Moiety, for structural modifications.
   */
  public moiety?: fhir.SubstanceSpecificationMoiety[]|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeight[]|undefined;
  /**
   * Names applicable to this substance.
   */
  public name?: fhir.SubstanceSpecificationName[]|undefined;
  /**
   * Data items specific to nucleic acids.
   */
  public nucleicAcid?: fhir.Reference|undefined;
  /**
   * Data items specific to polymers.
   */
  public polymer?: fhir.Reference|undefined;
  /**
   * General specifications for this substance, including how it is related to other substances.
   */
  public property?: fhir.SubstanceSpecificationProperty[]|undefined;
  /**
   * Data items specific to proteins.
   */
  public protein?: fhir.Reference|undefined;
  /**
   * General information detailing this substance.
   */
  public referenceInformation?: fhir.Reference|undefined;
  /**
   * A link between this substance and another, with details of the relationship.
   */
  public relationship?: fhir.SubstanceSpecificationRelationship[]|undefined;
  /**
   * Supporting literature.
   */
  public source?: fhir.Reference[]|undefined;
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  public sourceMaterial?: fhir.Reference|undefined;
  /**
   * Status of substance within the catalogue e.g. approved.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * Structural information.
   */
  public structure?: fhir.SubstanceSpecificationStructure|undefined;
  /**
   * High level categorization, e.g. polymer or nucleic acid.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SubstanceSpecification - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceSpecification> = {}) {
    super(source);
    this.resourceType = 'SubstanceSpecification';
    if (source["code"]) { this.code = source.code.map((x:Partial<fhir.ISubstanceSpecificationCode>) => new fhir.SubstanceSpecificationCode(x)); }
    if (source["comment"]) { this.comment = source.comment; }
    if (source["_comment"]) { this._comment = new fhir.FhirElement(source._comment!); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["domain"]) { this.domain = new fhir.CodeableConcept(source.domain!); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["moiety"]) { this.moiety = source.moiety.map((x:Partial<fhir.ISubstanceSpecificationMoiety>) => new fhir.SubstanceSpecificationMoiety(x)); }
    if (source["molecularWeight"]) { this.molecularWeight = source.molecularWeight.map((x:Partial<fhir.ISubstanceSpecificationStructureIsotopeMolecularWeight>) => new fhir.SubstanceSpecificationStructureIsotopeMolecularWeight(x)); }
    if (source["name"]) { this.name = source.name.map((x:Partial<fhir.ISubstanceSpecificationName>) => new fhir.SubstanceSpecificationName(x)); }
    if (source["nucleicAcid"]) { this.nucleicAcid = new fhir.Reference(source.nucleicAcid!); }
    if (source["polymer"]) { this.polymer = new fhir.Reference(source.polymer!); }
    if (source["property"]) { this.property = source.property.map((x:Partial<fhir.ISubstanceSpecificationProperty>) => new fhir.SubstanceSpecificationProperty(x)); }
    if (source["protein"]) { this.protein = new fhir.Reference(source.protein!); }
    if (source["referenceInformation"]) { this.referenceInformation = new fhir.Reference(source.referenceInformation!); }
    if (source["relationship"]) { this.relationship = source.relationship.map((x:Partial<fhir.ISubstanceSpecificationRelationship>) => new fhir.SubstanceSpecificationRelationship(x)); }
    if (source["source"]) { this.source = source.source.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["sourceMaterial"]) { this.sourceMaterial = new fhir.Reference(source.sourceMaterial!); }
    if (source["status"]) { this.status = new fhir.CodeableConcept(source.status!); }
    if (source["structure"]) { this.structure = new fhir.SubstanceSpecificationStructure(source.structure!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SubstanceSpecification contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceSpecification from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceSpecification):SubstanceSpecification {
    var dest:SubstanceSpecification = new SubstanceSpecification(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceSpecification is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
