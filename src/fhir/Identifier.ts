// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
  // Restricted to: Patient|Encounter|Observation
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 */
export interface IIdentifier extends fhir.IFhirElement {
  /**
   * The Identifier.assigner may omit the .reference element and only contain a .display element reflecting the name or other textual information about the assigning organization.
   */
  assigner?: fhir.IReference|undefined;
  /**
   * Time period during which identifier is/was valid for use.
   */
  period?: fhir.IPeriod|undefined;
  /**
   * Identifier.system is always case sensitive.
   */
  system?: string|undefined;
  _system?: fhir.IFhirElement|undefined;
  /**
   * This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage.   Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
   */
  type?: fhir.ICodeableConcept|undefined;
  /**
   * Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
   */
  use?: IdentifierUseEnum|undefined;
  _use?: fhir.IFhirElement|undefined;
  /**
   * If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.  The value's primary purpose is computational mapping.  As a result, it may be normalized for comparison purposes (e.g. removing non-significant whitespace, dashes, etc.)  A value formatted for human display can be conveyed using the [Rendered Value extension](extension-rendered-value.html). Identifier.value is to be treated as case sensitive unless knowledge of the Identifier.system allows the processer to be confident that non-case-sensitive processing is safe.
   */
  value?: string|undefined;
  _value?: fhir.IFhirElement|undefined;
}
/**
 * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 */
export class Identifier extends fhir.FhirElement implements fhir.IIdentifier {
  /**
   * The Identifier.assigner may omit the .reference element and only contain a .display element reflecting the name or other textual information about the assigning organization.
   */
  public assigner?: fhir.Reference|undefined;
  /**
   * Time period during which identifier is/was valid for use.
   */
  public period?: fhir.Period|undefined;
  /**
   * Identifier.system is always case sensitive.
   */
  public system?: string|undefined;
  public _system?: fhir.FhirElement|undefined;
  /**
   * This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage.   Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
   */
  public use?: IdentifierUseEnum|undefined;
  public _use?: fhir.FhirElement|undefined;
  /**
   * If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.  The value's primary purpose is computational mapping.  As a result, it may be normalized for comparison purposes (e.g. removing non-significant whitespace, dashes, etc.)  A value formatted for human display can be conveyed using the [Rendered Value extension](extension-rendered-value.html). Identifier.value is to be treated as case sensitive unless knowledge of the Identifier.system allows the processer to be confident that non-case-sensitive processing is safe.
   */
  public value?: string|undefined;
  public _value?: fhir.FhirElement|undefined;
  /**
   * Default constructor for Identifier - initializes required elements to null.
   */
  constructor() {
    super();
  }
  /**
   * Factory function to create a Identifier from an object that MAY NOT contain all required elements.
   */
  static override FactoryCreate(source:Partial<fhir.IIdentifier>):Identifier {
    var dest:Partial<Identifier> = super.FactoryCreate(source) as Partial<Identifier>;
    if (source["assigner"] !== undefined) { dest.assigner = fhir.Reference.FactoryCreate(source.assigner!); }
    if (source["period"] !== undefined) { dest.period = fhir.Period.FactoryCreate(source.period!); }
    if (source["system"] !== undefined) { dest.system = source.system; }
    if (source["_system"] !== undefined) { dest._system = fhir.FhirElement.FactoryCreate(source._system!); }
    if (source["type"] !== undefined) { dest.type = fhir.CodeableConcept.FactoryCreate(source.type!); }
    if (source["use"] !== undefined) { dest.use = source.use; }
    if (source["_use"] !== undefined) { dest._use = fhir.FhirElement.FactoryCreate(source._use!); }
    if (source["value"] !== undefined) { dest.value = source.value; }
    if (source["_value"] !== undefined) { dest._value = fhir.FhirElement.FactoryCreate(source._value!); }
    return dest as Identifier;
  }
  /**
   * Check if the current Identifier contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Identifier from an object that MUST contain all required elements.
   */
  static override FactoryCreateStrict(source:fhir.IIdentifier):Identifier {
    var dest:Identifier = this.FactoryCreate(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `Identifier is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * Code Values for the Identifier.use field
 */
export enum IdentifierUseEnum {
  USUAL = "usual",
  OFFICIAL = "official",
  TEMP = "temp",
  SECONDARY = "secondary",
  OLD = "old",
}
