// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Characteristics for quantitative results of this observation.
 */
export type IObservationDefinitionQuantitativeDetails = fhir.IBackboneElement & {
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  conversionFactor?: number|undefined;
  _conversionFactor?: fhir.IFhirElement|undefined;
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  customaryUnit?: fhir.ICodeableConcept|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  decimalPrecision?: number|undefined;
  _decimalPrecision?: fhir.IFhirElement|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  unit?: fhir.ICodeableConcept|undefined;
}
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export type IObservationDefinitionQualifiedInterval = fhir.IBackboneElement & {
  /**
   * Some analytes vary greatly over age.
   */
  age?: fhir.IRange|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  appliesTo?: fhir.ICodeableConcept[]|undefined;
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  category?: ObservationDefinitionQualifiedIntervalCategoryEnum|undefined;
  _category?: fhir.IFhirElement|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  condition?: string|undefined;
  _condition?: fhir.IFhirElement|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  context?: fhir.ICodeableConcept|undefined;
  /**
   * Sex of the population the range applies to.
   */
  gender?: ObservationDefinitionQualifiedIntervalGenderEnum|undefined;
  _gender?: fhir.IFhirElement|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  gestationalAge?: fhir.IRange|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  range?: fhir.IRange|undefined;
}
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export type IObservationDefinition = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "ObservationDefinition";
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  abnormalCodedValueSet?: fhir.IReference|undefined;
  /**
   * This element allows various categorization schemes based on the ownerâ€™s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  category?: fhir.ICodeableConcept[]|undefined;
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  code: fhir.ICodeableConcept|null;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  criticalCodedValueSet?: fhir.IReference|undefined;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  method?: fhir.ICodeableConcept|undefined;
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  multipleResultsAllowed?: boolean|undefined;
  _multipleResultsAllowed?: fhir.IFhirElement|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  normalCodedValueSet?: fhir.IReference|undefined;
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  permittedDataType?: ObservationDefinitionPermittedDataTypeEnum[]|undefined;
  _permittedDataType?: fhir.IFhirElement[]|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  preferredReportName?: string|undefined;
  _preferredReportName?: fhir.IFhirElement|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  qualifiedInterval?: fhir.IObservationDefinitionQualifiedInterval[]|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  quantitativeDetails?: fhir.IObservationDefinitionQuantitativeDetails|undefined;
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  validCodedValueSet?: fhir.IReference|undefined;
}
/**
 * Characteristics for quantitative results of this observation.
 */
export class ObservationDefinitionQuantitativeDetails extends fhir.BackboneElement implements fhir.IObservationDefinitionQuantitativeDetails {
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  public conversionFactor?: number|undefined;
  public _conversionFactor?: fhir.FhirElement|undefined;
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  public customaryUnit?: fhir.CodeableConcept|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  public decimalPrecision?: number|undefined;
  public _decimalPrecision?: fhir.FhirElement|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  public unit?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ObservationDefinitionQuantitativeDetails - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IObservationDefinitionQuantitativeDetails> = {}) {
    super(source);
    if (source["conversionFactor"]) { this.conversionFactor = source.conversionFactor; }
    if (source["_conversionFactor"]) { this._conversionFactor = new fhir.FhirElement(source._conversionFactor!); }
    if (source["customaryUnit"]) { this.customaryUnit = new fhir.CodeableConcept(source.customaryUnit!); }
    if (source["decimalPrecision"]) { this.decimalPrecision = source.decimalPrecision; }
    if (source["_decimalPrecision"]) { this._decimalPrecision = new fhir.FhirElement(source._decimalPrecision!); }
    if (source["unit"]) { this.unit = new fhir.CodeableConcept(source.unit!); }
  }
  /**
   * Check if the current ObservationDefinitionQuantitativeDetails contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ObservationDefinitionQuantitativeDetails from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IObservationDefinitionQuantitativeDetails):ObservationDefinitionQuantitativeDetails {
    var dest:ObservationDefinitionQuantitativeDetails = new ObservationDefinitionQuantitativeDetails(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `ObservationDefinitionQuantitativeDetails is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export class ObservationDefinitionQualifiedInterval extends fhir.BackboneElement implements fhir.IObservationDefinitionQualifiedInterval {
  /**
   * Some analytes vary greatly over age.
   */
  public age?: fhir.Range|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  public appliesTo?: fhir.CodeableConcept[]|undefined;
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  public category?: ObservationDefinitionQualifiedIntervalCategoryEnum|undefined;
  public _category?: fhir.FhirElement|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  public condition?: string|undefined;
  public _condition?: fhir.FhirElement|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  public context?: fhir.CodeableConcept|undefined;
  /**
   * Sex of the population the range applies to.
   */
  public gender?: ObservationDefinitionQualifiedIntervalGenderEnum|undefined;
  public _gender?: fhir.FhirElement|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  public gestationalAge?: fhir.Range|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  public range?: fhir.Range|undefined;
  /**
   * Default constructor for ObservationDefinitionQualifiedInterval - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IObservationDefinitionQualifiedInterval> = {}) {
    super(source);
    if (source["age"]) { this.age = new fhir.Range(source.age!); }
    if (source["appliesTo"]) { this.appliesTo = source.appliesTo.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["category"]) { this.category = source.category; }
    if (source["_category"]) { this._category = new fhir.FhirElement(source._category!); }
    if (source["condition"]) { this.condition = source.condition; }
    if (source["_condition"]) { this._condition = new fhir.FhirElement(source._condition!); }
    if (source["context"]) { this.context = new fhir.CodeableConcept(source.context!); }
    if (source["gender"]) { this.gender = source.gender; }
    if (source["_gender"]) { this._gender = new fhir.FhirElement(source._gender!); }
    if (source["gestationalAge"]) { this.gestationalAge = new fhir.Range(source.gestationalAge!); }
    if (source["range"]) { this.range = new fhir.Range(source.range!); }
  }
  /**
   * Check if the current ObservationDefinitionQualifiedInterval contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ObservationDefinitionQualifiedInterval from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IObservationDefinitionQualifiedInterval):ObservationDefinitionQualifiedInterval {
    var dest:ObservationDefinitionQualifiedInterval = new ObservationDefinitionQualifiedInterval(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `ObservationDefinitionQualifiedInterval is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export class ObservationDefinition extends fhir.DomainResource implements fhir.IObservationDefinition {
  /**
   * Resource Type Name
   */
  public override resourceType: "ObservationDefinition";
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  public abnormalCodedValueSet?: fhir.Reference|undefined;
  /**
   * This element allows various categorization schemes based on the ownerâ€™s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  public category?: fhir.CodeableConcept[]|undefined;
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  public code: fhir.CodeableConcept|null;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  public criticalCodedValueSet?: fhir.Reference|undefined;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  public multipleResultsAllowed?: boolean|undefined;
  public _multipleResultsAllowed?: fhir.FhirElement|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  public normalCodedValueSet?: fhir.Reference|undefined;
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  public permittedDataType?: ObservationDefinitionPermittedDataTypeEnum[]|undefined;
  public _permittedDataType?: fhir.FhirElement[]|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  public preferredReportName?: string|undefined;
  public _preferredReportName?: fhir.FhirElement|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  public qualifiedInterval?: fhir.ObservationDefinitionQualifiedInterval[]|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  public quantitativeDetails?: fhir.ObservationDefinitionQuantitativeDetails|undefined;
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  public validCodedValueSet?: fhir.Reference|undefined;
  /**
   * Default constructor for ObservationDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IObservationDefinition> = {}) {
    super(source);
    this.resourceType = 'ObservationDefinition';
    if (source["abnormalCodedValueSet"]) { this.abnormalCodedValueSet = new fhir.Reference(source.abnormalCodedValueSet!); }
    if (source["category"]) { this.category = source.category.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.code = null;
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (this.code === undefined) { this.code = null }
    if (source["criticalCodedValueSet"]) { this.criticalCodedValueSet = new fhir.Reference(source.criticalCodedValueSet!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["method"]) { this.method = new fhir.CodeableConcept(source.method!); }
    if (source["multipleResultsAllowed"]) { this.multipleResultsAllowed = source.multipleResultsAllowed; }
    if (source["_multipleResultsAllowed"]) { this._multipleResultsAllowed = new fhir.FhirElement(source._multipleResultsAllowed!); }
    if (source["normalCodedValueSet"]) { this.normalCodedValueSet = new fhir.Reference(source.normalCodedValueSet!); }
    if (source["permittedDataType"]) { this.permittedDataType = source.permittedDataType.map((x) => (x)); }
    if (source["_permittedDataType"]) { this._permittedDataType = source._permittedDataType.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["preferredReportName"]) { this.preferredReportName = source.preferredReportName; }
    if (source["_preferredReportName"]) { this._preferredReportName = new fhir.FhirElement(source._preferredReportName!); }
    if (source["qualifiedInterval"]) { this.qualifiedInterval = source.qualifiedInterval.map((x:Partial<fhir.IObservationDefinitionQualifiedInterval>) => new fhir.ObservationDefinitionQualifiedInterval(x)); }
    if (source["quantitativeDetails"]) { this.quantitativeDetails = new fhir.ObservationDefinitionQuantitativeDetails(source.quantitativeDetails!); }
    if (source["validCodedValueSet"]) { this.validCodedValueSet = new fhir.Reference(source.validCodedValueSet!); }
  }
  /**
   * Check if the current ObservationDefinition contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ObservationDefinition from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IObservationDefinition):ObservationDefinition {
    var dest:ObservationDefinition = new ObservationDefinition(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `ObservationDefinition is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the ObservationDefinition.qualifiedInterval.category field
 */
export enum ObservationDefinitionQualifiedIntervalCategoryEnum {
  REFERENCE = "reference",
  CRITICAL = "critical",
  ABSOLUTE = "absolute",
}
/**
 * Code Values for the ObservationDefinition.qualifiedInterval.gender field
 */
export enum ObservationDefinitionQualifiedIntervalGenderEnum {
  MALE = "male",
  FEMALE = "female",
  OTHER = "other",
  UNKNOWN = "unknown",
}
/**
 * Code Values for the ObservationDefinition.permittedDataType field
 */
export enum ObservationDefinitionPermittedDataTypeEnum {
  QUANTITY = "Quantity",
  CODEABLECONCEPT = "CodeableConcept",
  STRING = "string",
  BOOLEAN = "boolean",
  INTEGER = "integer",
  RANGE = "Range",
  RATIO = "Ratio",
  SAMPLEDDATA = "SampledData",
  TIME = "time",
  DATETIME = "dateTime",
  PERIOD = "Period",
}
