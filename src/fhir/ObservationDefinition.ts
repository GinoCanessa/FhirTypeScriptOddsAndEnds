// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Characteristics for quantitative results of this observation.
 */
export type IObservationDefinitionQuantitativeDetails = fhir.IBackboneElement & {
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  conversionFactor?: number|undefined;
  _conversionFactor?: fhir.IFhirElement|undefined;
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  customaryUnit?: fhir.ICodeableConcept|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  decimalPrecision?: number|undefined;
  _decimalPrecision?: fhir.IFhirElement|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  unit?: fhir.ICodeableConcept|undefined;
}
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export type IObservationDefinitionQualifiedInterval = fhir.IBackboneElement & {
  /**
   * Some analytes vary greatly over age.
   */
  age?: fhir.IRange|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  appliesTo?: fhir.ICodeableConcept[]|undefined;
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  category?: ObservationDefinitionQualifiedIntervalCategoryEnum|undefined;
  _category?: fhir.IFhirElement|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  condition?: string|undefined;
  _condition?: fhir.IFhirElement|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  context?: fhir.ICodeableConcept|undefined;
  /**
   * Sex of the population the range applies to.
   */
  gender?: ObservationDefinitionQualifiedIntervalGenderEnum|undefined;
  _gender?: fhir.IFhirElement|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  gestationalAge?: fhir.IRange|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  range?: fhir.IRange|undefined;
}
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export type IObservationDefinition = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "ObservationDefinition";
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  abnormalCodedValueSet?: fhir.IReference|undefined;
  /**
   * This element allows various categorization schemes based on the owner’s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  category?: fhir.ICodeableConcept[]|undefined;
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  code: fhir.ICodeableConcept|null;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  criticalCodedValueSet?: fhir.IReference|undefined;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  method?: fhir.ICodeableConcept|undefined;
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  multipleResultsAllowed?: boolean|undefined;
  _multipleResultsAllowed?: fhir.IFhirElement|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  normalCodedValueSet?: fhir.IReference|undefined;
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  permittedDataType?: ObservationDefinitionPermittedDataTypeEnum[]|undefined;
  _permittedDataType?: fhir.IFhirElement[]|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  preferredReportName?: string|undefined;
  _preferredReportName?: fhir.IFhirElement|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  qualifiedInterval?: fhir.IObservationDefinitionQualifiedInterval[]|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  quantitativeDetails?: fhir.IObservationDefinitionQuantitativeDetails|undefined;
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  validCodedValueSet?: fhir.IReference|undefined;
}
/**
 * Characteristics for quantitative results of this observation.
 */
export class ObservationDefinitionQuantitativeDetails extends fhir.BackboneElement implements fhir.IObservationDefinitionQuantitativeDetails {
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  public conversionFactor?: number|undefined;
  public _conversionFactor?: fhir.FhirElement|undefined;
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  public customaryUnit?: fhir.CodeableConcept|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  public decimalPrecision?: number|undefined;
  public _decimalPrecision?: fhir.FhirElement|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  public unit?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ObservationDefinitionQuantitativeDetails - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IObservationDefinitionQuantitativeDetails> = {}) {
    super(source);
    if (source["conversionFactor"]) { this.conversionFactor = source.conversionFactor; }
    if (source["_conversionFactor"]) { this._conversionFactor = new fhir.FhirElement(source._conversionFactor!); }
    if (source["customaryUnit"]) { this.customaryUnit = new fhir.CodeableConcept(source.customaryUnit!); }
    if (source["decimalPrecision"]) { this.decimalPrecision = source.decimalPrecision; }
    if (source["_decimalPrecision"]) { this._decimalPrecision = new fhir.FhirElement(source._decimalPrecision!); }
    if (source["unit"]) { this.unit = new fhir.CodeableConcept(source.unit!); }
  }
  /**
   * Check if the current ObservationDefinitionQuantitativeDetails contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ObservationDefinitionQuantitativeDetails from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IObservationDefinitionQuantitativeDetails):ObservationDefinitionQuantitativeDetails {
    var dest:ObservationDefinitionQuantitativeDetails = new ObservationDefinitionQuantitativeDetails(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `ObservationDefinitionQuantitativeDetails is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export class ObservationDefinitionQualifiedInterval extends fhir.BackboneElement implements fhir.IObservationDefinitionQualifiedInterval {
  /**
   * Some analytes vary greatly over age.
   */
  public age?: fhir.Range|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  public appliesTo?: fhir.CodeableConcept[]|undefined;
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  public category?: ObservationDefinitionQualifiedIntervalCategoryEnum|undefined;
  public _category?: fhir.FhirElement|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  public condition?: string|undefined;
  public _condition?: fhir.FhirElement|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  public context?: fhir.CodeableConcept|undefined;
  /**
   * Sex of the population the range applies to.
   */
  public gender?: ObservationDefinitionQualifiedIntervalGenderEnum|undefined;
  public _gender?: fhir.FhirElement|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  public gestationalAge?: fhir.Range|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  public range?: fhir.Range|undefined;
  /**
   * Default constructor for ObservationDefinitionQualifiedInterval - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IObservationDefinitionQualifiedInterval> = {}) {
    super(source);
    if (source["age"]) { this.age = new fhir.Range(source.age!); }
    if (source["appliesTo"]) { this.appliesTo = source.appliesTo.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["category"]) { this.category = source.category; }
    if (source["_category"]) { this._category = new fhir.FhirElement(source._category!); }
    if (source["condition"]) { this.condition = source.condition; }
    if (source["_condition"]) { this._condition = new fhir.FhirElement(source._condition!); }
    if (source["context"]) { this.context = new fhir.CodeableConcept(source.context!); }
    if (source["gender"]) { this.gender = source.gender; }
    if (source["_gender"]) { this._gender = new fhir.FhirElement(source._gender!); }
    if (source["gestationalAge"]) { this.gestationalAge = new fhir.Range(source.gestationalAge!); }
    if (source["range"]) { this.range = new fhir.Range(source.range!); }
  }
  /**
   * Check if the current ObservationDefinitionQualifiedInterval contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ObservationDefinitionQualifiedInterval from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IObservationDefinitionQualifiedInterval):ObservationDefinitionQualifiedInterval {
    var dest:ObservationDefinitionQualifiedInterval = new ObservationDefinitionQualifiedInterval(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `ObservationDefinitionQualifiedInterval is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export class ObservationDefinition extends fhir.DomainResource implements fhir.IObservationDefinition {
  /**
   * Resource Type Name
   */
  public override resourceType: "ObservationDefinition";
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  public abnormalCodedValueSet?: fhir.Reference|undefined;
  /**
   * This element allows various categorization schemes based on the owner’s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  public category?: fhir.CodeableConcept[]|undefined;
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  public code: fhir.CodeableConcept|null;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  public criticalCodedValueSet?: fhir.Reference|undefined;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  public multipleResultsAllowed?: boolean|undefined;
  public _multipleResultsAllowed?: fhir.FhirElement|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  public normalCodedValueSet?: fhir.Reference|undefined;
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  public permittedDataType?: ObservationDefinitionPermittedDataTypeEnum[]|undefined;
  public _permittedDataType?: fhir.FhirElement[]|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  public preferredReportName?: string|undefined;
  public _preferredReportName?: fhir.FhirElement|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  public qualifiedInterval?: fhir.ObservationDefinitionQualifiedInterval[]|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  public quantitativeDetails?: fhir.ObservationDefinitionQuantitativeDetails|undefined;
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  public validCodedValueSet?: fhir.Reference|undefined;
  /**
   * Default constructor for ObservationDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IObservationDefinition> = {}) {
    super(source);
    this.resourceType = 'ObservationDefinition';
    if (source["abnormalCodedValueSet"]) { this.abnormalCodedValueSet = new fhir.Reference(source.abnormalCodedValueSet!); }
    if (source["category"]) { this.category = source.category.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.code = null;
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (this.code === undefined) { this.code = null }
    if (source["criticalCodedValueSet"]) { this.criticalCodedValueSet = new fhir.Reference(source.criticalCodedValueSet!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["method"]) { this.method = new fhir.CodeableConcept(source.method!); }
    if (source["multipleResultsAllowed"]) { this.multipleResultsAllowed = source.multipleResultsAllowed; }
    if (source["_multipleResultsAllowed"]) { this._multipleResultsAllowed = new fhir.FhirElement(source._multipleResultsAllowed!); }
    if (source["normalCodedValueSet"]) { this.normalCodedValueSet = new fhir.Reference(source.normalCodedValueSet!); }
    if (source["permittedDataType"]) { this.permittedDataType = source.permittedDataType.map((x) => (x)); }
    if (source["_permittedDataType"]) { this._permittedDataType = source._permittedDataType.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["preferredReportName"]) { this.preferredReportName = source.preferredReportName; }
    if (source["_preferredReportName"]) { this._preferredReportName = new fhir.FhirElement(source._preferredReportName!); }
    if (source["qualifiedInterval"]) { this.qualifiedInterval = source.qualifiedInterval.map((x:Partial<fhir.IObservationDefinitionQualifiedInterval>) => new fhir.ObservationDefinitionQualifiedInterval(x)); }
    if (source["quantitativeDetails"]) { this.quantitativeDetails = new fhir.ObservationDefinitionQuantitativeDetails(source.quantitativeDetails!); }
    if (source["validCodedValueSet"]) { this.validCodedValueSet = new fhir.Reference(source.validCodedValueSet!); }
  }
  /**
   * Check if the current ObservationDefinition contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ObservationDefinition from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IObservationDefinition):ObservationDefinition {
    var dest:ObservationDefinition = new ObservationDefinition(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `ObservationDefinition is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the ObservationDefinition.qualifiedInterval.category field
 */
export enum ObservationDefinitionQualifiedIntervalCategoryEnum {
  REFERENCE = "reference",
  CRITICAL = "critical",
  ABSOLUTE = "absolute",
}
/**
 * Code Values for the ObservationDefinition.qualifiedInterval.gender field
 */
export enum ObservationDefinitionQualifiedIntervalGenderEnum {
  MALE = "male",
  FEMALE = "female",
  OTHER = "other",
  UNKNOWN = "unknown",
}
/**
 * Code Values for the ObservationDefinition.permittedDataType field
 */
export enum ObservationDefinitionPermittedDataTypeEnum {
  QUANTITY = "Quantity",
  CODEABLECONCEPT = "CodeableConcept",
  STRING = "string",
  BOOLEAN = "boolean",
  INTEGER = "integer",
  RANGE = "Range",
  RATIO = "Ratio",
  SAMPLEDDATA = "SampledData",
  TIME = "time",
  DATETIME = "dateTime",
  PERIOD = "Period",
}
