// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
 */
export type IContractContentDefinition = fhir.IBackboneElement & {
  /**
   * A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
   */
  copyright?: string|undefined;
  _copyright?: fhir.IFhirElement|undefined;
  /**
   * The date (and optionally time) when the contract was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
   */
  publicationDate?: string|undefined;
  _publicationDate?: fhir.IFhirElement|undefined;
  /**
   * amended | appended | cancelled | disputed | entered-in-error | executable | executed | negotiable | offered | policy | rejected | renewed | revoked | resolved | terminated.
   */
  publicationStatus: ContractContentDefinitionPublicationStatusEnum|null;
  _publicationStatus?: fhir.IFhirElement|undefined;
  /**
   * The  individual or organization that published the Contract precursor content.
   */
  publisher?: fhir.IReference|undefined;
  /**
   * Detailed Precusory content type.
   */
  subType?: fhir.ICodeableConcept|undefined;
  /**
   * Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation.
   */
  type: fhir.ICodeableConcept|null;
}
/**
 * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
 */
export type IContractTermSecurityLabel = fhir.IBackboneElement & {
  /**
   * Security label privacy tag that species the applicable privacy and security policies governing this term and/or term elements.
   */
  category?: fhir.ICoding[]|undefined;
  /**
   * Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements.
   */
  classification: fhir.ICoding|null;
  /**
   * Security label privacy tag that species the manner in which term and/or term elements are to be protected.
   */
  control?: fhir.ICoding[]|undefined;
  /**
   * Number used to link this term or term element to the applicable Security Label.
   */
  number?: number[]|undefined;
  _number?: fhir.IFhirElement[]|undefined;
}
/**
 * Offer Recipient.
 */
export type IContractTermOfferParty = fhir.IBackboneElement & {
  /**
   * Participant in the offer.
   */
  reference: fhir.IReference[]|null;
  /**
   * How the party participates in the offer.
   */
  role: fhir.ICodeableConcept|null;
}
/**
 * Response to offer text.
 */
export type IContractTermOfferAnswer = fhir.IBackboneElement & {
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueBoolean?: boolean|undefined;
  _valueBoolean?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueDecimal?: number|undefined;
  _valueDecimal?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueInteger?: number|undefined;
  _valueInteger?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueDate?: string|undefined;
  _valueDate?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueDateTime?: string|undefined;
  _valueDateTime?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueTime?: string|undefined;
  _valueTime?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueString?: string|undefined;
  _valueString?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueUri?: string|undefined;
  _valueUri?: fhir.IFhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueAttachment?: fhir.IAttachment|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueCoding?: fhir.ICoding|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueQuantity?: fhir.IQuantity|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  valueReference?: fhir.IReference|undefined;
}
/**
 * The matter of concern in the context of this provision of the agrement.
 */
export type IContractTermOffer = fhir.IBackboneElement & {
  /**
   * Response to offer text.
   */
  answer?: fhir.IContractTermOfferAnswer[]|undefined;
  /**
   * Type of choice made by accepting party with respect to an offer made by an offeror/ grantee.
   */
  decision?: fhir.ICodeableConcept|undefined;
  /**
   * How the decision about a Contract was conveyed.
   */
  decisionMode?: fhir.ICodeableConcept[]|undefined;
  /**
   * Unique identifier for this particular Contract Provision.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The id of the clause or question text of the offer in the referenced questionnaire/response.
   */
  linkId?: string[]|undefined;
  _linkId?: fhir.IFhirElement[]|undefined;
  /**
   * Offer Recipient.
   */
  party?: fhir.IContractTermOfferParty[]|undefined;
  /**
   * Security labels that protects the offer.
   */
  securityLabelNumber?: number[]|undefined;
  _securityLabelNumber?: fhir.IFhirElement[]|undefined;
  /**
   * Human readable form of this Contract Offer.
   */
  text?: string|undefined;
  _text?: fhir.IFhirElement|undefined;
  /**
   * The Contract.topic may be an application for or offer of a policy or service (e.g., uri to a consent directive form or a health insurance policy), which becomes the Contract once accepted by both the grantor and grantee. 
   * The Contract Resource may function simply as the computable representation of the executed contract, which may be the attached to the Contract Resource as the “binding” or as the “friendly” electronic form.  For example, a Contract Resource may be automatically populated with the values expressed in a related QuestionnaireResponse. 
   * However, the Contract Resource may be considered the legally binding contract if it is the only “executed” form of this contract, and includes the signatures as *The Contract Resource may function as the computable representation of an application or offer in a pre-executed Contract if the grantor has not entered any values.  In this case, it is populated with values in a “legal” form of the application or offer or by the values in an associated Questionnaire.  If the grantor has filled in the legal form or the associated Questionnaire Response, then these values are used to populate a pre-executed Contract Resource.
   * If the Contract.topic is considered an application or offer, then the policy is often required to be attached as the “legal” basis for the application to ensure “informed consent” to the contract, and that any discrepancy between the application and the policy are interpreted against the policy.  Implementers should check organizational and jurisdictional policies to determine the relationship among multiple representations of a contract pre- and post-execution.
   */
  topic?: fhir.IReference|undefined;
  /**
   * Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Circumstance of the asset.
 */
export type IContractTermAssetContext = fhir.IBackboneElement & {
  /**
   * Coded representation of the context generally or of the Referenced entity, such as the asset holder type or location.
   */
  code?: fhir.ICodeableConcept[]|undefined;
  /**
   * Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
   */
  reference?: fhir.IReference|undefined;
  /**
   * Context description.
   */
  text?: string|undefined;
  _text?: fhir.IFhirElement|undefined;
}
/**
 * Contract Valued Item List.
 */
export type IContractTermAssetValuedItem = fhir.IBackboneElement & {
  /**
   * Indicates the time during which this Contract ValuedItem information is effective.
   */
  effectiveTime?: string|undefined;
  _effectiveTime?: fhir.IFhirElement|undefined;
  /**
   * Specific type of Contract Valued Item that may be priced.
   */
  entityCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Specific type of Contract Valued Item that may be priced.
   */
  entityReference?: fhir.IReference|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  factor?: number|undefined;
  _factor?: fhir.IFhirElement|undefined;
  /**
   * Identifies a Contract Valued Item instance.
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * Id  of the clause or question text related to the context of this valuedItem in the referenced form or QuestionnaireResponse.
   */
  linkId?: string[]|undefined;
  _linkId?: fhir.IFhirElement[]|undefined;
  /**
   * Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  net?: fhir.IMoney|undefined;
  /**
   * Terms of valuation.
   */
  payment?: string|undefined;
  _payment?: fhir.IFhirElement|undefined;
  /**
   * When payment is due.
   */
  paymentDate?: string|undefined;
  _paymentDate?: fhir.IFhirElement|undefined;
  /**
   * An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
   */
  points?: number|undefined;
  _points?: fhir.IFhirElement|undefined;
  /**
   * Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
   */
  quantity?: fhir.IQuantity|undefined;
  /**
   * Who will receive payment.
   */
  recipient?: fhir.IReference|undefined;
  /**
   * Who will make payment.
   */
  responsible?: fhir.IReference|undefined;
  /**
   * A set of security labels that define which terms are controlled by this condition.
   */
  securityLabelNumber?: number[]|undefined;
  _securityLabelNumber?: fhir.IFhirElement[]|undefined;
  /**
   * A Contract Valued Item unit valuation measure.
   */
  unitPrice?: fhir.IMoney|undefined;
}
/**
 * Contract Term Asset List.
 */
export type IContractTermAsset = fhir.IBackboneElement & {
  /**
   * Response to assets.
   */
  answer?: fhir.IContractTermOfferAnswer[]|undefined;
  /**
   * Description of the quality and completeness of the asset that imay be a factor in its valuation.
   */
  condition?: string|undefined;
  _condition?: fhir.IFhirElement|undefined;
  /**
   * Circumstance of the asset.
   */
  context?: fhir.IContractTermAssetContext[]|undefined;
  /**
   * Id [identifier??] of the clause or question text about the asset in the referenced form or QuestionnaireResponse.
   */
  linkId?: string[]|undefined;
  _linkId?: fhir.IFhirElement[]|undefined;
  /**
   * Asset relevant contractual time period.
   */
  period?: fhir.IPeriod[]|undefined;
  /**
   * Type of Asset availability for use or ownership.
   */
  periodType?: fhir.ICodeableConcept[]|undefined;
  /**
   * Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree.
   */
  relationship?: fhir.ICoding|undefined;
  /**
   * Differentiates the kind of the asset .
   */
  scope?: fhir.ICodeableConcept|undefined;
  /**
   * Security labels that protects the asset.
   */
  securityLabelNumber?: number[]|undefined;
  _securityLabelNumber?: fhir.IFhirElement[]|undefined;
  /**
   * May be a subtype or part of an offered asset.
   */
  subtype?: fhir.ICodeableConcept[]|undefined;
  /**
   * Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
   */
  text?: string|undefined;
  _text?: fhir.IFhirElement|undefined;
  /**
   * Target entity type about which the term may be concerned.
   */
  type?: fhir.ICodeableConcept[]|undefined;
  /**
   * Associated entities.
   */
  typeReference?: fhir.IReference[]|undefined;
  /**
   * Time period of asset use.
   */
  usePeriod?: fhir.IPeriod[]|undefined;
  /**
   * Contract Valued Item List.
   */
  valuedItem?: fhir.IContractTermAssetValuedItem[]|undefined;
}
/**
 * Entity of the action.
 */
export type IContractTermActionSubject = fhir.IBackboneElement & {
  /**
   * The entity the action is performed or not performed on or for.
   */
  reference: fhir.IReference[]|null;
  /**
   * Role type of agent assigned roles in this Contract.
   */
  role?: fhir.ICodeableConcept|undefined;
}
/**
 * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
 * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
 */
export type IContractTermAction = fhir.IBackboneElement & {
  /**
   * Encounter or Episode with primary association to specified term activity.
   */
  context?: fhir.IReference|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
   */
  contextLinkId?: string[]|undefined;
  _contextLinkId?: fhir.IFhirElement[]|undefined;
  /**
   * True if the term prohibits the  action.
   */
  doNotPerform?: boolean|undefined;
  _doNotPerform?: fhir.IFhirElement|undefined;
  /**
   * Reason or purpose for the action stipulated by this Contract Provision.
   */
  intent: fhir.ICodeableConcept|null;
  /**
   * Id [identifier??] of the clause or question text related to this action in the referenced form or QuestionnaireResponse.
   */
  linkId?: string[]|undefined;
  _linkId?: fhir.IFhirElement[]|undefined;
  /**
   * Comments made about the term action made by the requester, performer, subject or other participants.
   */
  note?: fhir.IAnnotation[]|undefined;
  /**
   * When action happens.
   */
  occurrenceDateTime?: string|undefined;
  _occurrenceDateTime?: fhir.IFhirElement|undefined;
  /**
   * When action happens.
   */
  occurrencePeriod?: fhir.IPeriod|undefined;
  /**
   * When action happens.
   */
  occurrenceTiming?: fhir.ITiming|undefined;
  /**
   * Indicates who or what is being asked to perform (or not perform) the ction.
   */
  performer?: fhir.IReference|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
   */
  performerLinkId?: string[]|undefined;
  _performerLinkId?: fhir.IFhirElement[]|undefined;
  /**
   * The type of role or competency of an individual desired or required to perform or not perform the action.
   */
  performerRole?: fhir.ICodeableConcept|undefined;
  /**
   * The type of individual that is desired or required to perform or not perform the action.
   */
  performerType?: fhir.ICodeableConcept[]|undefined;
  /**
   * Describes why the action is to be performed or not performed in textual form.
   */
  reason?: string[]|undefined;
  _reason?: fhir.IFhirElement[]|undefined;
  /**
   * Rationale for the action to be performed or not performed. Describes why the action is permitted or prohibited.
   */
  reasonCode?: fhir.ICodeableConcept[]|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
   */
  reasonLinkId?: string[]|undefined;
  _reasonLinkId?: fhir.IFhirElement[]|undefined;
  /**
   * Indicates another resource whose existence justifies permitting or not permitting this action.
   */
  reasonReference?: fhir.IReference[]|undefined;
  /**
   * Who or what initiated the action and has responsibility for its activation.
   */
  requester?: fhir.IReference[]|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
   */
  requesterLinkId?: string[]|undefined;
  _requesterLinkId?: fhir.IFhirElement[]|undefined;
  /**
   * Security labels that protects the action.
   */
  securityLabelNumber?: number[]|undefined;
  _securityLabelNumber?: fhir.IFhirElement[]|undefined;
  /**
   * Current state of the term action.
   */
  status: fhir.ICodeableConcept|null;
  /**
   * Entity of the action.
   */
  subject?: fhir.IContractTermActionSubject[]|undefined;
  /**
   * Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term.
   */
  type: fhir.ICodeableConcept|null;
}
/**
 * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
 */
export type IContractTerm = fhir.IBackboneElement & {
  /**
   * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
   * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
   */
  action?: fhir.IContractTermAction[]|undefined;
  /**
   * Relevant time or time-period when this Contract Provision is applicable.
   */
  applies?: fhir.IPeriod|undefined;
  /**
   * Contract Term Asset List.
   */
  asset?: fhir.IContractTermAsset[]|undefined;
  /**
   * Nested group of Contract Provisions.
   */
  group?: fhir.IContractTerm[]|undefined;
  /**
   * Unique identifier for this particular Contract Provision.
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * When this Contract Provision was issued.
   */
  issued?: string|undefined;
  _issued?: fhir.IFhirElement|undefined;
  /**
   * The matter of concern in the context of this provision of the agrement.
   */
  offer: fhir.IContractTermOffer|null;
  /**
   * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
   */
  securityLabel?: fhir.IContractTermSecurityLabel[]|undefined;
  /**
   * A specialized legal clause or condition based on overarching contract type.
   */
  subType?: fhir.ICodeableConcept|undefined;
  /**
   * Statement of a provision in a policy or a contract.
   */
  text?: string|undefined;
  _text?: fhir.IFhirElement|undefined;
  /**
   * The entity that the term applies to.
   */
  topicCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * The entity that the term applies to.
   */
  topicReference?: fhir.IReference|undefined;
  /**
   * A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
 * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
 */
export type IContractSigner = fhir.IBackboneElement & {
  /**
   * Party which is a signator to this Contract.
   */
  party: fhir.IReference|null;
  /**
   * Legally binding Contract DSIG signature contents in Base64.
   */
  signature: fhir.ISignature[]|null;
  /**
   * Role of this Contract signer, e.g. notary, grantee.
   */
  type: fhir.ICoding|null;
}
/**
 * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
 */
export type IContractFriendly = fhir.IBackboneElement & {
  /**
   * Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
   */
  contentAttachment?: fhir.IAttachment|undefined;
  /**
   * Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
   */
  contentReference?: fhir.IReference|undefined;
}
/**
 * List of Legal expressions or representations of this Contract.
 */
export type IContractLegal = fhir.IBackboneElement & {
  /**
   * Contract legal text in human renderable form.
   */
  contentAttachment?: fhir.IAttachment|undefined;
  /**
   * Contract legal text in human renderable form.
   */
  contentReference?: fhir.IReference|undefined;
}
/**
 * List of Computable Policy Rule Language Representations of this Contract.
 */
export type IContractRule = fhir.IBackboneElement & {
  /**
   * Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
   */
  contentAttachment?: fhir.IAttachment|undefined;
  /**
   * Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
   */
  contentReference?: fhir.IReference|undefined;
}
/**
 * Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
 */
export type IContract = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "Contract";
  /**
   * Alternative representation of the title for this Contract definition, derivative, or instance in any legal state., e.g., a domain specific contract number related to legislation.
   */
  alias?: string[]|undefined;
  _alias?: fhir.IFhirElement[]|undefined;
  /**
   * Relevant time or time-period when this Contract is applicable.
   */
  applies?: fhir.IPeriod|undefined;
  /**
   * The individual or organization that authored the Contract definition, derivative, or instance in any legal state.
   */
  author?: fhir.IReference|undefined;
  /**
   * A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
   */
  authority?: fhir.IReference[]|undefined;
  /**
   * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
   */
  contentDefinition?: fhir.IContractContentDefinition|undefined;
  /**
   * The minimal content derived from the basal information source at a specific stage in its lifecycle.
   */
  contentDerivative?: fhir.ICodeableConcept|undefined;
  /**
   * Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
   */
  domain?: fhir.IReference[]|undefined;
  /**
   * Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract.
   */
  expirationType?: fhir.ICodeableConcept|undefined;
  /**
   * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
   */
  friendly?: fhir.IContractFriendly[]|undefined;
  /**
   * Unique identifier for this Contract or a derivative that references a Source Contract.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract.
   */
  instantiatesCanonical?: fhir.IReference|undefined;
  /**
   * The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
   */
  instantiatesUri?: string|undefined;
  _instantiatesUri?: fhir.IFhirElement|undefined;
  /**
   * When this  Contract was issued.
   */
  issued?: string|undefined;
  _issued?: fhir.IFhirElement|undefined;
  /**
   * List of Legal expressions or representations of this Contract.
   */
  legal?: fhir.IContractLegal[]|undefined;
  /**
   * Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
   */
  legallyBindingAttachment?: fhir.IAttachment|undefined;
  /**
   * Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
   */
  legallyBindingReference?: fhir.IReference|undefined;
  /**
   * Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement.
   */
  legalState?: fhir.ICodeableConcept|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  name?: string|undefined;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Links to Provenance records for past versions of this Contract definition, derivative, or instance, which identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the Contract.  The Provence.entity indicates the target that was changed in the update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
   */
  relevantHistory?: fhir.IReference[]|undefined;
  /**
   * List of Computable Policy Rule Language Representations of this Contract.
   */
  rule?: fhir.IContractRule[]|undefined;
  /**
   * A selector of legal concerns for this Contract definition, derivative, or instance in any legal state.
   */
  scope?: fhir.ICodeableConcept|undefined;
  /**
   * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
   * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
   */
  signer?: fhir.IContractSigner[]|undefined;
  /**
   * Sites in which the contract is complied with,  exercised, or in force.
   */
  site?: fhir.IReference[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the contract as not currently valid or active.
   */
  status?: ContractStatusEnum|undefined;
  _status?: fhir.IFhirElement|undefined;
  /**
   * The Contract.subject is an entity that has some role with respect to the Contract.topic and Contract.topic.term, which is of focal interest to the parties to the contract and likely impacted in a significant way by the Contract.action/Contract.action.reason and the Contract.term.action/Contract.action.reason. 
   * In many cases, the Contract.subject is a Contract.signer if the subject is an adult; has a legal interest in the contract; and incompetent to participate in the contract agreement.
   */
  subject?: fhir.IReference[]|undefined;
  /**
   * An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
   */
  subtitle?: string|undefined;
  _subtitle?: fhir.IFhirElement|undefined;
  /**
   * Sub-category for the Contract that distinguishes the kinds of systems that would be interested in the Contract within the context of the Contract's scope.
   */
  subType?: fhir.ICodeableConcept[]|undefined;
  /**
   * Information that may be needed by/relevant to the performer in their execution of this term action.
   */
  supportingInfo?: fhir.IReference[]|undefined;
  /**
   * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
   */
  term?: fhir.IContractTerm[]|undefined;
  /**
   * A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
   */
  title?: string|undefined;
  _title?: fhir.IFhirElement|undefined;
  /**
   * Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
   */
  topicCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
   */
  topicReference?: fhir.IReference|undefined;
  /**
   * A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract.
   */
  type?: fhir.ICodeableConcept|undefined;
  /**
   * Used in a domain that uses a supplied contract repository.
   */
  url?: string|undefined;
  _url?: fhir.IFhirElement|undefined;
  /**
   * Note -  This is a business versionId, not a resource version id (see discussion http://build.fhir.org/resource.html#versions) 
   * Comments - There may be different contract instances that have the same identifier but different versions. The version can be appended to the url in a reference to allow a reference to a particular business version of the plan definition with the format [url]|[version].
   */
  version?: string|undefined;
  _version?: fhir.IFhirElement|undefined;
}
/**
 * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
 */
export class ContractContentDefinition extends fhir.BackboneElement implements fhir.IContractContentDefinition {
  /**
   * A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
   */
  public copyright?: string|undefined;
  public _copyright?: fhir.FhirElement|undefined;
  /**
   * The date (and optionally time) when the contract was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
   */
  public publicationDate?: string|undefined;
  public _publicationDate?: fhir.FhirElement|undefined;
  /**
   * amended | appended | cancelled | disputed | entered-in-error | executable | executed | negotiable | offered | policy | rejected | renewed | revoked | resolved | terminated.
   */
  public publicationStatus: ContractContentDefinitionPublicationStatusEnum|null;
  public _publicationStatus?: fhir.FhirElement|undefined;
  /**
   * The  individual or organization that published the Contract precursor content.
   */
  public publisher?: fhir.Reference|undefined;
  /**
   * Detailed Precusory content type.
   */
  public subType?: fhir.CodeableConcept|undefined;
  /**
   * Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * Default constructor for ContractContentDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractContentDefinition> = {}) {
    super(source);
    if (source["copyright"]) { this.copyright = source.copyright; }
    if (source["_copyright"]) { this._copyright = new fhir.FhirElement(source._copyright!); }
    if (source["publicationDate"]) { this.publicationDate = source.publicationDate; }
    if (source["_publicationDate"]) { this._publicationDate = new fhir.FhirElement(source._publicationDate!); }
    this.publicationStatus = null;
    if (source["publicationStatus"]) { this.publicationStatus = source.publicationStatus; }
    if (this.publicationStatus === undefined) { this.publicationStatus = null }
    if (source["_publicationStatus"]) { this._publicationStatus = new fhir.FhirElement(source._publicationStatus!); }
    if (source["publisher"]) { this.publisher = new fhir.Reference(source.publisher!); }
    if (source["subType"]) { this.subType = new fhir.CodeableConcept(source.subType!); }
    this.type = null;
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
    if (this.type === undefined) { this.type = null }
  }
  /**
   * Check if the current ContractContentDefinition contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["publicationStatus"] === undefined) { missingElements.push("publicationStatus"); }
    if (this["type"] === undefined) { missingElements.push("type"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractContentDefinition from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractContentDefinition):ContractContentDefinition {
    var dest:ContractContentDefinition = new ContractContentDefinition(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractContentDefinition is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
 */
export class ContractTermSecurityLabel extends fhir.BackboneElement implements fhir.IContractTermSecurityLabel {
  /**
   * Security label privacy tag that species the applicable privacy and security policies governing this term and/or term elements.
   */
  public category?: fhir.Coding[]|undefined;
  /**
   * Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements.
   */
  public classification: fhir.Coding|null;
  /**
   * Security label privacy tag that species the manner in which term and/or term elements are to be protected.
   */
  public control?: fhir.Coding[]|undefined;
  /**
   * Number used to link this term or term element to the applicable Security Label.
   */
  public number?: number[]|undefined;
  public _number?: fhir.FhirElement[]|undefined;
  /**
   * Default constructor for ContractTermSecurityLabel - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermSecurityLabel> = {}) {
    super(source);
    if (source["category"]) { this.category = source.category.map((x:Partial<fhir.ICoding>) => new fhir.Coding(x)); }
    this.classification = null;
    if (source["classification"]) { this.classification = new fhir.Coding(source.classification!); }
    if (this.classification === undefined) { this.classification = null }
    if (source["control"]) { this.control = source.control.map((x:Partial<fhir.ICoding>) => new fhir.Coding(x)); }
    if (source["number"]) { this.number = source.number.map((x) => (x)); }
    if (source["_number"]) { this._number = source._number.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
  }
  /**
   * Check if the current ContractTermSecurityLabel contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["classification"] === undefined) { missingElements.push("classification"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermSecurityLabel from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermSecurityLabel):ContractTermSecurityLabel {
    var dest:ContractTermSecurityLabel = new ContractTermSecurityLabel(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermSecurityLabel is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Offer Recipient.
 */
export class ContractTermOfferParty extends fhir.BackboneElement implements fhir.IContractTermOfferParty {
  /**
   * Participant in the offer.
   */
  public reference: fhir.Reference[]|null;
  /**
   * How the party participates in the offer.
   */
  public role: fhir.CodeableConcept|null;
  /**
   * Default constructor for ContractTermOfferParty - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermOfferParty> = {}) {
    super(source);
    this.reference = null;
    if (source["reference"]) { this.reference = source.reference.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (this.reference === undefined) { this.reference = null }
    this.role = null;
    if (source["role"]) { this.role = new fhir.CodeableConcept(source.role!); }
    if (this.role === undefined) { this.role = null }
  }
  /**
   * Check if the current ContractTermOfferParty contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if ((!this["reference"]) || (this["reference"].length === 0)) { missingElements.push("reference"); }
    if (this["role"] === undefined) { missingElements.push("role"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermOfferParty from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermOfferParty):ContractTermOfferParty {
    var dest:ContractTermOfferParty = new ContractTermOfferParty(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermOfferParty is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Response to offer text.
 */
export class ContractTermOfferAnswer extends fhir.BackboneElement implements fhir.IContractTermOfferAnswer {
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueBoolean?: boolean|undefined;
  public _valueBoolean?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueDecimal?: number|undefined;
  public _valueDecimal?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueInteger?: number|undefined;
  public _valueInteger?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueDate?: string|undefined;
  public _valueDate?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueDateTime?: string|undefined;
  public _valueDateTime?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueTime?: string|undefined;
  public _valueTime?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueString?: string|undefined;
  public _valueString?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueUri?: string|undefined;
  public _valueUri?: fhir.FhirElement|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueAttachment?: fhir.Attachment|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueCoding?: fhir.Coding|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueQuantity?: fhir.Quantity|undefined;
  /**
   * Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
   */
  public valueReference?: fhir.Reference|undefined;
  /**
   * Default constructor for ContractTermOfferAnswer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermOfferAnswer> = {}) {
    super(source);
    if (source["valueBoolean"]) { this.valueBoolean = source.valueBoolean; }
    if (source["_valueBoolean"]) { this._valueBoolean = new fhir.FhirElement(source._valueBoolean!); }
    if (source["valueDecimal"]) { this.valueDecimal = source.valueDecimal; }
    if (source["_valueDecimal"]) { this._valueDecimal = new fhir.FhirElement(source._valueDecimal!); }
    if (source["valueInteger"]) { this.valueInteger = source.valueInteger; }
    if (source["_valueInteger"]) { this._valueInteger = new fhir.FhirElement(source._valueInteger!); }
    if (source["valueDate"]) { this.valueDate = source.valueDate; }
    if (source["_valueDate"]) { this._valueDate = new fhir.FhirElement(source._valueDate!); }
    if (source["valueDateTime"]) { this.valueDateTime = source.valueDateTime; }
    if (source["_valueDateTime"]) { this._valueDateTime = new fhir.FhirElement(source._valueDateTime!); }
    if (source["valueTime"]) { this.valueTime = source.valueTime; }
    if (source["_valueTime"]) { this._valueTime = new fhir.FhirElement(source._valueTime!); }
    if (source["valueString"]) { this.valueString = source.valueString; }
    if (source["_valueString"]) { this._valueString = new fhir.FhirElement(source._valueString!); }
    if (source["valueUri"]) { this.valueUri = source.valueUri; }
    if (source["_valueUri"]) { this._valueUri = new fhir.FhirElement(source._valueUri!); }
    if (source["valueAttachment"]) { this.valueAttachment = new fhir.Attachment(source.valueAttachment!); }
    if (source["valueCoding"]) { this.valueCoding = new fhir.Coding(source.valueCoding!); }
    if (source["valueQuantity"]) { this.valueQuantity = new fhir.Quantity(source.valueQuantity!); }
    if (source["valueReference"]) { this.valueReference = new fhir.Reference(source.valueReference!); }
  }
  /**
   * Check if the current ContractTermOfferAnswer contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermOfferAnswer from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermOfferAnswer):ContractTermOfferAnswer {
    var dest:ContractTermOfferAnswer = new ContractTermOfferAnswer(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermOfferAnswer is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The matter of concern in the context of this provision of the agrement.
 */
export class ContractTermOffer extends fhir.BackboneElement implements fhir.IContractTermOffer {
  /**
   * Response to offer text.
   */
  public answer?: fhir.ContractTermOfferAnswer[]|undefined;
  /**
   * Type of choice made by accepting party with respect to an offer made by an offeror/ grantee.
   */
  public decision?: fhir.CodeableConcept|undefined;
  /**
   * How the decision about a Contract was conveyed.
   */
  public decisionMode?: fhir.CodeableConcept[]|undefined;
  /**
   * Unique identifier for this particular Contract Provision.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The id of the clause or question text of the offer in the referenced questionnaire/response.
   */
  public linkId?: string[]|undefined;
  public _linkId?: fhir.FhirElement[]|undefined;
  /**
   * Offer Recipient.
   */
  public party?: fhir.ContractTermOfferParty[]|undefined;
  /**
   * Security labels that protects the offer.
   */
  public securityLabelNumber?: number[]|undefined;
  public _securityLabelNumber?: fhir.FhirElement[]|undefined;
  /**
   * Human readable form of this Contract Offer.
   */
  public text?: string|undefined;
  public _text?: fhir.FhirElement|undefined;
  /**
   * The Contract.topic may be an application for or offer of a policy or service (e.g., uri to a consent directive form or a health insurance policy), which becomes the Contract once accepted by both the grantor and grantee. 
   * The Contract Resource may function simply as the computable representation of the executed contract, which may be the attached to the Contract Resource as the “binding” or as the “friendly” electronic form.  For example, a Contract Resource may be automatically populated with the values expressed in a related QuestionnaireResponse. 
   * However, the Contract Resource may be considered the legally binding contract if it is the only “executed” form of this contract, and includes the signatures as *The Contract Resource may function as the computable representation of an application or offer in a pre-executed Contract if the grantor has not entered any values.  In this case, it is populated with values in a “legal” form of the application or offer or by the values in an associated Questionnaire.  If the grantor has filled in the legal form or the associated Questionnaire Response, then these values are used to populate a pre-executed Contract Resource.
   * If the Contract.topic is considered an application or offer, then the policy is often required to be attached as the “legal” basis for the application to ensure “informed consent” to the contract, and that any discrepancy between the application and the policy are interpreted against the policy.  Implementers should check organizational and jurisdictional policies to determine the relationship among multiple representations of a contract pre- and post-execution.
   */
  public topic?: fhir.Reference|undefined;
  /**
   * Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ContractTermOffer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermOffer> = {}) {
    super(source);
    if (source["answer"]) { this.answer = source.answer.map((x:Partial<fhir.IContractTermOfferAnswer>) => new fhir.ContractTermOfferAnswer(x)); }
    if (source["decision"]) { this.decision = new fhir.CodeableConcept(source.decision!); }
    if (source["decisionMode"]) { this.decisionMode = source.decisionMode.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["linkId"]) { this.linkId = source.linkId.map((x) => (x)); }
    if (source["_linkId"]) { this._linkId = source._linkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["party"]) { this.party = source.party.map((x:Partial<fhir.IContractTermOfferParty>) => new fhir.ContractTermOfferParty(x)); }
    if (source["securityLabelNumber"]) { this.securityLabelNumber = source.securityLabelNumber.map((x) => (x)); }
    if (source["_securityLabelNumber"]) { this._securityLabelNumber = source._securityLabelNumber.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["text"]) { this.text = source.text; }
    if (source["_text"]) { this._text = new fhir.FhirElement(source._text!); }
    if (source["topic"]) { this.topic = new fhir.Reference(source.topic!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current ContractTermOffer contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermOffer from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermOffer):ContractTermOffer {
    var dest:ContractTermOffer = new ContractTermOffer(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermOffer is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Circumstance of the asset.
 */
export class ContractTermAssetContext extends fhir.BackboneElement implements fhir.IContractTermAssetContext {
  /**
   * Coded representation of the context generally or of the Referenced entity, such as the asset holder type or location.
   */
  public code?: fhir.CodeableConcept[]|undefined;
  /**
   * Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
   */
  public reference?: fhir.Reference|undefined;
  /**
   * Context description.
   */
  public text?: string|undefined;
  public _text?: fhir.FhirElement|undefined;
  /**
   * Default constructor for ContractTermAssetContext - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermAssetContext> = {}) {
    super(source);
    if (source["code"]) { this.code = source.code.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["reference"]) { this.reference = new fhir.Reference(source.reference!); }
    if (source["text"]) { this.text = source.text; }
    if (source["_text"]) { this._text = new fhir.FhirElement(source._text!); }
  }
  /**
   * Check if the current ContractTermAssetContext contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermAssetContext from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermAssetContext):ContractTermAssetContext {
    var dest:ContractTermAssetContext = new ContractTermAssetContext(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermAssetContext is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Contract Valued Item List.
 */
export class ContractTermAssetValuedItem extends fhir.BackboneElement implements fhir.IContractTermAssetValuedItem {
  /**
   * Indicates the time during which this Contract ValuedItem information is effective.
   */
  public effectiveTime?: string|undefined;
  public _effectiveTime?: fhir.FhirElement|undefined;
  /**
   * Specific type of Contract Valued Item that may be priced.
   */
  public entityCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Specific type of Contract Valued Item that may be priced.
   */
  public entityReference?: fhir.Reference|undefined;
  /**
   * A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
   */
  public factor?: number|undefined;
  public _factor?: fhir.FhirElement|undefined;
  /**
   * Identifies a Contract Valued Item instance.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Id  of the clause or question text related to the context of this valuedItem in the referenced form or QuestionnaireResponse.
   */
  public linkId?: string[]|undefined;
  public _linkId?: fhir.FhirElement[]|undefined;
  /**
   * Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
   */
  public net?: fhir.Money|undefined;
  /**
   * Terms of valuation.
   */
  public payment?: string|undefined;
  public _payment?: fhir.FhirElement|undefined;
  /**
   * When payment is due.
   */
  public paymentDate?: string|undefined;
  public _paymentDate?: fhir.FhirElement|undefined;
  /**
   * An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
   */
  public points?: number|undefined;
  public _points?: fhir.FhirElement|undefined;
  /**
   * Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * Who will receive payment.
   */
  public recipient?: fhir.Reference|undefined;
  /**
   * Who will make payment.
   */
  public responsible?: fhir.Reference|undefined;
  /**
   * A set of security labels that define which terms are controlled by this condition.
   */
  public securityLabelNumber?: number[]|undefined;
  public _securityLabelNumber?: fhir.FhirElement[]|undefined;
  /**
   * A Contract Valued Item unit valuation measure.
   */
  public unitPrice?: fhir.Money|undefined;
  /**
   * Default constructor for ContractTermAssetValuedItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermAssetValuedItem> = {}) {
    super(source);
    if (source["effectiveTime"]) { this.effectiveTime = source.effectiveTime; }
    if (source["_effectiveTime"]) { this._effectiveTime = new fhir.FhirElement(source._effectiveTime!); }
    if (source["entityCodeableConcept"]) { this.entityCodeableConcept = new fhir.CodeableConcept(source.entityCodeableConcept!); }
    if (source["entityReference"]) { this.entityReference = new fhir.Reference(source.entityReference!); }
    if (source["factor"]) { this.factor = source.factor; }
    if (source["_factor"]) { this._factor = new fhir.FhirElement(source._factor!); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["linkId"]) { this.linkId = source.linkId.map((x) => (x)); }
    if (source["_linkId"]) { this._linkId = source._linkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["net"]) { this.net = new fhir.Money(source.net!); }
    if (source["payment"]) { this.payment = source.payment; }
    if (source["_payment"]) { this._payment = new fhir.FhirElement(source._payment!); }
    if (source["paymentDate"]) { this.paymentDate = source.paymentDate; }
    if (source["_paymentDate"]) { this._paymentDate = new fhir.FhirElement(source._paymentDate!); }
    if (source["points"]) { this.points = source.points; }
    if (source["_points"]) { this._points = new fhir.FhirElement(source._points!); }
    if (source["quantity"]) { this.quantity = new fhir.Quantity(source.quantity!); }
    if (source["recipient"]) { this.recipient = new fhir.Reference(source.recipient!); }
    if (source["responsible"]) { this.responsible = new fhir.Reference(source.responsible!); }
    if (source["securityLabelNumber"]) { this.securityLabelNumber = source.securityLabelNumber.map((x) => (x)); }
    if (source["_securityLabelNumber"]) { this._securityLabelNumber = source._securityLabelNumber.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["unitPrice"]) { this.unitPrice = new fhir.Money(source.unitPrice!); }
  }
  /**
   * Check if the current ContractTermAssetValuedItem contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermAssetValuedItem from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermAssetValuedItem):ContractTermAssetValuedItem {
    var dest:ContractTermAssetValuedItem = new ContractTermAssetValuedItem(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermAssetValuedItem is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Contract Term Asset List.
 */
export class ContractTermAsset extends fhir.BackboneElement implements fhir.IContractTermAsset {
  /**
   * Response to assets.
   */
  public answer?: fhir.ContractTermOfferAnswer[]|undefined;
  /**
   * Description of the quality and completeness of the asset that imay be a factor in its valuation.
   */
  public condition?: string|undefined;
  public _condition?: fhir.FhirElement|undefined;
  /**
   * Circumstance of the asset.
   */
  public context?: fhir.ContractTermAssetContext[]|undefined;
  /**
   * Id [identifier??] of the clause or question text about the asset in the referenced form or QuestionnaireResponse.
   */
  public linkId?: string[]|undefined;
  public _linkId?: fhir.FhirElement[]|undefined;
  /**
   * Asset relevant contractual time period.
   */
  public period?: fhir.Period[]|undefined;
  /**
   * Type of Asset availability for use or ownership.
   */
  public periodType?: fhir.CodeableConcept[]|undefined;
  /**
   * Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree.
   */
  public relationship?: fhir.Coding|undefined;
  /**
   * Differentiates the kind of the asset .
   */
  public scope?: fhir.CodeableConcept|undefined;
  /**
   * Security labels that protects the asset.
   */
  public securityLabelNumber?: number[]|undefined;
  public _securityLabelNumber?: fhir.FhirElement[]|undefined;
  /**
   * May be a subtype or part of an offered asset.
   */
  public subtype?: fhir.CodeableConcept[]|undefined;
  /**
   * Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
   */
  public text?: string|undefined;
  public _text?: fhir.FhirElement|undefined;
  /**
   * Target entity type about which the term may be concerned.
   */
  public type?: fhir.CodeableConcept[]|undefined;
  /**
   * Associated entities.
   */
  public typeReference?: fhir.Reference[]|undefined;
  /**
   * Time period of asset use.
   */
  public usePeriod?: fhir.Period[]|undefined;
  /**
   * Contract Valued Item List.
   */
  public valuedItem?: fhir.ContractTermAssetValuedItem[]|undefined;
  /**
   * Default constructor for ContractTermAsset - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermAsset> = {}) {
    super(source);
    if (source["answer"]) { this.answer = source.answer.map((x:Partial<fhir.IContractTermOfferAnswer>) => new fhir.ContractTermOfferAnswer(x)); }
    if (source["condition"]) { this.condition = source.condition; }
    if (source["_condition"]) { this._condition = new fhir.FhirElement(source._condition!); }
    if (source["context"]) { this.context = source.context.map((x:Partial<fhir.IContractTermAssetContext>) => new fhir.ContractTermAssetContext(x)); }
    if (source["linkId"]) { this.linkId = source.linkId.map((x) => (x)); }
    if (source["_linkId"]) { this._linkId = source._linkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["period"]) { this.period = source.period.map((x:Partial<fhir.IPeriod>) => new fhir.Period(x)); }
    if (source["periodType"]) { this.periodType = source.periodType.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["relationship"]) { this.relationship = new fhir.Coding(source.relationship!); }
    if (source["scope"]) { this.scope = new fhir.CodeableConcept(source.scope!); }
    if (source["securityLabelNumber"]) { this.securityLabelNumber = source.securityLabelNumber.map((x) => (x)); }
    if (source["_securityLabelNumber"]) { this._securityLabelNumber = source._securityLabelNumber.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["subtype"]) { this.subtype = source.subtype.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["text"]) { this.text = source.text; }
    if (source["_text"]) { this._text = new fhir.FhirElement(source._text!); }
    if (source["type"]) { this.type = source.type.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["typeReference"]) { this.typeReference = source.typeReference.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["usePeriod"]) { this.usePeriod = source.usePeriod.map((x:Partial<fhir.IPeriod>) => new fhir.Period(x)); }
    if (source["valuedItem"]) { this.valuedItem = source.valuedItem.map((x:Partial<fhir.IContractTermAssetValuedItem>) => new fhir.ContractTermAssetValuedItem(x)); }
  }
  /**
   * Check if the current ContractTermAsset contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermAsset from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermAsset):ContractTermAsset {
    var dest:ContractTermAsset = new ContractTermAsset(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermAsset is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Entity of the action.
 */
export class ContractTermActionSubject extends fhir.BackboneElement implements fhir.IContractTermActionSubject {
  /**
   * The entity the action is performed or not performed on or for.
   */
  public reference: fhir.Reference[]|null;
  /**
   * Role type of agent assigned roles in this Contract.
   */
  public role?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ContractTermActionSubject - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermActionSubject> = {}) {
    super(source);
    this.reference = null;
    if (source["reference"]) { this.reference = source.reference.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (this.reference === undefined) { this.reference = null }
    if (source["role"]) { this.role = new fhir.CodeableConcept(source.role!); }
  }
  /**
   * Check if the current ContractTermActionSubject contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if ((!this["reference"]) || (this["reference"].length === 0)) { missingElements.push("reference"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermActionSubject from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermActionSubject):ContractTermActionSubject {
    var dest:ContractTermActionSubject = new ContractTermActionSubject(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermActionSubject is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
 * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
 */
export class ContractTermAction extends fhir.BackboneElement implements fhir.IContractTermAction {
  /**
   * Encounter or Episode with primary association to specified term activity.
   */
  public context?: fhir.Reference|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
   */
  public contextLinkId?: string[]|undefined;
  public _contextLinkId?: fhir.FhirElement[]|undefined;
  /**
   * True if the term prohibits the  action.
   */
  public doNotPerform?: boolean|undefined;
  public _doNotPerform?: fhir.FhirElement|undefined;
  /**
   * Reason or purpose for the action stipulated by this Contract Provision.
   */
  public intent: fhir.CodeableConcept|null;
  /**
   * Id [identifier??] of the clause or question text related to this action in the referenced form or QuestionnaireResponse.
   */
  public linkId?: string[]|undefined;
  public _linkId?: fhir.FhirElement[]|undefined;
  /**
   * Comments made about the term action made by the requester, performer, subject or other participants.
   */
  public note?: fhir.Annotation[]|undefined;
  /**
   * When action happens.
   */
  public occurrenceDateTime?: string|undefined;
  public _occurrenceDateTime?: fhir.FhirElement|undefined;
  /**
   * When action happens.
   */
  public occurrencePeriod?: fhir.Period|undefined;
  /**
   * When action happens.
   */
  public occurrenceTiming?: fhir.Timing|undefined;
  /**
   * Indicates who or what is being asked to perform (or not perform) the ction.
   */
  public performer?: fhir.Reference|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
   */
  public performerLinkId?: string[]|undefined;
  public _performerLinkId?: fhir.FhirElement[]|undefined;
  /**
   * The type of role or competency of an individual desired or required to perform or not perform the action.
   */
  public performerRole?: fhir.CodeableConcept|undefined;
  /**
   * The type of individual that is desired or required to perform or not perform the action.
   */
  public performerType?: fhir.CodeableConcept[]|undefined;
  /**
   * Describes why the action is to be performed or not performed in textual form.
   */
  public reason?: string[]|undefined;
  public _reason?: fhir.FhirElement[]|undefined;
  /**
   * Rationale for the action to be performed or not performed. Describes why the action is permitted or prohibited.
   */
  public reasonCode?: fhir.CodeableConcept[]|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
   */
  public reasonLinkId?: string[]|undefined;
  public _reasonLinkId?: fhir.FhirElement[]|undefined;
  /**
   * Indicates another resource whose existence justifies permitting or not permitting this action.
   */
  public reasonReference?: fhir.Reference[]|undefined;
  /**
   * Who or what initiated the action and has responsibility for its activation.
   */
  public requester?: fhir.Reference[]|undefined;
  /**
   * Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
   */
  public requesterLinkId?: string[]|undefined;
  public _requesterLinkId?: fhir.FhirElement[]|undefined;
  /**
   * Security labels that protects the action.
   */
  public securityLabelNumber?: number[]|undefined;
  public _securityLabelNumber?: fhir.FhirElement[]|undefined;
  /**
   * Current state of the term action.
   */
  public status: fhir.CodeableConcept|null;
  /**
   * Entity of the action.
   */
  public subject?: fhir.ContractTermActionSubject[]|undefined;
  /**
   * Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * Default constructor for ContractTermAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTermAction> = {}) {
    super(source);
    if (source["context"]) { this.context = new fhir.Reference(source.context!); }
    if (source["contextLinkId"]) { this.contextLinkId = source.contextLinkId.map((x) => (x)); }
    if (source["_contextLinkId"]) { this._contextLinkId = source._contextLinkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["doNotPerform"]) { this.doNotPerform = source.doNotPerform; }
    if (source["_doNotPerform"]) { this._doNotPerform = new fhir.FhirElement(source._doNotPerform!); }
    this.intent = null;
    if (source["intent"]) { this.intent = new fhir.CodeableConcept(source.intent!); }
    if (this.intent === undefined) { this.intent = null }
    if (source["linkId"]) { this.linkId = source.linkId.map((x) => (x)); }
    if (source["_linkId"]) { this._linkId = source._linkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["note"]) { this.note = source.note.map((x:Partial<fhir.IAnnotation>) => new fhir.Annotation(x)); }
    if (source["occurrenceDateTime"]) { this.occurrenceDateTime = source.occurrenceDateTime; }
    if (source["_occurrenceDateTime"]) { this._occurrenceDateTime = new fhir.FhirElement(source._occurrenceDateTime!); }
    if (source["occurrencePeriod"]) { this.occurrencePeriod = new fhir.Period(source.occurrencePeriod!); }
    if (source["occurrenceTiming"]) { this.occurrenceTiming = new fhir.Timing(source.occurrenceTiming!); }
    if (source["performer"]) { this.performer = new fhir.Reference(source.performer!); }
    if (source["performerLinkId"]) { this.performerLinkId = source.performerLinkId.map((x) => (x)); }
    if (source["_performerLinkId"]) { this._performerLinkId = source._performerLinkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["performerRole"]) { this.performerRole = new fhir.CodeableConcept(source.performerRole!); }
    if (source["performerType"]) { this.performerType = source.performerType.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["reason"]) { this.reason = source.reason.map((x) => (x)); }
    if (source["_reason"]) { this._reason = source._reason.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["reasonCode"]) { this.reasonCode = source.reasonCode.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["reasonLinkId"]) { this.reasonLinkId = source.reasonLinkId.map((x) => (x)); }
    if (source["_reasonLinkId"]) { this._reasonLinkId = source._reasonLinkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["reasonReference"]) { this.reasonReference = source.reasonReference.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["requester"]) { this.requester = source.requester.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["requesterLinkId"]) { this.requesterLinkId = source.requesterLinkId.map((x) => (x)); }
    if (source["_requesterLinkId"]) { this._requesterLinkId = source._requesterLinkId.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["securityLabelNumber"]) { this.securityLabelNumber = source.securityLabelNumber.map((x) => (x)); }
    if (source["_securityLabelNumber"]) { this._securityLabelNumber = source._securityLabelNumber.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    this.status = null;
    if (source["status"]) { this.status = new fhir.CodeableConcept(source.status!); }
    if (this.status === undefined) { this.status = null }
    if (source["subject"]) { this.subject = source.subject.map((x:Partial<fhir.IContractTermActionSubject>) => new fhir.ContractTermActionSubject(x)); }
    this.type = null;
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
    if (this.type === undefined) { this.type = null }
  }
  /**
   * Check if the current ContractTermAction contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["intent"] === undefined) { missingElements.push("intent"); }
    if (this["status"] === undefined) { missingElements.push("status"); }
    if (this["type"] === undefined) { missingElements.push("type"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTermAction from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTermAction):ContractTermAction {
    var dest:ContractTermAction = new ContractTermAction(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTermAction is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
 */
export class ContractTerm extends fhir.BackboneElement implements fhir.IContractTerm {
  /**
   * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
   * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
   */
  public action?: fhir.ContractTermAction[]|undefined;
  /**
   * Relevant time or time-period when this Contract Provision is applicable.
   */
  public applies?: fhir.Period|undefined;
  /**
   * Contract Term Asset List.
   */
  public asset?: fhir.ContractTermAsset[]|undefined;
  /**
   * Nested group of Contract Provisions.
   */
  public group?: fhir.ContractTerm[]|undefined;
  /**
   * Unique identifier for this particular Contract Provision.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * When this Contract Provision was issued.
   */
  public issued?: string|undefined;
  public _issued?: fhir.FhirElement|undefined;
  /**
   * The matter of concern in the context of this provision of the agrement.
   */
  public offer: fhir.ContractTermOffer|null;
  /**
   * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
   */
  public securityLabel?: fhir.ContractTermSecurityLabel[]|undefined;
  /**
   * A specialized legal clause or condition based on overarching contract type.
   */
  public subType?: fhir.CodeableConcept|undefined;
  /**
   * Statement of a provision in a policy or a contract.
   */
  public text?: string|undefined;
  public _text?: fhir.FhirElement|undefined;
  /**
   * The entity that the term applies to.
   */
  public topicCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * The entity that the term applies to.
   */
  public topicReference?: fhir.Reference|undefined;
  /**
   * A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for ContractTerm - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractTerm> = {}) {
    super(source);
    if (source["action"]) { this.action = source.action.map((x:Partial<fhir.IContractTermAction>) => new fhir.ContractTermAction(x)); }
    if (source["applies"]) { this.applies = new fhir.Period(source.applies!); }
    if (source["asset"]) { this.asset = source.asset.map((x:Partial<fhir.IContractTermAsset>) => new fhir.ContractTermAsset(x)); }
    if (source["group"]) { this.group = source.group.map((x:Partial<fhir.IContractTerm>) => new fhir.ContractTerm(x)); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["issued"]) { this.issued = source.issued; }
    if (source["_issued"]) { this._issued = new fhir.FhirElement(source._issued!); }
    this.offer = null;
    if (source["offer"]) { this.offer = new fhir.ContractTermOffer(source.offer!); }
    if (this.offer === undefined) { this.offer = null }
    if (source["securityLabel"]) { this.securityLabel = source.securityLabel.map((x:Partial<fhir.IContractTermSecurityLabel>) => new fhir.ContractTermSecurityLabel(x)); }
    if (source["subType"]) { this.subType = new fhir.CodeableConcept(source.subType!); }
    if (source["text"]) { this.text = source.text; }
    if (source["_text"]) { this._text = new fhir.FhirElement(source._text!); }
    if (source["topicCodeableConcept"]) { this.topicCodeableConcept = new fhir.CodeableConcept(source.topicCodeableConcept!); }
    if (source["topicReference"]) { this.topicReference = new fhir.Reference(source.topicReference!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current ContractTerm contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["offer"] === undefined) { missingElements.push("offer"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractTerm from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractTerm):ContractTerm {
    var dest:ContractTerm = new ContractTerm(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractTerm is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
 * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
 */
export class ContractSigner extends fhir.BackboneElement implements fhir.IContractSigner {
  /**
   * Party which is a signator to this Contract.
   */
  public party: fhir.Reference|null;
  /**
   * Legally binding Contract DSIG signature contents in Base64.
   */
  public signature: fhir.Signature[]|null;
  /**
   * Role of this Contract signer, e.g. notary, grantee.
   */
  public type: fhir.Coding|null;
  /**
   * Default constructor for ContractSigner - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractSigner> = {}) {
    super(source);
    this.party = null;
    if (source["party"]) { this.party = new fhir.Reference(source.party!); }
    if (this.party === undefined) { this.party = null }
    this.signature = null;
    if (source["signature"]) { this.signature = source.signature.map((x:Partial<fhir.ISignature>) => new fhir.Signature(x)); }
    if (this.signature === undefined) { this.signature = null }
    this.type = null;
    if (source["type"]) { this.type = new fhir.Coding(source.type!); }
    if (this.type === undefined) { this.type = null }
  }
  /**
   * Check if the current ContractSigner contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["party"] === undefined) { missingElements.push("party"); }
    if ((!this["signature"]) || (this["signature"].length === 0)) { missingElements.push("signature"); }
    if (this["type"] === undefined) { missingElements.push("type"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractSigner from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractSigner):ContractSigner {
    var dest:ContractSigner = new ContractSigner(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractSigner is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
 */
export class ContractFriendly extends fhir.BackboneElement implements fhir.IContractFriendly {
  /**
   * Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
   */
  public contentAttachment?: fhir.Attachment|undefined;
  /**
   * Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
   */
  public contentReference?: fhir.Reference|undefined;
  /**
   * Default constructor for ContractFriendly - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractFriendly> = {}) {
    super(source);
    if (source["contentAttachment"]) { this.contentAttachment = new fhir.Attachment(source.contentAttachment!); }
    if (source["contentReference"]) { this.contentReference = new fhir.Reference(source.contentReference!); }
  }
  /**
   * Check if the current ContractFriendly contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractFriendly from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractFriendly):ContractFriendly {
    var dest:ContractFriendly = new ContractFriendly(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractFriendly is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * List of Legal expressions or representations of this Contract.
 */
export class ContractLegal extends fhir.BackboneElement implements fhir.IContractLegal {
  /**
   * Contract legal text in human renderable form.
   */
  public contentAttachment?: fhir.Attachment|undefined;
  /**
   * Contract legal text in human renderable form.
   */
  public contentReference?: fhir.Reference|undefined;
  /**
   * Default constructor for ContractLegal - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractLegal> = {}) {
    super(source);
    if (source["contentAttachment"]) { this.contentAttachment = new fhir.Attachment(source.contentAttachment!); }
    if (source["contentReference"]) { this.contentReference = new fhir.Reference(source.contentReference!); }
  }
  /**
   * Check if the current ContractLegal contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractLegal from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractLegal):ContractLegal {
    var dest:ContractLegal = new ContractLegal(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractLegal is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * List of Computable Policy Rule Language Representations of this Contract.
 */
export class ContractRule extends fhir.BackboneElement implements fhir.IContractRule {
  /**
   * Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
   */
  public contentAttachment?: fhir.Attachment|undefined;
  /**
   * Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
   */
  public contentReference?: fhir.Reference|undefined;
  /**
   * Default constructor for ContractRule - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContractRule> = {}) {
    super(source);
    if (source["contentAttachment"]) { this.contentAttachment = new fhir.Attachment(source.contentAttachment!); }
    if (source["contentReference"]) { this.contentReference = new fhir.Reference(source.contentReference!); }
  }
  /**
   * Check if the current ContractRule contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a ContractRule from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContractRule):ContractRule {
    var dest:ContractRule = new ContractRule(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `ContractRule is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
 */
export class Contract extends fhir.DomainResource implements fhir.IContract {
  /**
   * Resource Type Name
   */
  public override resourceType: "Contract";
  /**
   * Alternative representation of the title for this Contract definition, derivative, or instance in any legal state., e.g., a domain specific contract number related to legislation.
   */
  public alias?: string[]|undefined;
  public _alias?: fhir.FhirElement[]|undefined;
  /**
   * Relevant time or time-period when this Contract is applicable.
   */
  public applies?: fhir.Period|undefined;
  /**
   * The individual or organization that authored the Contract definition, derivative, or instance in any legal state.
   */
  public author?: fhir.Reference|undefined;
  /**
   * A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
   */
  public authority?: fhir.Reference[]|undefined;
  /**
   * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
   */
  public contentDefinition?: fhir.ContractContentDefinition|undefined;
  /**
   * The minimal content derived from the basal information source at a specific stage in its lifecycle.
   */
  public contentDerivative?: fhir.CodeableConcept|undefined;
  /**
   * Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
   */
  public domain?: fhir.Reference[]|undefined;
  /**
   * Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract.
   */
  public expirationType?: fhir.CodeableConcept|undefined;
  /**
   * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
   */
  public friendly?: fhir.ContractFriendly[]|undefined;
  /**
   * Unique identifier for this Contract or a derivative that references a Source Contract.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract.
   */
  public instantiatesCanonical?: fhir.Reference|undefined;
  /**
   * The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
   */
  public instantiatesUri?: string|undefined;
  public _instantiatesUri?: fhir.FhirElement|undefined;
  /**
   * When this  Contract was issued.
   */
  public issued?: string|undefined;
  public _issued?: fhir.FhirElement|undefined;
  /**
   * List of Legal expressions or representations of this Contract.
   */
  public legal?: fhir.ContractLegal[]|undefined;
  /**
   * Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
   */
  public legallyBindingAttachment?: fhir.Attachment|undefined;
  /**
   * Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
   */
  public legallyBindingReference?: fhir.Reference|undefined;
  /**
   * Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement.
   */
  public legalState?: fhir.CodeableConcept|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  public name?: string|undefined;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Links to Provenance records for past versions of this Contract definition, derivative, or instance, which identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the Contract.  The Provence.entity indicates the target that was changed in the update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
   */
  public relevantHistory?: fhir.Reference[]|undefined;
  /**
   * List of Computable Policy Rule Language Representations of this Contract.
   */
  public rule?: fhir.ContractRule[]|undefined;
  /**
   * A selector of legal concerns for this Contract definition, derivative, or instance in any legal state.
   */
  public scope?: fhir.CodeableConcept|undefined;
  /**
   * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
   * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
   */
  public signer?: fhir.ContractSigner[]|undefined;
  /**
   * Sites in which the contract is complied with,  exercised, or in force.
   */
  public site?: fhir.Reference[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the contract as not currently valid or active.
   */
  public status?: ContractStatusEnum|undefined;
  public _status?: fhir.FhirElement|undefined;
  /**
   * The Contract.subject is an entity that has some role with respect to the Contract.topic and Contract.topic.term, which is of focal interest to the parties to the contract and likely impacted in a significant way by the Contract.action/Contract.action.reason and the Contract.term.action/Contract.action.reason. 
   * In many cases, the Contract.subject is a Contract.signer if the subject is an adult; has a legal interest in the contract; and incompetent to participate in the contract agreement.
   */
  public subject?: fhir.Reference[]|undefined;
  /**
   * An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
   */
  public subtitle?: string|undefined;
  public _subtitle?: fhir.FhirElement|undefined;
  /**
   * Sub-category for the Contract that distinguishes the kinds of systems that would be interested in the Contract within the context of the Contract's scope.
   */
  public subType?: fhir.CodeableConcept[]|undefined;
  /**
   * Information that may be needed by/relevant to the performer in their execution of this term action.
   */
  public supportingInfo?: fhir.Reference[]|undefined;
  /**
   * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
   */
  public term?: fhir.ContractTerm[]|undefined;
  /**
   * A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
   */
  public title?: string|undefined;
  public _title?: fhir.FhirElement|undefined;
  /**
   * Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
   */
  public topicCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
   */
  public topicReference?: fhir.Reference|undefined;
  /**
   * A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Used in a domain that uses a supplied contract repository.
   */
  public url?: string|undefined;
  public _url?: fhir.FhirElement|undefined;
  /**
   * Note -  This is a business versionId, not a resource version id (see discussion http://build.fhir.org/resource.html#versions) 
   * Comments - There may be different contract instances that have the same identifier but different versions. The version can be appended to the url in a reference to allow a reference to a particular business version of the plan definition with the format [url]|[version].
   */
  public version?: string|undefined;
  public _version?: fhir.FhirElement|undefined;
  /**
   * Default constructor for Contract - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IContract> = {}) {
    super(source);
    this.resourceType = 'Contract';
    if (source["alias"]) { this.alias = source.alias.map((x) => (x)); }
    if (source["_alias"]) { this._alias = source._alias.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["applies"]) { this.applies = new fhir.Period(source.applies!); }
    if (source["author"]) { this.author = new fhir.Reference(source.author!); }
    if (source["authority"]) { this.authority = source.authority.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["contentDefinition"]) { this.contentDefinition = new fhir.ContractContentDefinition(source.contentDefinition!); }
    if (source["contentDerivative"]) { this.contentDerivative = new fhir.CodeableConcept(source.contentDerivative!); }
    if (source["domain"]) { this.domain = source.domain.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["expirationType"]) { this.expirationType = new fhir.CodeableConcept(source.expirationType!); }
    if (source["friendly"]) { this.friendly = source.friendly.map((x:Partial<fhir.IContractFriendly>) => new fhir.ContractFriendly(x)); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["instantiatesCanonical"]) { this.instantiatesCanonical = new fhir.Reference(source.instantiatesCanonical!); }
    if (source["instantiatesUri"]) { this.instantiatesUri = source.instantiatesUri; }
    if (source["_instantiatesUri"]) { this._instantiatesUri = new fhir.FhirElement(source._instantiatesUri!); }
    if (source["issued"]) { this.issued = source.issued; }
    if (source["_issued"]) { this._issued = new fhir.FhirElement(source._issued!); }
    if (source["legal"]) { this.legal = source.legal.map((x:Partial<fhir.IContractLegal>) => new fhir.ContractLegal(x)); }
    if (source["legallyBindingAttachment"]) { this.legallyBindingAttachment = new fhir.Attachment(source.legallyBindingAttachment!); }
    if (source["legallyBindingReference"]) { this.legallyBindingReference = new fhir.Reference(source.legallyBindingReference!); }
    if (source["legalState"]) { this.legalState = new fhir.CodeableConcept(source.legalState!); }
    if (source["name"]) { this.name = source.name; }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["relevantHistory"]) { this.relevantHistory = source.relevantHistory.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["rule"]) { this.rule = source.rule.map((x:Partial<fhir.IContractRule>) => new fhir.ContractRule(x)); }
    if (source["scope"]) { this.scope = new fhir.CodeableConcept(source.scope!); }
    if (source["signer"]) { this.signer = source.signer.map((x:Partial<fhir.IContractSigner>) => new fhir.ContractSigner(x)); }
    if (source["site"]) { this.site = source.site.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["status"]) { this.status = source.status; }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["subject"]) { this.subject = source.subject.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["subtitle"]) { this.subtitle = source.subtitle; }
    if (source["_subtitle"]) { this._subtitle = new fhir.FhirElement(source._subtitle!); }
    if (source["subType"]) { this.subType = source.subType.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["supportingInfo"]) { this.supportingInfo = source.supportingInfo.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["term"]) { this.term = source.term.map((x:Partial<fhir.IContractTerm>) => new fhir.ContractTerm(x)); }
    if (source["title"]) { this.title = source.title; }
    if (source["_title"]) { this._title = new fhir.FhirElement(source._title!); }
    if (source["topicCodeableConcept"]) { this.topicCodeableConcept = new fhir.CodeableConcept(source.topicCodeableConcept!); }
    if (source["topicReference"]) { this.topicReference = new fhir.Reference(source.topicReference!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
    if (source["url"]) { this.url = source.url; }
    if (source["_url"]) { this._url = new fhir.FhirElement(source._url!); }
    if (source["version"]) { this.version = source.version; }
    if (source["_version"]) { this._version = new fhir.FhirElement(source._version!); }
  }
  /**
   * Check if the current Contract contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Contract from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IContract):Contract {
    var dest:Contract = new Contract(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `Contract is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the Contract.contentDefinition.publicationStatus field
 */
export enum ContractContentDefinitionPublicationStatusEnum {
  AMENDED = "amended",
  APPENDED = "appended",
  CANCELLED = "cancelled",
  DISPUTED = "disputed",
  ENTERED_IN_ERROR = "entered-in-error",
  EXECUTABLE = "executable",
  EXECUTED = "executed",
  NEGOTIABLE = "negotiable",
  OFFERED = "offered",
  POLICY = "policy",
  REJECTED = "rejected",
  RENEWED = "renewed",
  REVOKED = "revoked",
  RESOLVED = "resolved",
  TERMINATED = "terminated",
}
/**
 * Code Values for the Contract.status field
 */
export enum ContractStatusEnum {
  AMENDED = "amended",
  APPENDED = "appended",
  CANCELLED = "cancelled",
  DISPUTED = "disputed",
  ENTERED_IN_ERROR = "entered-in-error",
  EXECUTABLE = "executable",
  EXECUTED = "executed",
  NEGOTIABLE = "negotiable",
  OFFERED = "offered",
  POLICY = "policy",
  REJECTED = "rejected",
  RENEWED = "renewed",
  REVOKED = "revoked",
  RESOLVED = "resolved",
  TERMINATED = "terminated",
}
