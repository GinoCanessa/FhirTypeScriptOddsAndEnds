// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * When multiple conditions of the same kind are present, the effects are combined using AND semantics, so the overall condition is true only if all of the conditions are true.
 */
export type IRequestGroupActionCondition = fhir.IBackboneElement & {
  /**
   * The expression may be inlined, or may be a reference to a named expression within a logic library referenced by the library element.
   */
  expression?: fhir.IExpression|undefined;
  /**
   * Applicability criteria are used to determine immediate applicability when a plan definition is applied to a given context. Start and stop criteria are carried through application and used to describe enter/exit criteria for an action.
   */
  kind: RequestGroupActionConditionKindEnum|null;
  _kind?: fhir.IFhirElement|undefined;
}
/**
 * A relationship to another action such as "before" or "30-60 minutes after start of".
 */
export type IRequestGroupActionRelatedAction = fhir.IBackboneElement & {
  /**
   * The element id of the action this is related to.
   */
  actionId: string|null;
  _actionId?: fhir.IFhirElement|undefined;
  /**
   * A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
   */
  offsetDuration?: fhir.IDuration|undefined;
  /**
   * A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
   */
  offsetRange?: fhir.IRange|undefined;
  /**
   * The relationship of this action to the related action.
   */
  relationship: RequestGroupActionRelatedActionRelationshipEnum|null;
  _relationship?: fhir.IFhirElement|undefined;
}
/**
 * The actions, if any, produced by the evaluation of the artifact.
 */
export type IRequestGroupAction = fhir.IBackboneElement & {
  /**
   * Sub actions.
   */
  action?: fhir.IRequestGroupAction[]|undefined;
  /**
   * Defines whether the action can be selected multiple times.
   */
  cardinalityBehavior?: RequestGroupActionCardinalityBehaviorEnum|undefined;
  _cardinalityBehavior?: fhir.IFhirElement|undefined;
  /**
   * A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a section of a documentation template.
   */
  code?: fhir.ICodeableConcept[]|undefined;
  /**
   * When multiple conditions of the same kind are present, the effects are combined using AND semantics, so the overall condition is true only if all of the conditions are true.
   */
  condition?: fhir.IRequestGroupActionCondition[]|undefined;
  /**
   * A short description of the action used to provide a summary to display to the user.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
   */
  documentation?: fhir.IRelatedArtifact[]|undefined;
  /**
   * Defines the grouping behavior for the action and its children.
   */
  groupingBehavior?: RequestGroupActionGroupingBehaviorEnum|undefined;
  _groupingBehavior?: fhir.IFhirElement|undefined;
  /**
   * The participant that should perform or be responsible for this action.
   */
  participant?: fhir.IReference[]|undefined;
  /**
   * Defines whether the action should usually be preselected.
   */
  precheckBehavior?: RequestGroupActionPrecheckBehaviorEnum|undefined;
  _precheckBehavior?: fhir.IFhirElement|undefined;
  /**
   * A user-visible prefix for the action.
   */
  prefix?: string|undefined;
  _prefix?: fhir.IFhirElement|undefined;
  /**
   * Indicates how quickly the action should be addressed with respect to other actions.
   */
  priority?: RequestGroupActionPriorityEnum|undefined;
  _priority?: fhir.IFhirElement|undefined;
  /**
   * A relationship to another action such as "before" or "30-60 minutes after start of".
   */
  relatedAction?: fhir.IRequestGroupActionRelatedAction[]|undefined;
  /**
   * Defines expectations around whether an action is required.
   */
  requiredBehavior?: RequestGroupActionRequiredBehaviorEnum|undefined;
  _requiredBehavior?: fhir.IFhirElement|undefined;
  /**
   * The target resource SHALL be a [Request](request.html) resource with a Request.intent set to "option".
   */
  resource?: fhir.IReference|undefined;
  /**
   * Defines the selection behavior for the action and its children.
   */
  selectionBehavior?: RequestGroupActionSelectionBehaviorEnum|undefined;
  _selectionBehavior?: fhir.IFhirElement|undefined;
  /**
   * A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
   */
  textEquivalent?: string|undefined;
  _textEquivalent?: fhir.IFhirElement|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  timingDateTime?: string|undefined;
  _timingDateTime?: fhir.IFhirElement|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  timingAge?: fhir.IAge|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  timingPeriod?: fhir.IPeriod|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  timingDuration?: fhir.IDuration|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  timingRange?: fhir.IRange|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  timingTiming?: fhir.ITiming|undefined;
  /**
   * The title of the action displayed to a user.
   */
  title?: string|undefined;
  _title?: fhir.IFhirElement|undefined;
  /**
   * The type of action to perform (create, update, remove).
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
 */
export type IRequestGroup = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "RequestGroup";
  /**
   * The actions, if any, produced by the evaluation of the artifact.
   */
  action?: fhir.IRequestGroupAction[]|undefined;
  /**
   * Provides a reference to the author of the request group.
   */
  author?: fhir.IReference|undefined;
  /**
   * Indicates when the request group was created.
   */
  authoredOn?: string|undefined;
  _authoredOn?: fhir.IFhirElement|undefined;
  /**
   * A plan, proposal or order that is fulfilled in whole or in part by this request.
   */
  basedOn?: fhir.IReference[]|undefined;
  /**
   * This element can be used to provide a code that captures the meaning of the request group as a whole, as opposed to the code of the action element, which captures the meaning of the individual actions within the request group.
   */
  code?: fhir.ICodeableConcept|undefined;
  /**
   * Describes the context of the request group, if any.
   */
  encounter?: fhir.IReference|undefined;
  /**
   * Requests are linked either by a "basedOn" relationship (i.e. one request is fulfilling another) or by having a common requisition.  Requests that are part of the same requisition are generally treated independently from the perspective of changing their state or maintaining them after initial creation.
   */
  groupIdentifier?: fhir.IIdentifier|undefined;
  /**
   * Allows a service to provide a unique, business identifier for the request.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * A canonical URL referencing a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
   */
  instantiatesCanonical?: string[]|undefined;
  _instantiatesCanonical?: fhir.IFhirElement[]|undefined;
  /**
   * A URL referencing an externally defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
   */
  instantiatesUri?: string[]|undefined;
  _instantiatesUri?: fhir.IFhirElement[]|undefined;
  /**
   * Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
   */
  intent: RequestGroupIntentEnum|null;
  _intent?: fhir.IFhirElement|undefined;
  /**
   * Provides a mechanism to communicate additional information about the response.
   */
  note?: fhir.IAnnotation[]|undefined;
  /**
   * Indicates how quickly the request should be addressed with respect to other requests.
   */
  priority?: RequestGroupPriorityEnum|undefined;
  _priority?: fhir.IFhirElement|undefined;
  /**
   * Describes the reason for the request group in coded or textual form.
   */
  reasonCode?: fhir.ICodeableConcept[]|undefined;
  /**
   * Indicates another resource whose existence justifies this request group.
   */
  reasonReference?: fhir.IReference[]|undefined;
  /**
   * The replacement could be because the initial request was immediately rejected (due to an issue) or because the previous request was completed, but the need for the action described by the request remains ongoing.
   */
  replaces?: fhir.IReference[]|undefined;
  /**
   * The current state of the request. For request groups, the status reflects the status of all the requests in the group.
   */
  status: RequestGroupStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
  /**
   * The subject for which the request group was created.
   */
  subject?: fhir.IReference|undefined;
}
/**
 * When multiple conditions of the same kind are present, the effects are combined using AND semantics, so the overall condition is true only if all of the conditions are true.
 */
export class RequestGroupActionCondition extends fhir.BackboneElement implements fhir.IRequestGroupActionCondition {
  /**
   * The expression may be inlined, or may be a reference to a named expression within a logic library referenced by the library element.
   */
  public expression?: fhir.Expression|undefined;
  /**
   * Applicability criteria are used to determine immediate applicability when a plan definition is applied to a given context. Start and stop criteria are carried through application and used to describe enter/exit criteria for an action.
   */
  public kind: RequestGroupActionConditionKindEnum|null;
  public _kind?: fhir.FhirElement|undefined;
  /**
   * Default constructor for RequestGroupActionCondition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IRequestGroupActionCondition> = {}) {
    super(source);
    if (source["expression"]) { this.expression = new fhir.Expression(source.expression!); }
    this.kind = null;
    if (source["kind"]) { this.kind = source.kind; }
    if (this.kind === undefined) { this.kind = null }
    if (source["_kind"]) { this._kind = new fhir.FhirElement(source._kind!); }
  }
  /**
   * Check if the current RequestGroupActionCondition contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["kind"] === undefined) { missingElements.push("kind"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a RequestGroupActionCondition from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IRequestGroupActionCondition):RequestGroupActionCondition {
    var dest:RequestGroupActionCondition = new RequestGroupActionCondition(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `RequestGroupActionCondition is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A relationship to another action such as "before" or "30-60 minutes after start of".
 */
export class RequestGroupActionRelatedAction extends fhir.BackboneElement implements fhir.IRequestGroupActionRelatedAction {
  /**
   * The element id of the action this is related to.
   */
  public actionId: string|null;
  public _actionId?: fhir.FhirElement|undefined;
  /**
   * A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
   */
  public offsetDuration?: fhir.Duration|undefined;
  /**
   * A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
   */
  public offsetRange?: fhir.Range|undefined;
  /**
   * The relationship of this action to the related action.
   */
  public relationship: RequestGroupActionRelatedActionRelationshipEnum|null;
  public _relationship?: fhir.FhirElement|undefined;
  /**
   * Default constructor for RequestGroupActionRelatedAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IRequestGroupActionRelatedAction> = {}) {
    super(source);
    this.actionId = null;
    if (source["actionId"]) { this.actionId = source.actionId; }
    if (this.actionId === undefined) { this.actionId = null }
    if (source["_actionId"]) { this._actionId = new fhir.FhirElement(source._actionId!); }
    if (source["offsetDuration"]) { this.offsetDuration = new fhir.Duration(source.offsetDuration!); }
    if (source["offsetRange"]) { this.offsetRange = new fhir.Range(source.offsetRange!); }
    this.relationship = null;
    if (source["relationship"]) { this.relationship = source.relationship; }
    if (this.relationship === undefined) { this.relationship = null }
    if (source["_relationship"]) { this._relationship = new fhir.FhirElement(source._relationship!); }
  }
  /**
   * Check if the current RequestGroupActionRelatedAction contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["actionId"] === undefined) { missingElements.push("actionId"); }
    if (this["relationship"] === undefined) { missingElements.push("relationship"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a RequestGroupActionRelatedAction from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IRequestGroupActionRelatedAction):RequestGroupActionRelatedAction {
    var dest:RequestGroupActionRelatedAction = new RequestGroupActionRelatedAction(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `RequestGroupActionRelatedAction is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The actions, if any, produced by the evaluation of the artifact.
 */
export class RequestGroupAction extends fhir.BackboneElement implements fhir.IRequestGroupAction {
  /**
   * Sub actions.
   */
  public action?: fhir.RequestGroupAction[]|undefined;
  /**
   * Defines whether the action can be selected multiple times.
   */
  public cardinalityBehavior?: RequestGroupActionCardinalityBehaviorEnum|undefined;
  public _cardinalityBehavior?: fhir.FhirElement|undefined;
  /**
   * A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a section of a documentation template.
   */
  public code?: fhir.CodeableConcept[]|undefined;
  /**
   * When multiple conditions of the same kind are present, the effects are combined using AND semantics, so the overall condition is true only if all of the conditions are true.
   */
  public condition?: fhir.RequestGroupActionCondition[]|undefined;
  /**
   * A short description of the action used to provide a summary to display to the user.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
   */
  public documentation?: fhir.RelatedArtifact[]|undefined;
  /**
   * Defines the grouping behavior for the action and its children.
   */
  public groupingBehavior?: RequestGroupActionGroupingBehaviorEnum|undefined;
  public _groupingBehavior?: fhir.FhirElement|undefined;
  /**
   * The participant that should perform or be responsible for this action.
   */
  public participant?: fhir.Reference[]|undefined;
  /**
   * Defines whether the action should usually be preselected.
   */
  public precheckBehavior?: RequestGroupActionPrecheckBehaviorEnum|undefined;
  public _precheckBehavior?: fhir.FhirElement|undefined;
  /**
   * A user-visible prefix for the action.
   */
  public prefix?: string|undefined;
  public _prefix?: fhir.FhirElement|undefined;
  /**
   * Indicates how quickly the action should be addressed with respect to other actions.
   */
  public priority?: RequestGroupActionPriorityEnum|undefined;
  public _priority?: fhir.FhirElement|undefined;
  /**
   * A relationship to another action such as "before" or "30-60 minutes after start of".
   */
  public relatedAction?: fhir.RequestGroupActionRelatedAction[]|undefined;
  /**
   * Defines expectations around whether an action is required.
   */
  public requiredBehavior?: RequestGroupActionRequiredBehaviorEnum|undefined;
  public _requiredBehavior?: fhir.FhirElement|undefined;
  /**
   * The target resource SHALL be a [Request](request.html) resource with a Request.intent set to "option".
   */
  public resource?: fhir.Reference|undefined;
  /**
   * Defines the selection behavior for the action and its children.
   */
  public selectionBehavior?: RequestGroupActionSelectionBehaviorEnum|undefined;
  public _selectionBehavior?: fhir.FhirElement|undefined;
  /**
   * A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
   */
  public textEquivalent?: string|undefined;
  public _textEquivalent?: fhir.FhirElement|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  public timingDateTime?: string|undefined;
  public _timingDateTime?: fhir.FhirElement|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  public timingAge?: fhir.Age|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  public timingPeriod?: fhir.Period|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  public timingDuration?: fhir.Duration|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  public timingRange?: fhir.Range|undefined;
  /**
   * An optional value describing when the action should be performed.
   */
  public timingTiming?: fhir.Timing|undefined;
  /**
   * The title of the action displayed to a user.
   */
  public title?: string|undefined;
  public _title?: fhir.FhirElement|undefined;
  /**
   * The type of action to perform (create, update, remove).
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for RequestGroupAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IRequestGroupAction> = {}) {
    super(source);
    if (source["action"]) { this.action = source.action.map((x:Partial<fhir.IRequestGroupAction>) => new fhir.RequestGroupAction(x)); }
    if (source["cardinalityBehavior"]) { this.cardinalityBehavior = source.cardinalityBehavior; }
    if (source["_cardinalityBehavior"]) { this._cardinalityBehavior = new fhir.FhirElement(source._cardinalityBehavior!); }
    if (source["code"]) { this.code = source.code.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["condition"]) { this.condition = source.condition.map((x:Partial<fhir.IRequestGroupActionCondition>) => new fhir.RequestGroupActionCondition(x)); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["documentation"]) { this.documentation = source.documentation.map((x:Partial<fhir.IRelatedArtifact>) => new fhir.RelatedArtifact(x)); }
    if (source["groupingBehavior"]) { this.groupingBehavior = source.groupingBehavior; }
    if (source["_groupingBehavior"]) { this._groupingBehavior = new fhir.FhirElement(source._groupingBehavior!); }
    if (source["participant"]) { this.participant = source.participant.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["precheckBehavior"]) { this.precheckBehavior = source.precheckBehavior; }
    if (source["_precheckBehavior"]) { this._precheckBehavior = new fhir.FhirElement(source._precheckBehavior!); }
    if (source["prefix"]) { this.prefix = source.prefix; }
    if (source["_prefix"]) { this._prefix = new fhir.FhirElement(source._prefix!); }
    if (source["priority"]) { this.priority = source.priority; }
    if (source["_priority"]) { this._priority = new fhir.FhirElement(source._priority!); }
    if (source["relatedAction"]) { this.relatedAction = source.relatedAction.map((x:Partial<fhir.IRequestGroupActionRelatedAction>) => new fhir.RequestGroupActionRelatedAction(x)); }
    if (source["requiredBehavior"]) { this.requiredBehavior = source.requiredBehavior; }
    if (source["_requiredBehavior"]) { this._requiredBehavior = new fhir.FhirElement(source._requiredBehavior!); }
    if (source["resource"]) { this.resource = new fhir.Reference(source.resource!); }
    if (source["selectionBehavior"]) { this.selectionBehavior = source.selectionBehavior; }
    if (source["_selectionBehavior"]) { this._selectionBehavior = new fhir.FhirElement(source._selectionBehavior!); }
    if (source["textEquivalent"]) { this.textEquivalent = source.textEquivalent; }
    if (source["_textEquivalent"]) { this._textEquivalent = new fhir.FhirElement(source._textEquivalent!); }
    if (source["timingDateTime"]) { this.timingDateTime = source.timingDateTime; }
    if (source["_timingDateTime"]) { this._timingDateTime = new fhir.FhirElement(source._timingDateTime!); }
    if (source["timingAge"]) { this.timingAge = new fhir.Age(source.timingAge!); }
    if (source["timingPeriod"]) { this.timingPeriod = new fhir.Period(source.timingPeriod!); }
    if (source["timingDuration"]) { this.timingDuration = new fhir.Duration(source.timingDuration!); }
    if (source["timingRange"]) { this.timingRange = new fhir.Range(source.timingRange!); }
    if (source["timingTiming"]) { this.timingTiming = new fhir.Timing(source.timingTiming!); }
    if (source["title"]) { this.title = source.title; }
    if (source["_title"]) { this._title = new fhir.FhirElement(source._title!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current RequestGroupAction contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a RequestGroupAction from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IRequestGroupAction):RequestGroupAction {
    var dest:RequestGroupAction = new RequestGroupAction(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `RequestGroupAction is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
 */
export class RequestGroup extends fhir.DomainResource implements fhir.IRequestGroup {
  /**
   * Resource Type Name
   */
  public override resourceType: "RequestGroup";
  /**
   * The actions, if any, produced by the evaluation of the artifact.
   */
  public action?: fhir.RequestGroupAction[]|undefined;
  /**
   * Provides a reference to the author of the request group.
   */
  public author?: fhir.Reference|undefined;
  /**
   * Indicates when the request group was created.
   */
  public authoredOn?: string|undefined;
  public _authoredOn?: fhir.FhirElement|undefined;
  /**
   * A plan, proposal or order that is fulfilled in whole or in part by this request.
   */
  public basedOn?: fhir.Reference[]|undefined;
  /**
   * This element can be used to provide a code that captures the meaning of the request group as a whole, as opposed to the code of the action element, which captures the meaning of the individual actions within the request group.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Describes the context of the request group, if any.
   */
  public encounter?: fhir.Reference|undefined;
  /**
   * Requests are linked either by a "basedOn" relationship (i.e. one request is fulfilling another) or by having a common requisition.  Requests that are part of the same requisition are generally treated independently from the perspective of changing their state or maintaining them after initial creation.
   */
  public groupIdentifier?: fhir.Identifier|undefined;
  /**
   * Allows a service to provide a unique, business identifier for the request.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * A canonical URL referencing a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
   */
  public instantiatesCanonical?: string[]|undefined;
  public _instantiatesCanonical?: fhir.FhirElement[]|undefined;
  /**
   * A URL referencing an externally defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
   */
  public instantiatesUri?: string[]|undefined;
  public _instantiatesUri?: fhir.FhirElement[]|undefined;
  /**
   * Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
   */
  public intent: RequestGroupIntentEnum|null;
  public _intent?: fhir.FhirElement|undefined;
  /**
   * Provides a mechanism to communicate additional information about the response.
   */
  public note?: fhir.Annotation[]|undefined;
  /**
   * Indicates how quickly the request should be addressed with respect to other requests.
   */
  public priority?: RequestGroupPriorityEnum|undefined;
  public _priority?: fhir.FhirElement|undefined;
  /**
   * Describes the reason for the request group in coded or textual form.
   */
  public reasonCode?: fhir.CodeableConcept[]|undefined;
  /**
   * Indicates another resource whose existence justifies this request group.
   */
  public reasonReference?: fhir.Reference[]|undefined;
  /**
   * The replacement could be because the initial request was immediately rejected (due to an issue) or because the previous request was completed, but the need for the action described by the request remains ongoing.
   */
  public replaces?: fhir.Reference[]|undefined;
  /**
   * The current state of the request. For request groups, the status reflects the status of all the requests in the group.
   */
  public status: RequestGroupStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * The subject for which the request group was created.
   */
  public subject?: fhir.Reference|undefined;
  /**
   * Default constructor for RequestGroup - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IRequestGroup> = {}) {
    super(source);
    this.resourceType = 'RequestGroup';
    if (source["action"]) { this.action = source.action.map((x:Partial<fhir.IRequestGroupAction>) => new fhir.RequestGroupAction(x)); }
    if (source["author"]) { this.author = new fhir.Reference(source.author!); }
    if (source["authoredOn"]) { this.authoredOn = source.authoredOn; }
    if (source["_authoredOn"]) { this._authoredOn = new fhir.FhirElement(source._authoredOn!); }
    if (source["basedOn"]) { this.basedOn = source.basedOn.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (source["encounter"]) { this.encounter = new fhir.Reference(source.encounter!); }
    if (source["groupIdentifier"]) { this.groupIdentifier = new fhir.Identifier(source.groupIdentifier!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["instantiatesCanonical"]) { this.instantiatesCanonical = source.instantiatesCanonical.map((x) => (x)); }
    if (source["_instantiatesCanonical"]) { this._instantiatesCanonical = source._instantiatesCanonical.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["instantiatesUri"]) { this.instantiatesUri = source.instantiatesUri.map((x) => (x)); }
    if (source["_instantiatesUri"]) { this._instantiatesUri = source._instantiatesUri.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    this.intent = null;
    if (source["intent"]) { this.intent = source.intent; }
    if (this.intent === undefined) { this.intent = null }
    if (source["_intent"]) { this._intent = new fhir.FhirElement(source._intent!); }
    if (source["note"]) { this.note = source.note.map((x:Partial<fhir.IAnnotation>) => new fhir.Annotation(x)); }
    if (source["priority"]) { this.priority = source.priority; }
    if (source["_priority"]) { this._priority = new fhir.FhirElement(source._priority!); }
    if (source["reasonCode"]) { this.reasonCode = source.reasonCode.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["reasonReference"]) { this.reasonReference = source.reasonReference.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["replaces"]) { this.replaces = source.replaces.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["subject"]) { this.subject = new fhir.Reference(source.subject!); }
  }
  /**
   * Check if the current RequestGroup contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["intent"] === undefined) { missingElements.push("intent"); }
    if (this["status"] === undefined) { missingElements.push("status"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a RequestGroup from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IRequestGroup):RequestGroup {
    var dest:RequestGroup = new RequestGroup(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `RequestGroup is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the RequestGroup.action.condition.kind field
 */
export enum RequestGroupActionConditionKindEnum {
  APPLICABILITY = "applicability",
  START = "start",
  STOP = "stop",
}
/**
 * Code Values for the RequestGroup.action.relatedAction.relationship field
 */
export enum RequestGroupActionRelatedActionRelationshipEnum {
  BEFORE_START = "before-start",
  BEFORE = "before",
  BEFORE_END = "before-end",
  CONCURRENT_WITH_START = "concurrent-with-start",
  CONCURRENT = "concurrent",
  CONCURRENT_WITH_END = "concurrent-with-end",
  AFTER_START = "after-start",
  AFTER = "after",
  AFTER_END = "after-end",
}
/**
 * Code Values for the RequestGroup.action.cardinalityBehavior field
 */
export enum RequestGroupActionCardinalityBehaviorEnum {
  SINGLE = "single",
  MULTIPLE = "multiple",
}
/**
 * Code Values for the RequestGroup.action.groupingBehavior field
 */
export enum RequestGroupActionGroupingBehaviorEnum {
  VISUAL_GROUP = "visual-group",
  LOGICAL_GROUP = "logical-group",
  SENTENCE_GROUP = "sentence-group",
}
/**
 * Code Values for the RequestGroup.action.precheckBehavior field
 */
export enum RequestGroupActionPrecheckBehaviorEnum {
  YES = "yes",
  NO = "no",
}
/**
 * Code Values for the RequestGroup.action.priority field
 */
export enum RequestGroupActionPriorityEnum {
  ROUTINE = "routine",
  URGENT = "urgent",
  ASAP = "asap",
  STAT = "stat",
}
/**
 * Code Values for the RequestGroup.action.requiredBehavior field
 */
export enum RequestGroupActionRequiredBehaviorEnum {
  MUST = "must",
  COULD = "could",
  MUST_UNLESS_DOCUMENTED = "must-unless-documented",
}
/**
 * Code Values for the RequestGroup.action.selectionBehavior field
 */
export enum RequestGroupActionSelectionBehaviorEnum {
  ANY = "any",
  ALL = "all",
  ALL_OR_NONE = "all-or-none",
  EXACTLY_ONE = "exactly-one",
  AT_MOST_ONE = "at-most-one",
  ONE_OR_MORE = "one-or-more",
}
/**
 * Code Values for the RequestGroup.intent field
 */
export enum RequestGroupIntentEnum {
  PROPOSAL = "proposal",
  PLAN = "plan",
  DIRECTIVE = "directive",
  ORDER = "order",
  ORIGINAL_ORDER = "original-order",
  REFLEX_ORDER = "reflex-order",
  FILLER_ORDER = "filler-order",
  INSTANCE_ORDER = "instance-order",
  OPTION = "option",
}
/**
 * Code Values for the RequestGroup.priority field
 */
export enum RequestGroupPriorityEnum {
  ROUTINE = "routine",
  URGENT = "urgent",
  ASAP = "asap",
  STAT = "stat",
}
/**
 * Code Values for the RequestGroup.status field
 */
export enum RequestGroupStatusEnum {
  DRAFT = "draft",
  ACTIVE = "active",
  ON_HOLD = "on-hold",
  REVOKED = "revoked",
  COMPLETED = "completed",
  ENTERED_IN_ERROR = "entered-in-error",
  UNKNOWN = "unknown",
}
