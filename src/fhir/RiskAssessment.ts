// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Multiple repetitions can be used to identify the same type of outcome in different timeframes as well as different types of outcomes.
 */
export type IRiskAssessmentPrediction = fhir.IBackboneElement & {
  /**
   * One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
   */
  outcome?: fhir.ICodeableConcept|undefined;
  /**
   * If range is used, it represents the lower and upper bounds of certainty; e.g. 40-60%  Decimal values are expressed as percentages as well (max = 100).
   */
  probabilityDecimal?: number|undefined;
  _probabilityDecimal?: fhir.IFhirElement|undefined;
  /**
   * If range is used, it represents the lower and upper bounds of certainty; e.g. 40-60%  Decimal values are expressed as percentages as well (max = 100).
   */
  probabilityRange?: fhir.IRange|undefined;
  /**
   * Indicates how likely the outcome is (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, or high).
   */
  qualitativeRisk?: fhir.ICodeableConcept|undefined;
  /**
   * Additional information explaining the basis for the prediction.
   */
  rationale?: string|undefined;
  _rationale?: fhir.IFhirElement|undefined;
  /**
   * Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
   */
  relativeRisk?: number|undefined;
  _relativeRisk?: fhir.IFhirElement|undefined;
  /**
   * If not specified, the risk applies "over the subject's lifespan".
   */
  whenPeriod?: fhir.IPeriod|undefined;
  /**
   * If not specified, the risk applies "over the subject's lifespan".
   */
  whenRange?: fhir.IRange|undefined;
}
/**
 * An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
 */
export type IRiskAssessment = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "RiskAssessment";
  /**
   * A reference to the request that is fulfilled by this risk assessment.
   */
  basedOn?: fhir.IReference|undefined;
  /**
   * Indicates the source data considered as part of the assessment (for example, FamilyHistory, Observations, Procedures, Conditions, etc.).
   */
  basis?: fhir.IReference[]|undefined;
  /**
   * The type of the risk assessment performed.
   */
  code?: fhir.ICodeableConcept|undefined;
  /**
   * For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
   */
  condition?: fhir.IReference|undefined;
  /**
   * The encounter where the assessment was performed.
   */
  encounter?: fhir.IReference|undefined;
  /**
   * Business identifier assigned to the risk assessment.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The algorithm, process or mechanism used to evaluate the risk.
   */
  method?: fhir.ICodeableConcept|undefined;
  /**
   * A description of the steps that might be taken to reduce the identified risk(s).
   */
  mitigation?: string|undefined;
  _mitigation?: fhir.IFhirElement|undefined;
  /**
   * Additional comments about the risk assessment.
   */
  note?: fhir.IAnnotation[]|undefined;
  /**
   * The date (and possibly time) the risk assessment was performed.
   */
  occurrenceDateTime?: string|undefined;
  _occurrenceDateTime?: fhir.IFhirElement|undefined;
  /**
   * The date (and possibly time) the risk assessment was performed.
   */
  occurrencePeriod?: fhir.IPeriod|undefined;
  /**
   * A reference to a resource that this risk assessment is part of, such as a Procedure.
   */
  parent?: fhir.IReference|undefined;
  /**
   * The provider or software application that performed the assessment.
   */
  performer?: fhir.IReference|undefined;
  /**
   * Multiple repetitions can be used to identify the same type of outcome in different timeframes as well as different types of outcomes.
   */
  prediction?: fhir.IRiskAssessmentPrediction[]|undefined;
  /**
   * The reason the risk assessment was performed.
   */
  reasonCode?: fhir.ICodeableConcept[]|undefined;
  /**
   * Resources supporting the reason the risk assessment was performed.
   */
  reasonReference?: fhir.IReference[]|undefined;
  /**
   * The status of the RiskAssessment, using the same statuses as an Observation.
   */
  status: RiskAssessmentStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
  /**
   * The patient or group the risk assessment applies to.
   */
  subject: fhir.IReference|null;
}
/**
 * Multiple repetitions can be used to identify the same type of outcome in different timeframes as well as different types of outcomes.
 */
export class RiskAssessmentPrediction extends fhir.BackboneElement implements fhir.IRiskAssessmentPrediction {
  /**
   * One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
   */
  public outcome?: fhir.CodeableConcept|undefined;
  /**
   * If range is used, it represents the lower and upper bounds of certainty; e.g. 40-60%  Decimal values are expressed as percentages as well (max = 100).
   */
  public probabilityDecimal?: number|undefined;
  public _probabilityDecimal?: fhir.FhirElement|undefined;
  /**
   * If range is used, it represents the lower and upper bounds of certainty; e.g. 40-60%  Decimal values are expressed as percentages as well (max = 100).
   */
  public probabilityRange?: fhir.Range|undefined;
  /**
   * Indicates how likely the outcome is (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, or high).
   */
  public qualitativeRisk?: fhir.CodeableConcept|undefined;
  /**
   * Additional information explaining the basis for the prediction.
   */
  public rationale?: string|undefined;
  public _rationale?: fhir.FhirElement|undefined;
  /**
   * Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
   */
  public relativeRisk?: number|undefined;
  public _relativeRisk?: fhir.FhirElement|undefined;
  /**
   * If not specified, the risk applies "over the subject's lifespan".
   */
  public whenPeriod?: fhir.Period|undefined;
  /**
   * If not specified, the risk applies "over the subject's lifespan".
   */
  public whenRange?: fhir.Range|undefined;
  /**
   * Default constructor for RiskAssessmentPrediction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IRiskAssessmentPrediction> = {}) {
    super(source);
    if (source["outcome"]) { this.outcome = new fhir.CodeableConcept(source.outcome!); }
    if (source["probabilityDecimal"]) { this.probabilityDecimal = source.probabilityDecimal; }
    if (source["_probabilityDecimal"]) { this._probabilityDecimal = new fhir.FhirElement(source._probabilityDecimal!); }
    if (source["probabilityRange"]) { this.probabilityRange = new fhir.Range(source.probabilityRange!); }
    if (source["qualitativeRisk"]) { this.qualitativeRisk = new fhir.CodeableConcept(source.qualitativeRisk!); }
    if (source["rationale"]) { this.rationale = source.rationale; }
    if (source["_rationale"]) { this._rationale = new fhir.FhirElement(source._rationale!); }
    if (source["relativeRisk"]) { this.relativeRisk = source.relativeRisk; }
    if (source["_relativeRisk"]) { this._relativeRisk = new fhir.FhirElement(source._relativeRisk!); }
    if (source["whenPeriod"]) { this.whenPeriod = new fhir.Period(source.whenPeriod!); }
    if (source["whenRange"]) { this.whenRange = new fhir.Range(source.whenRange!); }
  }
  /**
   * Check if the current RiskAssessmentPrediction contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a RiskAssessmentPrediction from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IRiskAssessmentPrediction):RiskAssessmentPrediction {
    var dest:RiskAssessmentPrediction = new RiskAssessmentPrediction(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `RiskAssessmentPrediction is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
 */
export class RiskAssessment extends fhir.DomainResource implements fhir.IRiskAssessment {
  /**
   * Resource Type Name
   */
  public override resourceType: "RiskAssessment";
  /**
   * A reference to the request that is fulfilled by this risk assessment.
   */
  public basedOn?: fhir.Reference|undefined;
  /**
   * Indicates the source data considered as part of the assessment (for example, FamilyHistory, Observations, Procedures, Conditions, etc.).
   */
  public basis?: fhir.Reference[]|undefined;
  /**
   * The type of the risk assessment performed.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
   */
  public condition?: fhir.Reference|undefined;
  /**
   * The encounter where the assessment was performed.
   */
  public encounter?: fhir.Reference|undefined;
  /**
   * Business identifier assigned to the risk assessment.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The algorithm, process or mechanism used to evaluate the risk.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * A description of the steps that might be taken to reduce the identified risk(s).
   */
  public mitigation?: string|undefined;
  public _mitigation?: fhir.FhirElement|undefined;
  /**
   * Additional comments about the risk assessment.
   */
  public note?: fhir.Annotation[]|undefined;
  /**
   * The date (and possibly time) the risk assessment was performed.
   */
  public occurrenceDateTime?: string|undefined;
  public _occurrenceDateTime?: fhir.FhirElement|undefined;
  /**
   * The date (and possibly time) the risk assessment was performed.
   */
  public occurrencePeriod?: fhir.Period|undefined;
  /**
   * A reference to a resource that this risk assessment is part of, such as a Procedure.
   */
  public parent?: fhir.Reference|undefined;
  /**
   * The provider or software application that performed the assessment.
   */
  public performer?: fhir.Reference|undefined;
  /**
   * Multiple repetitions can be used to identify the same type of outcome in different timeframes as well as different types of outcomes.
   */
  public prediction?: fhir.RiskAssessmentPrediction[]|undefined;
  /**
   * The reason the risk assessment was performed.
   */
  public reasonCode?: fhir.CodeableConcept[]|undefined;
  /**
   * Resources supporting the reason the risk assessment was performed.
   */
  public reasonReference?: fhir.Reference[]|undefined;
  /**
   * The status of the RiskAssessment, using the same statuses as an Observation.
   */
  public status: RiskAssessmentStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * The patient or group the risk assessment applies to.
   */
  public subject: fhir.Reference|null;
  /**
   * Default constructor for RiskAssessment - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IRiskAssessment> = {}) {
    super(source);
    this.resourceType = 'RiskAssessment';
    if (source["basedOn"]) { this.basedOn = new fhir.Reference(source.basedOn!); }
    if (source["basis"]) { this.basis = source.basis.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (source["condition"]) { this.condition = new fhir.Reference(source.condition!); }
    if (source["encounter"]) { this.encounter = new fhir.Reference(source.encounter!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["method"]) { this.method = new fhir.CodeableConcept(source.method!); }
    if (source["mitigation"]) { this.mitigation = source.mitigation; }
    if (source["_mitigation"]) { this._mitigation = new fhir.FhirElement(source._mitigation!); }
    if (source["note"]) { this.note = source.note.map((x:Partial<fhir.IAnnotation>) => new fhir.Annotation(x)); }
    if (source["occurrenceDateTime"]) { this.occurrenceDateTime = source.occurrenceDateTime; }
    if (source["_occurrenceDateTime"]) { this._occurrenceDateTime = new fhir.FhirElement(source._occurrenceDateTime!); }
    if (source["occurrencePeriod"]) { this.occurrencePeriod = new fhir.Period(source.occurrencePeriod!); }
    if (source["parent"]) { this.parent = new fhir.Reference(source.parent!); }
    if (source["performer"]) { this.performer = new fhir.Reference(source.performer!); }
    if (source["prediction"]) { this.prediction = source.prediction.map((x:Partial<fhir.IRiskAssessmentPrediction>) => new fhir.RiskAssessmentPrediction(x)); }
    if (source["reasonCode"]) { this.reasonCode = source.reasonCode.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["reasonReference"]) { this.reasonReference = source.reasonReference.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    this.subject = null;
    if (source["subject"]) { this.subject = new fhir.Reference(source.subject!); }
    if (this.subject === undefined) { this.subject = null }
  }
  /**
   * Check if the current RiskAssessment contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["status"] === undefined) { missingElements.push("status"); }
    if (this["subject"] === undefined) { missingElements.push("subject"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a RiskAssessment from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IRiskAssessment):RiskAssessment {
    var dest:RiskAssessment = new RiskAssessment(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `RiskAssessment is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the RiskAssessment.status field
 */
export enum RiskAssessmentStatusEnum {
  REGISTERED = "registered",
  PRELIMINARY = "preliminary",
  FINAL = "final",
  AMENDED = "amended",
  CORRECTED = "corrected",
  CANCELLED = "cancelled",
  ENTERED_IN_ERROR = "entered-in-error",
  UNKNOWN = "unknown",
}
