// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: TestReport

import * as fhir from '../fhir.js';

import { ReportParticipantTypeValueSet, ReportParticipantTypeValueSetType,} from '../fhirValueSets/ReportParticipantTypeValueSet.js';
import { ReportParticipantTypeValueSetEnum } from '../valueSetEnums.js';
import { ReportActionResultCodesValueSet, ReportActionResultCodesValueSetType,} from '../fhirValueSets/ReportActionResultCodesValueSet.js';
import { ReportActionResultCodesValueSetEnum } from '../valueSetEnums.js';
import { ReportStatusCodesValueSet, ReportStatusCodesValueSetType,} from '../fhirValueSets/ReportStatusCodesValueSet.js';
import { ReportStatusCodesValueSetEnum } from '../valueSetEnums.js';
import { ReportResultCodesValueSet, ReportResultCodesValueSetType,} from '../fhirValueSets/ReportResultCodesValueSet.js';
import { ReportResultCodesValueSetEnum } from '../valueSetEnums.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Valid arguments for the TestReportParticipant type.
 */
export interface TestReportParticipantArgs extends fhir.BackboneElementArgs {
  /**
   * The type of participant.
   */
  type: ReportParticipantTypeValueSetEnum|null;
  /**
   * The uri of the participant. An absolute URL is preferred.
   */
  uri: fhir.FhirUri|string|undefined;
  /**
   * The display name of the participant.
   */
  display?: fhir.FhirString|string|undefined;
}

/**
 * A participant in the test execution, either the execution engine, a client, or a server.
 */
export class TestReportParticipant extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportParticipant';
  /**
   * The type of participant.
   */
  public type: ReportParticipantTypeValueSetEnum|null;
  /**
   * The uri of the participant. An absolute URL is preferred.
   */
  public uri: fhir.FhirUri|null;
  /**
   * The display name of the participant.
   */
  public display?: fhir.FhirString|undefined;
  /**
   * Default constructor for TestReportParticipant - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportParticipantArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = source.type; }
    else { this.type = null; }
    if (source['uri']) { this.uri = new fhir.FhirUri({value: source.uri}); }
    else { this.uri = null; }
    if (source['display']) { this.display = new fhir.FhirString({value: source.display}); }
  }
  /**
   * Required-bound Value Set for type
   */
  public static typeRequiredValueSet():ReportParticipantTypeValueSetType {
    return ReportParticipantTypeValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['type']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property type:ReportParticipantTypeValueSetEnum fhir: TestReport.participant.type:code", }));
    }
    if (!this['uri']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property uri:fhir.FhirUri fhir: TestReport.participant.uri:uri", }));
    }
    if (this["uri"]) { outcome.issue!.push(...this.uri.doModelValidation().issue!); }
    if (this["display"]) { outcome.issue!.push(...this.display.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportSetupActionOperation type.
 */
export interface TestReportSetupActionOperationArgs extends fhir.BackboneElementArgs {
  /**
   * The result of this operation.
   */
  result: ReportActionResultCodesValueSetEnum|null;
  /**
   * An explanatory message associated with the result.
   */
  message?: fhir.FhirMarkdown|string|undefined;
  /**
   * A link to further details on the result.
   */
  detail?: fhir.FhirUri|string|undefined;
}

/**
 * The operation performed.
 */
export class TestReportSetupActionOperation extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportSetupActionOperation';
  /**
   * The result of this operation.
   */
  public result: ReportActionResultCodesValueSetEnum|null;
  /**
   * An explanatory message associated with the result.
   */
  public message?: fhir.FhirMarkdown|undefined;
  /**
   * A link to further details on the result.
   */
  public detail?: fhir.FhirUri|undefined;
  /**
   * Default constructor for TestReportSetupActionOperation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportSetupActionOperationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['result']) { this.result = source.result; }
    else { this.result = null; }
    if (source['message']) { this.message = new fhir.FhirMarkdown({value: source.message}); }
    if (source['detail']) { this.detail = new fhir.FhirUri({value: source.detail}); }
  }
  /**
   * Required-bound Value Set for result
   */
  public static resultRequiredValueSet():ReportActionResultCodesValueSetType {
    return ReportActionResultCodesValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['result']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property result:ReportActionResultCodesValueSetEnum fhir: TestReport.setup.action.operation.result:code", }));
    }
    if (this["message"]) { outcome.issue!.push(...this.message.doModelValidation().issue!); }
    if (this["detail"]) { outcome.issue!.push(...this.detail.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportSetupActionAssert type.
 */
export interface TestReportSetupActionAssertArgs extends fhir.BackboneElementArgs {
  /**
   * The result of this assertion.
   */
  result: ReportActionResultCodesValueSetEnum|null;
  /**
   * An explanatory message associated with the result.
   */
  message?: fhir.FhirMarkdown|string|undefined;
  /**
   * A link to further details on the result.
   */
  detail?: fhir.FhirString|string|undefined;
}

/**
 * The results of the assertion performed on the previous operations.
 */
export class TestReportSetupActionAssert extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportSetupActionAssert';
  /**
   * The result of this assertion.
   */
  public result: ReportActionResultCodesValueSetEnum|null;
  /**
   * An explanatory message associated with the result.
   */
  public message?: fhir.FhirMarkdown|undefined;
  /**
   * A link to further details on the result.
   */
  public detail?: fhir.FhirString|undefined;
  /**
   * Default constructor for TestReportSetupActionAssert - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportSetupActionAssertArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['result']) { this.result = source.result; }
    else { this.result = null; }
    if (source['message']) { this.message = new fhir.FhirMarkdown({value: source.message}); }
    if (source['detail']) { this.detail = new fhir.FhirString({value: source.detail}); }
  }
  /**
   * Required-bound Value Set for result
   */
  public static resultRequiredValueSet():ReportActionResultCodesValueSetType {
    return ReportActionResultCodesValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['result']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property result:ReportActionResultCodesValueSetEnum fhir: TestReport.setup.action.assert.result:code", }));
    }
    if (this["message"]) { outcome.issue!.push(...this.message.doModelValidation().issue!); }
    if (this["detail"]) { outcome.issue!.push(...this.detail.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportSetupAction type.
 */
export interface TestReportSetupActionArgs extends fhir.BackboneElementArgs {
  /**
   * The operation performed.
   */
  operation?: fhir.TestReportSetupActionOperationArgs|undefined;
  /**
   * The results of the assertion performed on the previous operations.
   */
  assert?: fhir.TestReportSetupActionAssertArgs|undefined;
}

/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestReportSetupAction extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportSetupAction';
  /**
   * The operation performed.
   */
  public operation?: fhir.TestReportSetupActionOperation|undefined;
  /**
   * The results of the assertion performed on the previous operations.
   */
  public assert?: fhir.TestReportSetupActionAssert|undefined;
  /**
   * Default constructor for TestReportSetupAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportSetupActionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['operation']) { this.operation = new fhir.TestReportSetupActionOperation(source.operation); }
    if (source['assert']) { this.assert = new fhir.TestReportSetupActionAssert(source.assert); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (this["operation"]) { outcome.issue!.push(...this.operation.doModelValidation().issue!); }
    if (this["assert"]) { outcome.issue!.push(...this.assert.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportSetup type.
 */
export interface TestReportSetupArgs extends fhir.BackboneElementArgs {
  /**
   * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
   */
  action: fhir.TestReportSetupActionArgs[]|null;
}

/**
 * The results of the series of required setup operations before the tests were executed.
 */
export class TestReportSetup extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportSetup';
  /**
   * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
   */
  public action: fhir.TestReportSetupAction[]|null = [];
  /**
   * Default constructor for TestReportSetup - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportSetupArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['action']) { this.action = source.action.map((x) => new fhir.TestReportSetupAction(x)); }
    else { this.action = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['action']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property action:fhir.TestReportSetupAction[] fhir: TestReport.setup.action:action", }));
    } else if (!Array.isArray(this.action)) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue,  diagnostics: "Found scalar in array property action:fhir.TestReportSetupAction[] fhir: TestReport.setup.action:action", }));
    } else if (this.action.length === 0) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property action:fhir.TestReportSetupAction[] fhir: TestReport.setup.action:action", }));
    }
    if (this["action"]) { this.action.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportTestAction type.
 */
export interface TestReportTestActionArgs extends fhir.BackboneElementArgs {
  /**
   * An operation would involve a REST request to a server.
   */
  operation?: fhir.TestReportSetupActionOperationArgs|undefined;
  /**
   * The results of the assertion performed on the previous operations.
   */
  assert?: fhir.TestReportSetupActionAssertArgs|undefined;
}

/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestReportTestAction extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportTestAction';
  /**
   * An operation would involve a REST request to a server.
   */
  public operation?: fhir.TestReportSetupActionOperation|undefined;
  /**
   * The results of the assertion performed on the previous operations.
   */
  public assert?: fhir.TestReportSetupActionAssert|undefined;
  /**
   * Default constructor for TestReportTestAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportTestActionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['operation']) { this.operation = new fhir.TestReportSetupActionOperation(source.operation); }
    if (source['assert']) { this.assert = new fhir.TestReportSetupActionAssert(source.assert); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (this["operation"]) { outcome.issue!.push(...this.operation.doModelValidation().issue!); }
    if (this["assert"]) { outcome.issue!.push(...this.assert.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportTest type.
 */
export interface TestReportTestArgs extends fhir.BackboneElementArgs {
  /**
   * The name of this test used for tracking/logging purposes by test engines.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * A short description of the test used by test engines for tracking and reporting purposes.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
   */
  action: fhir.TestReportTestActionArgs[]|null;
}

/**
 * A test executed from the test script.
 */
export class TestReportTest extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportTest';
  /**
   * The name of this test used for tracking/logging purposes by test engines.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * A short description of the test used by test engines for tracking and reporting purposes.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
   */
  public action: fhir.TestReportTestAction[]|null = [];
  /**
   * Default constructor for TestReportTest - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportTestArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['action']) { this.action = source.action.map((x) => new fhir.TestReportTestAction(x)); }
    else { this.action = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (this["name"]) { outcome.issue!.push(...this.name.doModelValidation().issue!); }
    if (this["description"]) { outcome.issue!.push(...this.description.doModelValidation().issue!); }
    if (!this['action']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property action:fhir.TestReportTestAction[] fhir: TestReport.test.action:action", }));
    } else if (!Array.isArray(this.action)) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue,  diagnostics: "Found scalar in array property action:fhir.TestReportTestAction[] fhir: TestReport.test.action:action", }));
    } else if (this.action.length === 0) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property action:fhir.TestReportTestAction[] fhir: TestReport.test.action:action", }));
    }
    if (this["action"]) { this.action.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportTeardownAction type.
 */
export interface TestReportTeardownActionArgs extends fhir.BackboneElementArgs {
  /**
   * An operation would involve a REST request to a server.
   */
  operation: fhir.TestReportSetupActionOperationArgs|null;
}

/**
 * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
 */
export class TestReportTeardownAction extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportTeardownAction';
  /**
   * An operation would involve a REST request to a server.
   */
  public operation: fhir.TestReportSetupActionOperation|null;
  /**
   * Default constructor for TestReportTeardownAction - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportTeardownActionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['operation']) { this.operation = new fhir.TestReportSetupActionOperation(source.operation); }
    else { this.operation = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['operation']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property operation:fhir.TestReportSetupActionOperation fhir: TestReport.teardown.action.operation:TestReport.setup.action.operation", }));
    }
    if (this["operation"]) { outcome.issue!.push(...this.operation.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReportTeardown type.
 */
export interface TestReportTeardownArgs extends fhir.BackboneElementArgs {
  /**
   * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
   */
  action: fhir.TestReportTeardownActionArgs[]|null;
}

/**
 * The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
 */
export class TestReportTeardown extends fhir.BackboneElement {
  readonly __dataType:string = 'TestReportTeardown';
  /**
   * An action should contain either an operation or an assertion but not both.  It can contain any number of variables.
   */
  public action: fhir.TestReportTeardownAction[]|null = [];
  /**
   * Default constructor for TestReportTeardown - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportTeardownArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['action']) { this.action = source.action.map((x) => new fhir.TestReportTeardownAction(x)); }
    else { this.action = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['action']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property action:fhir.TestReportTeardownAction[] fhir: TestReport.teardown.action:action", }));
    } else if (!Array.isArray(this.action)) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue,  diagnostics: "Found scalar in array property action:fhir.TestReportTeardownAction[] fhir: TestReport.teardown.action:action", }));
    } else if (this.action.length === 0) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property action:fhir.TestReportTeardownAction[] fhir: TestReport.teardown.action:action", }));
    }
    if (this["action"]) { this.action.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the TestReport type.
 */
export interface TestReportArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "TestReport"|undefined;
  /**
   * Identifier for the TestScript assigned for external purposes outside the context of FHIR.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * Not expected to be globally unique.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * The status represents where the execution is currently within the test script execution life cycle.
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  status: ReportStatusCodesValueSetEnum|null;
  /**
   * Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
   */
  testScript: fhir.ReferenceArgs|null;
  /**
   * The pass and fail result represents a completed test script execution. The pending result represents a test script execution that has not yet started or is currently in progress.
   */
  result: ReportResultCodesValueSetEnum|null;
  /**
   * The final score (percentage of tests passed) resulting from the execution of the TestScript.
   */
  score?: fhir.FhirDecimal|number|undefined;
  /**
   * Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
   */
  tester?: fhir.FhirString|string|undefined;
  /**
   * Additional specific dates may be added as extensions.
   */
  issued?: fhir.FhirDateTime|string|undefined;
  /**
   * A participant in the test execution, either the execution engine, a client, or a server.
   */
  participant?: fhir.TestReportParticipantArgs[]|undefined;
  /**
   * The results of the series of required setup operations before the tests were executed.
   */
  setup?: fhir.TestReportSetupArgs|undefined;
  /**
   * A test executed from the test script.
   */
  test?: fhir.TestReportTestArgs[]|undefined;
  /**
   * The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
   */
  teardown?: fhir.TestReportTeardownArgs|undefined;
}

/**
 * A summary of information based on the results of executing a TestScript.
 */
export class TestReport extends fhir.DomainResource {
  readonly __dataType:string = 'TestReport';
  /**
   * Resource Type Name
   */
  public resourceType: "TestReport";
  /**
   * Identifier for the TestScript assigned for external purposes outside the context of FHIR.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Not expected to be globally unique.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * The status represents where the execution is currently within the test script execution life cycle.
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  public status: ReportStatusCodesValueSetEnum|null;
  /**
   * Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
   */
  public testScript: fhir.Reference|null;
  /**
   * The pass and fail result represents a completed test script execution. The pending result represents a test script execution that has not yet started or is currently in progress.
   */
  public result: ReportResultCodesValueSetEnum|null;
  /**
   * The final score (percentage of tests passed) resulting from the execution of the TestScript.
   */
  public score?: fhir.FhirDecimal|undefined;
  /**
   * Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
   */
  public tester?: fhir.FhirString|undefined;
  /**
   * Additional specific dates may be added as extensions.
   */
  public issued?: fhir.FhirDateTime|undefined;
  /**
   * A participant in the test execution, either the execution engine, a client, or a server.
   */
  public participant?: fhir.TestReportParticipant[]|undefined = [];
  /**
   * The results of the series of required setup operations before the tests were executed.
   */
  public setup?: fhir.TestReportSetup|undefined;
  /**
   * A test executed from the test script.
   */
  public test?: fhir.TestReportTest[]|undefined = [];
  /**
   * The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
   */
  public teardown?: fhir.TestReportTeardown|undefined;
  /**
   * Default constructor for TestReport - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<TestReportArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'TestReport';
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['status']) { this.status = source.status; }
    else { this.status = null; }
    if (source['testScript']) { this.testScript = new fhir.Reference(source.testScript); }
    else { this.testScript = null; }
    if (source['result']) { this.result = source.result; }
    else { this.result = null; }
    if (source['score']) { this.score = new fhir.FhirDecimal({value: source.score}); }
    if (source['tester']) { this.tester = new fhir.FhirString({value: source.tester}); }
    if (source['issued']) { this.issued = new fhir.FhirDateTime({value: source.issued}); }
    if (source['participant']) { this.participant = source.participant.map((x) => new fhir.TestReportParticipant(x)); }
    if (source['setup']) { this.setup = new fhir.TestReportSetup(source.setup); }
    if (source['test']) { this.test = source.test.map((x) => new fhir.TestReportTest(x)); }
    if (source['teardown']) { this.teardown = new fhir.TestReportTeardown(source.teardown); }
  }
  /**
   * Required-bound Value Set for status
   */
  public static statusRequiredValueSet():ReportStatusCodesValueSetType {
    return ReportStatusCodesValueSet;
  }
  /**
   * Required-bound Value Set for result
   */
  public static resultRequiredValueSet():ReportResultCodesValueSetType {
    return ReportResultCodesValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['resourceType']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property resourceType:'TestReport' fhir: TestReport.resourceType:'TestReport'", }));
    }
    if (this["identifier"]) { outcome.issue!.push(...this.identifier.doModelValidation().issue!); }
    if (this["name"]) { outcome.issue!.push(...this.name.doModelValidation().issue!); }
    if (!this['status']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property status:ReportStatusCodesValueSetEnum fhir: TestReport.status:code", }));
    }
    if (!this['testScript']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property testScript:fhir.Reference fhir: TestReport.testScript:Reference", }));
    }
    if (this["testScript"]) { outcome.issue!.push(...this.testScript.doModelValidation().issue!); }
    if (!this['result']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property result:ReportResultCodesValueSetEnum fhir: TestReport.result:code", }));
    }
    if (this["score"]) { outcome.issue!.push(...this.score.doModelValidation().issue!); }
    if (this["tester"]) { outcome.issue!.push(...this.tester.doModelValidation().issue!); }
    if (this["issued"]) { outcome.issue!.push(...this.issued.doModelValidation().issue!); }
    if (this["participant"]) { this.participant.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["setup"]) { outcome.issue!.push(...this.setup.doModelValidation().issue!); }
    if (this["test"]) { this.test.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["teardown"]) { outcome.issue!.push(...this.teardown.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
