// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
 */
export type IDetectedIssueEvidence = fhir.IBackboneElement & {
  /**
   * A manifestation that led to the recording of this detected issue.
   */
  code?: fhir.ICodeableConcept[]|undefined;
  /**
   * Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport.
   */
  detail?: fhir.IReference[]|undefined;
}
/**
 * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
 */
export type IDetectedIssueMitigation = fhir.IBackboneElement & {
  /**
   * The "text" component can be used for detail or when no appropriate code exists.
   */
  action: fhir.ICodeableConcept|null;
  /**
   * Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
   */
  author?: fhir.IReference|undefined;
  /**
   * This might not be the same as when the mitigating step was actually taken.
   */
  date?: string|undefined;
  _date?: fhir.IFhirElement|undefined;
}
/**
 * Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
 */
export type IDetectedIssue = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "DetectedIssue";
  /**
   * Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review.
   */
  author?: fhir.IReference|undefined;
  /**
   * Identifies the general type of issue identified.
   */
  code?: fhir.ICodeableConcept|undefined;
  /**
   * Should focus on information not covered elsewhere as discrete data - no need to duplicate the narrative.
   */
  detail?: string|undefined;
  _detail?: fhir.IFhirElement|undefined;
  /**
   * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
   */
  evidence?: fhir.IDetectedIssueEvidence[]|undefined;
  /**
   * The date or period when the detected issue was initially identified.
   */
  identifiedDateTime?: string|undefined;
  _identifiedDateTime?: fhir.IFhirElement|undefined;
  /**
   * The date or period when the detected issue was initially identified.
   */
  identifiedPeriod?: fhir.IPeriod|undefined;
  /**
   * Business identifier associated with the detected issue record.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * There's an implicit constraint on the number of implicated resources based on DetectedIssue.type; e.g. For drug-drug, there would be more than one.  For timing, there would typically only be one.
   */
  implicated?: fhir.IReference[]|undefined;
  /**
   * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
   */
  mitigation?: fhir.IDetectedIssueMitigation[]|undefined;
  /**
   * Indicates the patient whose record the detected issue is associated with.
   */
  patient?: fhir.IReference|undefined;
  /**
   * The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
   */
  reference?: string|undefined;
  _reference?: fhir.IFhirElement|undefined;
  /**
   * Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
   */
  severity?: DetectedIssueSeverityEnum|undefined;
  _severity?: fhir.IFhirElement|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes cancelled and entered-in-error that mark the issue as not currently valid.
   */
  status: DetectedIssueStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
}
/**
 * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
 */
export class DetectedIssueEvidence extends fhir.BackboneElement implements fhir.IDetectedIssueEvidence {
  /**
   * A manifestation that led to the recording of this detected issue.
   */
  public code?: fhir.CodeableConcept[]|undefined;
  /**
   * Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport.
   */
  public detail?: fhir.Reference[]|undefined;
  /**
   * Default constructor for DetectedIssueEvidence - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IDetectedIssueEvidence> = {}) {
    super(source);
    if (source["code"]) { this.code = source.code.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["detail"]) { this.detail = source.detail.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
  }
  /**
   * Check if the current DetectedIssueEvidence contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a DetectedIssueEvidence from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IDetectedIssueEvidence):DetectedIssueEvidence {
    var dest:DetectedIssueEvidence = new DetectedIssueEvidence(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `DetectedIssueEvidence is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
 */
export class DetectedIssueMitigation extends fhir.BackboneElement implements fhir.IDetectedIssueMitigation {
  /**
   * The "text" component can be used for detail or when no appropriate code exists.
   */
  public action: fhir.CodeableConcept|null;
  /**
   * Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
   */
  public author?: fhir.Reference|undefined;
  /**
   * This might not be the same as when the mitigating step was actually taken.
   */
  public date?: string|undefined;
  public _date?: fhir.FhirElement|undefined;
  /**
   * Default constructor for DetectedIssueMitigation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IDetectedIssueMitigation> = {}) {
    super(source);
    this.action = null;
    if (source["action"]) { this.action = new fhir.CodeableConcept(source.action!); }
    if (this.action === undefined) { this.action = null }
    if (source["author"]) { this.author = new fhir.Reference(source.author!); }
    if (source["date"]) { this.date = source.date; }
    if (source["_date"]) { this._date = new fhir.FhirElement(source._date!); }
  }
  /**
   * Check if the current DetectedIssueMitigation contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["action"] === undefined) { missingElements.push("action"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a DetectedIssueMitigation from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IDetectedIssueMitigation):DetectedIssueMitigation {
    var dest:DetectedIssueMitigation = new DetectedIssueMitigation(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `DetectedIssueMitigation is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
 */
export class DetectedIssue extends fhir.DomainResource implements fhir.IDetectedIssue {
  /**
   * Resource Type Name
   */
  public override resourceType: "DetectedIssue";
  /**
   * Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review.
   */
  public author?: fhir.Reference|undefined;
  /**
   * Identifies the general type of issue identified.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Should focus on information not covered elsewhere as discrete data - no need to duplicate the narrative.
   */
  public detail?: string|undefined;
  public _detail?: fhir.FhirElement|undefined;
  /**
   * Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
   */
  public evidence?: fhir.DetectedIssueEvidence[]|undefined;
  /**
   * The date or period when the detected issue was initially identified.
   */
  public identifiedDateTime?: string|undefined;
  public _identifiedDateTime?: fhir.FhirElement|undefined;
  /**
   * The date or period when the detected issue was initially identified.
   */
  public identifiedPeriod?: fhir.Period|undefined;
  /**
   * Business identifier associated with the detected issue record.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * There's an implicit constraint on the number of implicated resources based on DetectedIssue.type; e.g. For drug-drug, there would be more than one.  For timing, there would typically only be one.
   */
  public implicated?: fhir.Reference[]|undefined;
  /**
   * Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
   */
  public mitigation?: fhir.DetectedIssueMitigation[]|undefined;
  /**
   * Indicates the patient whose record the detected issue is associated with.
   */
  public patient?: fhir.Reference|undefined;
  /**
   * The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
   */
  public reference?: string|undefined;
  public _reference?: fhir.FhirElement|undefined;
  /**
   * Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
   */
  public severity?: DetectedIssueSeverityEnum|undefined;
  public _severity?: fhir.FhirElement|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes cancelled and entered-in-error that mark the issue as not currently valid.
   */
  public status: DetectedIssueStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * Default constructor for DetectedIssue - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IDetectedIssue> = {}) {
    super(source);
    this.resourceType = 'DetectedIssue';
    if (source["author"]) { this.author = new fhir.Reference(source.author!); }
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (source["detail"]) { this.detail = source.detail; }
    if (source["_detail"]) { this._detail = new fhir.FhirElement(source._detail!); }
    if (source["evidence"]) { this.evidence = source.evidence.map((x:Partial<fhir.IDetectedIssueEvidence>) => new fhir.DetectedIssueEvidence(x)); }
    if (source["identifiedDateTime"]) { this.identifiedDateTime = source.identifiedDateTime; }
    if (source["_identifiedDateTime"]) { this._identifiedDateTime = new fhir.FhirElement(source._identifiedDateTime!); }
    if (source["identifiedPeriod"]) { this.identifiedPeriod = new fhir.Period(source.identifiedPeriod!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["implicated"]) { this.implicated = source.implicated.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["mitigation"]) { this.mitigation = source.mitigation.map((x:Partial<fhir.IDetectedIssueMitigation>) => new fhir.DetectedIssueMitigation(x)); }
    if (source["patient"]) { this.patient = new fhir.Reference(source.patient!); }
    if (source["reference"]) { this.reference = source.reference; }
    if (source["_reference"]) { this._reference = new fhir.FhirElement(source._reference!); }
    if (source["severity"]) { this.severity = source.severity; }
    if (source["_severity"]) { this._severity = new fhir.FhirElement(source._severity!); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
  }
  /**
   * Check if the current DetectedIssue contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["status"] === undefined) { missingElements.push("status"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a DetectedIssue from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IDetectedIssue):DetectedIssue {
    var dest:DetectedIssue = new DetectedIssue(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `DetectedIssue is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the DetectedIssue.severity field
 */
export enum DetectedIssueSeverityEnum {
  HIGH = "high",
  MODERATE = "moderate",
  LOW = "low",
}
/**
 * Code Values for the DetectedIssue.status field
 */
export enum DetectedIssueStatusEnum {
  REGISTERED = "registered",
  PRELIMINARY = "preliminary",
  FINAL = "final",
  AMENDED = "amended",
  CORRECTED = "corrected",
  CANCELLED = "cancelled",
  ENTERED_IN_ERROR = "entered-in-error",
  UNKNOWN = "unknown",
}
