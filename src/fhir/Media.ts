// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.
 */
export type IMedia = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "Media";
  /**
   * A procedure that is fulfilled in whole or in part by the creation of this media.
   */
  basedOn?: fhir.IReference[]|undefined;
  /**
   * Only used if not implicit in code found in Observation.code.  In many systems, this may be represented as a related observation instead of an inline component.   
   * If the use case requires BodySite to be handled as a separate resource (e.g. to identify and track separately) then use the standard extension[ bodySite](extension-bodysite.html).
   */
  bodySite?: fhir.ICodeableConcept|undefined;
  /**
   * Recommended content types: image/jpeg, image/png, image/tiff, video/mpeg, audio/mp4, application/dicom. Application/dicom can contain the transfer syntax as a parameter.  For media that covers a period of time (video/sound), the content.creationTime is the end time. Creation time is used for tracking, organizing versions and searching.
   */
  content: fhir.IAttachment|null;
  /**
   * The date and time(s) at which the media was collected.
   */
  createdDateTime?: string|undefined;
  _createdDateTime?: fhir.IFhirElement|undefined;
  /**
   * The date and time(s) at which the media was collected.
   */
  createdPeriod?: fhir.IPeriod|undefined;
  /**
   * An extension should be used if further typing of the device is needed.  Secondary devices used to support collecting a media can be represented using either extension or through the Observation.related element.
   */
  device?: fhir.IReference|undefined;
  /**
   * The name of the device / manufacturer of the device  that was used to make the recording.
   */
  deviceName?: string|undefined;
  _deviceName?: fhir.IFhirElement|undefined;
  /**
   * The duration might differ from occurrencePeriod if recording was paused.
   */
  duration?: number|undefined;
  _duration?: fhir.IFhirElement|undefined;
  /**
   * This will typically be the encounter the media occurred within.
   */
  encounter?: fhir.IReference|undefined;
  /**
   * if the number of frames is not supplied, the value may be unknown. Applications should not assume that there is only one frame unless it is explicitly stated.
   */
  frames?: number|undefined;
  _frames?: fhir.IFhirElement|undefined;
  /**
   * Height of the image in pixels (photo/video).
   */
  height?: number|undefined;
  _height?: fhir.IFhirElement|undefined;
  /**
   * The identifier label and use can be used to determine what kind of identifier it is.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * It may be the same as the [`lastUpdated` ](resource-definitions.html#Meta.lastUpdated) time of the resource itself.  For Observations that do require review and verification for certain updates, it might not be the same as the `lastUpdated` time of the resource itself due to a non-clinically significant update that does not require the new version to be reviewed and verified again.
   */
  issued?: string|undefined;
  _issued?: fhir.IFhirElement|undefined;
  /**
   * Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality.
   */
  modality?: fhir.ICodeableConcept|undefined;
  /**
   * Not to be used for observations, conclusions, etc. Instead use an [Observation](observation.html) based on the Media/ImagingStudy resource.
   */
  note?: fhir.IAnnotation[]|undefined;
  /**
   * The person who administered the collection of the image.
   */
  operator?: fhir.IReference|undefined;
  /**
   * Not to be used to link an event to an Encounter - use Media.encounter for that.
   * [The allowed reference resources may be adjusted as appropriate for the event resource].
   */
  partOf?: fhir.IReference[]|undefined;
  /**
   * Textual reasons can be captured using reasonCode.text.
   */
  reasonCode?: fhir.ICodeableConcept[]|undefined;
  /**
   * A nominal state-transition diagram can be found in the [[event.html#statemachine | Event pattern]] documentation
   * Unknown does not represent "other" - one of the defined statuses must apply.  Unknown is used when the authoring system is not sure what the current status is.
   */
  status: MediaStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
  /**
   * Who/What this Media is a record of.
   */
  subject?: fhir.IReference|undefined;
  /**
   * A code that classifies whether the media is an image, video or audio recording or some other media category.
   */
  type?: fhir.ICodeableConcept|undefined;
  /**
   * The name of the imaging view e.g. Lateral or Antero-posterior (AP).
   */
  view?: fhir.ICodeableConcept|undefined;
  /**
   * Width of the image in pixels (photo/video).
   */
  width?: number|undefined;
  _width?: fhir.IFhirElement|undefined;
}
/**
 * A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.
 */
export class Media extends fhir.DomainResource implements fhir.IMedia {
  /**
   * Resource Type Name
   */
  public override resourceType: "Media";
  /**
   * A procedure that is fulfilled in whole or in part by the creation of this media.
   */
  public basedOn?: fhir.Reference[]|undefined;
  /**
   * Only used if not implicit in code found in Observation.code.  In many systems, this may be represented as a related observation instead of an inline component.   
   * If the use case requires BodySite to be handled as a separate resource (e.g. to identify and track separately) then use the standard extension[ bodySite](extension-bodysite.html).
   */
  public bodySite?: fhir.CodeableConcept|undefined;
  /**
   * Recommended content types: image/jpeg, image/png, image/tiff, video/mpeg, audio/mp4, application/dicom. Application/dicom can contain the transfer syntax as a parameter.  For media that covers a period of time (video/sound), the content.creationTime is the end time. Creation time is used for tracking, organizing versions and searching.
   */
  public content: fhir.Attachment|null;
  /**
   * The date and time(s) at which the media was collected.
   */
  public createdDateTime?: string|undefined;
  public _createdDateTime?: fhir.FhirElement|undefined;
  /**
   * The date and time(s) at which the media was collected.
   */
  public createdPeriod?: fhir.Period|undefined;
  /**
   * An extension should be used if further typing of the device is needed.  Secondary devices used to support collecting a media can be represented using either extension or through the Observation.related element.
   */
  public device?: fhir.Reference|undefined;
  /**
   * The name of the device / manufacturer of the device  that was used to make the recording.
   */
  public deviceName?: string|undefined;
  public _deviceName?: fhir.FhirElement|undefined;
  /**
   * The duration might differ from occurrencePeriod if recording was paused.
   */
  public duration?: number|undefined;
  public _duration?: fhir.FhirElement|undefined;
  /**
   * This will typically be the encounter the media occurred within.
   */
  public encounter?: fhir.Reference|undefined;
  /**
   * if the number of frames is not supplied, the value may be unknown. Applications should not assume that there is only one frame unless it is explicitly stated.
   */
  public frames?: number|undefined;
  public _frames?: fhir.FhirElement|undefined;
  /**
   * Height of the image in pixels (photo/video).
   */
  public height?: number|undefined;
  public _height?: fhir.FhirElement|undefined;
  /**
   * The identifier label and use can be used to determine what kind of identifier it is.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * It may be the same as the [`lastUpdated` ](resource-definitions.html#Meta.lastUpdated) time of the resource itself.  For Observations that do require review and verification for certain updates, it might not be the same as the `lastUpdated` time of the resource itself due to a non-clinically significant update that does not require the new version to be reviewed and verified again.
   */
  public issued?: string|undefined;
  public _issued?: fhir.FhirElement|undefined;
  /**
   * Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality.
   */
  public modality?: fhir.CodeableConcept|undefined;
  /**
   * Not to be used for observations, conclusions, etc. Instead use an [Observation](observation.html) based on the Media/ImagingStudy resource.
   */
  public note?: fhir.Annotation[]|undefined;
  /**
   * The person who administered the collection of the image.
   */
  public operator?: fhir.Reference|undefined;
  /**
   * Not to be used to link an event to an Encounter - use Media.encounter for that.
   * [The allowed reference resources may be adjusted as appropriate for the event resource].
   */
  public partOf?: fhir.Reference[]|undefined;
  /**
   * Textual reasons can be captured using reasonCode.text.
   */
  public reasonCode?: fhir.CodeableConcept[]|undefined;
  /**
   * A nominal state-transition diagram can be found in the [[event.html#statemachine | Event pattern]] documentation
   * Unknown does not represent "other" - one of the defined statuses must apply.  Unknown is used when the authoring system is not sure what the current status is.
   */
  public status: MediaStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * Who/What this Media is a record of.
   */
  public subject?: fhir.Reference|undefined;
  /**
   * A code that classifies whether the media is an image, video or audio recording or some other media category.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The name of the imaging view e.g. Lateral or Antero-posterior (AP).
   */
  public view?: fhir.CodeableConcept|undefined;
  /**
   * Width of the image in pixels (photo/video).
   */
  public width?: number|undefined;
  public _width?: fhir.FhirElement|undefined;
  /**
   * Default constructor for Media - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IMedia> = {}) {
    super(source);
    this.resourceType = 'Media';
    if (source["basedOn"]) { this.basedOn = source.basedOn.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["bodySite"]) { this.bodySite = new fhir.CodeableConcept(source.bodySite!); }
    this.content = null;
    if (source["content"]) { this.content = new fhir.Attachment(source.content!); }
    if (this.content === undefined) { this.content = null }
    if (source["createdDateTime"]) { this.createdDateTime = source.createdDateTime; }
    if (source["_createdDateTime"]) { this._createdDateTime = new fhir.FhirElement(source._createdDateTime!); }
    if (source["createdPeriod"]) { this.createdPeriod = new fhir.Period(source.createdPeriod!); }
    if (source["device"]) { this.device = new fhir.Reference(source.device!); }
    if (source["deviceName"]) { this.deviceName = source.deviceName; }
    if (source["_deviceName"]) { this._deviceName = new fhir.FhirElement(source._deviceName!); }
    if (source["duration"]) { this.duration = source.duration; }
    if (source["_duration"]) { this._duration = new fhir.FhirElement(source._duration!); }
    if (source["encounter"]) { this.encounter = new fhir.Reference(source.encounter!); }
    if (source["frames"]) { this.frames = source.frames; }
    if (source["_frames"]) { this._frames = new fhir.FhirElement(source._frames!); }
    if (source["height"]) { this.height = source.height; }
    if (source["_height"]) { this._height = new fhir.FhirElement(source._height!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["issued"]) { this.issued = source.issued; }
    if (source["_issued"]) { this._issued = new fhir.FhirElement(source._issued!); }
    if (source["modality"]) { this.modality = new fhir.CodeableConcept(source.modality!); }
    if (source["note"]) { this.note = source.note.map((x:Partial<fhir.IAnnotation>) => new fhir.Annotation(x)); }
    if (source["operator"]) { this.operator = new fhir.Reference(source.operator!); }
    if (source["partOf"]) { this.partOf = source.partOf.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["reasonCode"]) { this.reasonCode = source.reasonCode.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["subject"]) { this.subject = new fhir.Reference(source.subject!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
    if (source["view"]) { this.view = new fhir.CodeableConcept(source.view!); }
    if (source["width"]) { this.width = source.width; }
    if (source["_width"]) { this._width = new fhir.FhirElement(source._width!); }
  }
  /**
   * Check if the current Media contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["content"] === undefined) { missingElements.push("content"); }
    if (this["status"] === undefined) { missingElements.push("status"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Media from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IMedia):Media {
    var dest:Media = new Media(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `Media is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the Media.status field
 */
export enum MediaStatusEnum {
  PREPARATION = "preparation",
  IN_PROGRESS = "in-progress",
  NOT_DONE = "not-done",
  ON_HOLD = "on-hold",
  STOPPED = "stopped",
  COMPLETED = "completed",
  ENTERED_IN_ERROR = "entered-in-error",
  UNKNOWN = "unknown",
}
