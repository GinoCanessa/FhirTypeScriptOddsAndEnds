// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Linkage

import * as fhir from '../fhir.js';

import { LinkageTypeValueSet, LinkageTypeValueSetType,} from '../fhirValueSets/LinkageTypeValueSet.js';
import { LinkageTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Valid arguments for the LinkageItem type.
 */
export interface LinkageItemArgs extends fhir.BackboneElementArgs {
  /**
   * Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
   */
  type: LinkageTypeValueSetEnum|null;
  /**
   * The resource instance being linked as part of the group.
   */
  resource: fhir.ReferenceArgs|null;
}

/**
 * Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
 */
export class LinkageItem extends fhir.BackboneElement {
  readonly __dataType:string = 'LinkageItem';
  /**
   * Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
   */
  public type: LinkageTypeValueSetEnum|null;
  /**
   * The resource instance being linked as part of the group.
   */
  public resource: fhir.Reference|null;
  /**
   * Default constructor for LinkageItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<LinkageItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = source.type; }
    else { this.type = null; }
    if (source['resource']) { this.resource = new fhir.Reference(source.resource); }
    else { this.resource = null; }
  }
  /**
   * Required-bound Value Set for type
   */
  public static typeRequiredValueSet():LinkageTypeValueSetType {
    return LinkageTypeValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['type']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property type:LinkageTypeValueSetEnum fhir: Linkage.item.type:code", }));
    }
    if (!this['resource']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property resource:fhir.Reference fhir: Linkage.item.resource:Reference", }));
    }
    if (this["resource"]) { outcome.issue!.push(...this.resource.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the Linkage type.
 */
export interface LinkageArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Linkage"|undefined;
  /**
   * If false, any asserted linkages should not be considered current/relevant/applicable.
   */
  active?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
   */
  author?: fhir.ReferenceArgs|undefined;
  /**
   * Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
   */
  item: fhir.LinkageItemArgs[]|null;
}

/**
 * Identifies two or more records (resource instances) that refer to the same real-world "occurrence".
 */
export class Linkage extends fhir.DomainResource {
  readonly __dataType:string = 'Linkage';
  /**
   * Resource Type Name
   */
  public resourceType: "Linkage";
  /**
   * If false, any asserted linkages should not be considered current/relevant/applicable.
   */
  public active?: fhir.FhirBoolean|undefined;
  /**
   * Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
   */
  public author?: fhir.Reference|undefined;
  /**
   * Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
   */
  public item: fhir.LinkageItem[]|null = [];
  /**
   * Default constructor for Linkage - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<LinkageArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Linkage';
    if (source['active']) { this.active = new fhir.FhirBoolean({value: source.active}); }
    if (source['author']) { this.author = new fhir.Reference(source.author); }
    if (source['item']) { this.item = source.item.map((x) => new fhir.LinkageItem(x)); }
    else { this.item = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['resourceType']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property resourceType:'Linkage' fhir: Linkage.resourceType:'Linkage'", }));
    }
    if (this["active"]) { outcome.issue!.push(...this.active.doModelValidation().issue!); }
    if (this["author"]) { outcome.issue!.push(...this.author.doModelValidation().issue!); }
    if (!this['item']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property item:fhir.LinkageItem[] fhir: Linkage.item:item", }));
    } else if (!Array.isArray(this.item)) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue,  diagnostics: "Found scalar in array property item:fhir.LinkageItem[] fhir: Linkage.item:item", }));
    } else if (this.item.length === 0) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property item:fhir.LinkageItem[] fhir: Linkage.item:item", }));
    }
    if (this["item"]) { this.item.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
