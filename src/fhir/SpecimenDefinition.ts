// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
 */
export type ISpecimenDefinitionTypeTestedContainerAdditive = fhir.IBackboneElement & {
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveReference?: fhir.IReference|undefined;
}
/**
 * The specimen's container.
 */
export type ISpecimenDefinitionTypeTestedContainer = fhir.IBackboneElement & {
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additive?: fhir.ISpecimenDefinitionTypeTestedContainerAdditive[]|undefined;
  /**
   * Color of container cap.
   */
  cap?: fhir.ICodeableConcept|undefined;
  /**
   * The capacity (volume or other measure) of this kind of container.
   */
  capacity?: fhir.IQuantity|undefined;
  /**
   * The textual description of the kind of container.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * The type of material of the container.
   */
  material?: fhir.ICodeableConcept|undefined;
  /**
   * The minimum volume to be conditioned in the container.
   */
  minimumVolumeQuantity?: fhir.IQuantity|undefined;
  /**
   * The minimum volume to be conditioned in the container.
   */
  minimumVolumeString?: string|undefined;
  _minimumVolumeString?: fhir.IFhirElement|undefined;
  /**
   * Special processing that should be applied to the container for this kind of specimen.
   */
  preparation?: string|undefined;
  _preparation?: fhir.IFhirElement|undefined;
  /**
   * The type of container used to contain this kind of specimen.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
 */
export type ISpecimenDefinitionTypeTestedHandling = fhir.IBackboneElement & {
  /**
   * Additional textual instructions for the preservation or transport of the specimen. For instance, 'Protect from light exposure'.
   */
  instruction?: string|undefined;
  _instruction?: fhir.IFhirElement|undefined;
  /**
   * The maximum time interval of preservation of the specimen with these conditions.
   */
  maxDuration?: fhir.IDuration|undefined;
  /**
   * It qualifies the interval of temperature, which characterizes an occurrence of handling. Conditions that are not related to temperature may be handled in the instruction element.
   */
  temperatureQualifier?: fhir.ICodeableConcept|undefined;
  /**
   * The temperature interval for this set of handling instructions.
   */
  temperatureRange?: fhir.IRange|undefined;
}
/**
 * Specimen conditioned in a container as expected by the testing laboratory.
 */
export type ISpecimenDefinitionTypeTested = fhir.IBackboneElement & {
  /**
   * The specimen's container.
   */
  container?: fhir.ISpecimenDefinitionTypeTestedContainer|undefined;
  /**
   * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
   */
  handling?: fhir.ISpecimenDefinitionTypeTestedHandling[]|undefined;
  /**
   * Primary of secondary specimen.
   */
  isDerived?: boolean|undefined;
  _isDerived?: fhir.IFhirElement|undefined;
  /**
   * The preference for this type of conditioned specimen.
   */
  preference: SpecimenDefinitionTypeTestedPreferenceEnum|null;
  _preference?: fhir.IFhirElement|undefined;
  /**
   * Criterion for rejection of the specimen in its container by the laboratory.
   */
  rejectionCriterion?: fhir.ICodeableConcept[]|undefined;
  /**
   * Requirements for delivery and special handling of this kind of conditioned specimen.
   */
  requirement?: string|undefined;
  _requirement?: fhir.IFhirElement|undefined;
  /**
   * The usual time that a specimen of this kind is retained after the ordered tests are completed, for the purpose of additional testing.
   */
  retentionTime?: fhir.IDuration|undefined;
  /**
   * The kind of specimen conditioned for testing expected by lab.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * A kind of specimen with associated set of requirements.
 */
export type ISpecimenDefinition = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "SpecimenDefinition";
  /**
   * The action to be performed for collecting the specimen.
   */
  collection?: fhir.ICodeableConcept[]|undefined;
  /**
   * A business identifier associated with the kind of specimen.
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * Preparation of the patient for specimen collection.
   */
  patientPreparation?: fhir.ICodeableConcept[]|undefined;
  /**
   * Time aspect of specimen collection (duration or offset).
   */
  timeAspect?: string|undefined;
  _timeAspect?: fhir.IFhirElement|undefined;
  /**
   * The kind of material to be collected.
   */
  typeCollected?: fhir.ICodeableConcept|undefined;
  /**
   * Specimen conditioned in a container as expected by the testing laboratory.
   */
  typeTested?: fhir.ISpecimenDefinitionTypeTested[]|undefined;
}
/**
 * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
 */
export class SpecimenDefinitionTypeTestedContainerAdditive extends fhir.BackboneElement implements fhir.ISpecimenDefinitionTypeTestedContainerAdditive {
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  public additiveCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  public additiveReference?: fhir.Reference|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTestedContainerAdditive - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenDefinitionTypeTestedContainerAdditive> = {}) {
    super(source);
    if (source["additiveCodeableConcept"]) { this.additiveCodeableConcept = new fhir.CodeableConcept(source.additiveCodeableConcept!); }
    if (source["additiveReference"]) { this.additiveReference = new fhir.Reference(source.additiveReference!); }
  }
  /**
   * Check if the current SpecimenDefinitionTypeTestedContainerAdditive contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenDefinitionTypeTestedContainerAdditive from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenDefinitionTypeTestedContainerAdditive):SpecimenDefinitionTypeTestedContainerAdditive {
    var dest:SpecimenDefinitionTypeTestedContainerAdditive = new SpecimenDefinitionTypeTestedContainerAdditive(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenDefinitionTypeTestedContainerAdditive is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The specimen's container.
 */
export class SpecimenDefinitionTypeTestedContainer extends fhir.BackboneElement implements fhir.ISpecimenDefinitionTypeTestedContainer {
  /**
   * Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  public additive?: fhir.SpecimenDefinitionTypeTestedContainerAdditive[]|undefined;
  /**
   * Color of container cap.
   */
  public cap?: fhir.CodeableConcept|undefined;
  /**
   * The capacity (volume or other measure) of this kind of container.
   */
  public capacity?: fhir.Quantity|undefined;
  /**
   * The textual description of the kind of container.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * The type of material of the container.
   */
  public material?: fhir.CodeableConcept|undefined;
  /**
   * The minimum volume to be conditioned in the container.
   */
  public minimumVolumeQuantity?: fhir.Quantity|undefined;
  /**
   * The minimum volume to be conditioned in the container.
   */
  public minimumVolumeString?: string|undefined;
  public _minimumVolumeString?: fhir.FhirElement|undefined;
  /**
   * Special processing that should be applied to the container for this kind of specimen.
   */
  public preparation?: string|undefined;
  public _preparation?: fhir.FhirElement|undefined;
  /**
   * The type of container used to contain this kind of specimen.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTestedContainer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenDefinitionTypeTestedContainer> = {}) {
    super(source);
    if (source["additive"]) { this.additive = source.additive.map((x:Partial<fhir.ISpecimenDefinitionTypeTestedContainerAdditive>) => new fhir.SpecimenDefinitionTypeTestedContainerAdditive(x)); }
    if (source["cap"]) { this.cap = new fhir.CodeableConcept(source.cap!); }
    if (source["capacity"]) { this.capacity = new fhir.Quantity(source.capacity!); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["material"]) { this.material = new fhir.CodeableConcept(source.material!); }
    if (source["minimumVolumeQuantity"]) { this.minimumVolumeQuantity = new fhir.Quantity(source.minimumVolumeQuantity!); }
    if (source["minimumVolumeString"]) { this.minimumVolumeString = source.minimumVolumeString; }
    if (source["_minimumVolumeString"]) { this._minimumVolumeString = new fhir.FhirElement(source._minimumVolumeString!); }
    if (source["preparation"]) { this.preparation = source.preparation; }
    if (source["_preparation"]) { this._preparation = new fhir.FhirElement(source._preparation!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SpecimenDefinitionTypeTestedContainer contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenDefinitionTypeTestedContainer from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenDefinitionTypeTestedContainer):SpecimenDefinitionTypeTestedContainer {
    var dest:SpecimenDefinitionTypeTestedContainer = new SpecimenDefinitionTypeTestedContainer(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenDefinitionTypeTestedContainer is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
 */
export class SpecimenDefinitionTypeTestedHandling extends fhir.BackboneElement implements fhir.ISpecimenDefinitionTypeTestedHandling {
  /**
   * Additional textual instructions for the preservation or transport of the specimen. For instance, 'Protect from light exposure'.
   */
  public instruction?: string|undefined;
  public _instruction?: fhir.FhirElement|undefined;
  /**
   * The maximum time interval of preservation of the specimen with these conditions.
   */
  public maxDuration?: fhir.Duration|undefined;
  /**
   * It qualifies the interval of temperature, which characterizes an occurrence of handling. Conditions that are not related to temperature may be handled in the instruction element.
   */
  public temperatureQualifier?: fhir.CodeableConcept|undefined;
  /**
   * The temperature interval for this set of handling instructions.
   */
  public temperatureRange?: fhir.Range|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTestedHandling - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenDefinitionTypeTestedHandling> = {}) {
    super(source);
    if (source["instruction"]) { this.instruction = source.instruction; }
    if (source["_instruction"]) { this._instruction = new fhir.FhirElement(source._instruction!); }
    if (source["maxDuration"]) { this.maxDuration = new fhir.Duration(source.maxDuration!); }
    if (source["temperatureQualifier"]) { this.temperatureQualifier = new fhir.CodeableConcept(source.temperatureQualifier!); }
    if (source["temperatureRange"]) { this.temperatureRange = new fhir.Range(source.temperatureRange!); }
  }
  /**
   * Check if the current SpecimenDefinitionTypeTestedHandling contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenDefinitionTypeTestedHandling from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenDefinitionTypeTestedHandling):SpecimenDefinitionTypeTestedHandling {
    var dest:SpecimenDefinitionTypeTestedHandling = new SpecimenDefinitionTypeTestedHandling(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenDefinitionTypeTestedHandling is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Specimen conditioned in a container as expected by the testing laboratory.
 */
export class SpecimenDefinitionTypeTested extends fhir.BackboneElement implements fhir.ISpecimenDefinitionTypeTested {
  /**
   * The specimen's container.
   */
  public container?: fhir.SpecimenDefinitionTypeTestedContainer|undefined;
  /**
   * Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
   */
  public handling?: fhir.SpecimenDefinitionTypeTestedHandling[]|undefined;
  /**
   * Primary of secondary specimen.
   */
  public isDerived?: boolean|undefined;
  public _isDerived?: fhir.FhirElement|undefined;
  /**
   * The preference for this type of conditioned specimen.
   */
  public preference: SpecimenDefinitionTypeTestedPreferenceEnum|null;
  public _preference?: fhir.FhirElement|undefined;
  /**
   * Criterion for rejection of the specimen in its container by the laboratory.
   */
  public rejectionCriterion?: fhir.CodeableConcept[]|undefined;
  /**
   * Requirements for delivery and special handling of this kind of conditioned specimen.
   */
  public requirement?: string|undefined;
  public _requirement?: fhir.FhirElement|undefined;
  /**
   * The usual time that a specimen of this kind is retained after the ordered tests are completed, for the purpose of additional testing.
   */
  public retentionTime?: fhir.Duration|undefined;
  /**
   * The kind of specimen conditioned for testing expected by lab.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SpecimenDefinitionTypeTested - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenDefinitionTypeTested> = {}) {
    super(source);
    if (source["container"]) { this.container = new fhir.SpecimenDefinitionTypeTestedContainer(source.container!); }
    if (source["handling"]) { this.handling = source.handling.map((x:Partial<fhir.ISpecimenDefinitionTypeTestedHandling>) => new fhir.SpecimenDefinitionTypeTestedHandling(x)); }
    if (source["isDerived"]) { this.isDerived = source.isDerived; }
    if (source["_isDerived"]) { this._isDerived = new fhir.FhirElement(source._isDerived!); }
    this.preference = null;
    if (source["preference"]) { this.preference = source.preference; }
    if (this.preference === undefined) { this.preference = null }
    if (source["_preference"]) { this._preference = new fhir.FhirElement(source._preference!); }
    if (source["rejectionCriterion"]) { this.rejectionCriterion = source.rejectionCriterion.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["requirement"]) { this.requirement = source.requirement; }
    if (source["_requirement"]) { this._requirement = new fhir.FhirElement(source._requirement!); }
    if (source["retentionTime"]) { this.retentionTime = new fhir.Duration(source.retentionTime!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SpecimenDefinitionTypeTested contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["preference"] === undefined) { missingElements.push("preference"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenDefinitionTypeTested from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenDefinitionTypeTested):SpecimenDefinitionTypeTested {
    var dest:SpecimenDefinitionTypeTested = new SpecimenDefinitionTypeTested(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenDefinitionTypeTested is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A kind of specimen with associated set of requirements.
 */
export class SpecimenDefinition extends fhir.DomainResource implements fhir.ISpecimenDefinition {
  /**
   * Resource Type Name
   */
  public override resourceType: "SpecimenDefinition";
  /**
   * The action to be performed for collecting the specimen.
   */
  public collection?: fhir.CodeableConcept[]|undefined;
  /**
   * A business identifier associated with the kind of specimen.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Preparation of the patient for specimen collection.
   */
  public patientPreparation?: fhir.CodeableConcept[]|undefined;
  /**
   * Time aspect of specimen collection (duration or offset).
   */
  public timeAspect?: string|undefined;
  public _timeAspect?: fhir.FhirElement|undefined;
  /**
   * The kind of material to be collected.
   */
  public typeCollected?: fhir.CodeableConcept|undefined;
  /**
   * Specimen conditioned in a container as expected by the testing laboratory.
   */
  public typeTested?: fhir.SpecimenDefinitionTypeTested[]|undefined;
  /**
   * Default constructor for SpecimenDefinition - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenDefinition> = {}) {
    super(source);
    this.resourceType = 'SpecimenDefinition';
    if (source["collection"]) { this.collection = source.collection.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["patientPreparation"]) { this.patientPreparation = source.patientPreparation.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["timeAspect"]) { this.timeAspect = source.timeAspect; }
    if (source["_timeAspect"]) { this._timeAspect = new fhir.FhirElement(source._timeAspect!); }
    if (source["typeCollected"]) { this.typeCollected = new fhir.CodeableConcept(source.typeCollected!); }
    if (source["typeTested"]) { this.typeTested = source.typeTested.map((x:Partial<fhir.ISpecimenDefinitionTypeTested>) => new fhir.SpecimenDefinitionTypeTested(x)); }
  }
  /**
   * Check if the current SpecimenDefinition contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenDefinition from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenDefinition):SpecimenDefinition {
    var dest:SpecimenDefinition = new SpecimenDefinition(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenDefinition is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the SpecimenDefinition.typeTested.preference field
 */
export enum SpecimenDefinitionTypeTestedPreferenceEnum {
  PREFERRED = "preferred",
  ALTERNATE = "alternate",
}
