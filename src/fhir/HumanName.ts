// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * A human's name with the ability to identify parts and usage.
 */
export type IHumanName = fhir.IFhirElement & {
  /**
   * Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   */
  family?: string|undefined;
  _family?: fhir.IFhirElement|undefined;
  /**
   * If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren't due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   */
  given?: string[]|undefined;
  _given?: fhir.IFhirElement[]|undefined;
  /**
   * Indicates the period of time when this name was valid for the named person.
   */
  period?: fhir.IPeriod|undefined;
  /**
   * Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   */
  prefix?: string[]|undefined;
  _prefix?: fhir.IFhirElement[]|undefined;
  /**
   * Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   */
  suffix?: string[]|undefined;
  _suffix?: fhir.IFhirElement[]|undefined;
  /**
   * Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn't found in a part.
   */
  text?: string|undefined;
  _text?: fhir.IFhirElement|undefined;
  /**
   * Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   */
  use?: HumanNameUseEnum|undefined;
  _use?: fhir.IFhirElement|undefined;
}
/**
 * A human's name with the ability to identify parts and usage.
 */
export class HumanName extends fhir.FhirElement implements fhir.IHumanName {
  /**
   * Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   */
  public family?: string|undefined;
  public _family?: fhir.FhirElement|undefined;
  /**
   * If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren't due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   */
  public given?: string[]|undefined;
  public _given?: fhir.FhirElement[]|undefined;
  /**
   * Indicates the period of time when this name was valid for the named person.
   */
  public period?: fhir.Period|undefined;
  /**
   * Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   */
  public prefix?: string[]|undefined;
  public _prefix?: fhir.FhirElement[]|undefined;
  /**
   * Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   */
  public suffix?: string[]|undefined;
  public _suffix?: fhir.FhirElement[]|undefined;
  /**
   * Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn't found in a part.
   */
  public text?: string|undefined;
  public _text?: fhir.FhirElement|undefined;
  /**
   * Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   */
  public use?: HumanNameUseEnum|undefined;
  public _use?: fhir.FhirElement|undefined;
  /**
   * Default constructor for HumanName - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IHumanName> = {}) {
    super(source);
    if (source["family"]) { this.family = source.family; }
    if (source["_family"]) { this._family = new fhir.FhirElement(source._family!); }
    if (source["given"]) { this.given = source.given.map((x) => (x)); }
    if (source["_given"]) { this._given = source._given.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["period"]) { this.period = new fhir.Period(source.period!); }
    if (source["prefix"]) { this.prefix = source.prefix.map((x) => (x)); }
    if (source["_prefix"]) { this._prefix = source._prefix.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["suffix"]) { this.suffix = source.suffix.map((x) => (x)); }
    if (source["_suffix"]) { this._suffix = source._suffix.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["text"]) { this.text = source.text; }
    if (source["_text"]) { this._text = new fhir.FhirElement(source._text!); }
    if (source["use"]) { this.use = source.use; }
    if (source["_use"]) { this._use = new fhir.FhirElement(source._use!); }
  }
  /**
   * Check if the current HumanName contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a HumanName from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IHumanName):HumanName {
    var dest:HumanName = new HumanName(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `HumanName is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }

/**
 * Convert a HumanName into a displayable string
 */
ToDisplay(familyFirst:boolean = true, includeAnnotations:boolean = false):string {
  if ((this.text) && (this.text.length > 0)) {
    return this.text;
  }

  var val:string = '';

  if (familyFirst) {
    if (this.family) {
      val = this.family;
    }

    if (this.given) {
      val += (val.length > 0 ? ', ' : '') + this.given.join(' ');
    }

    if (includeAnnotations) {
      if (this.suffix) {
        val += (val.length > 0 ? ', ' : '') + this.suffix.join(', ');
      }

      if (this.prefix) {
        val += (val.length > 0 ? ', ' : '') + this.prefix.join(', ');
      }
    }

    return val;
  }

  if ((includeAnnotations) && (this.prefix)) {
    val += this.prefix.join(', ');
  }

  if (this.given) {
    val = (val.length > 0 ? ' ' : '') + this.given.join(' ');
  }
  if (this.family) {
    val += (val.length > 0 ? ' ' : '') + this.family;
  }

  if ((includeAnnotations) && (this.suffix)) {
    val += (val.length > 0 ? ', ' : '') + this.suffix.join(', ');
  }

  return val;
}
}
/**
 * Code Values for the HumanName.use field
 */
export enum HumanNameUseEnum {
  USUAL = "usual",
  OFFICIAL = "official",
  TEMP = "temp",
  NICKNAME = "nickname",
  ANONYMOUS = "anonymous",
  OLD = "old",
  MAIDEN = "maiden",
}
