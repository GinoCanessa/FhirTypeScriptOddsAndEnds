// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: MedicinalProductPackaged

import * as fhir from '../fhir.js'


/**
 * Batch numbering.
 */
export type IMedicinalProductPackagedBatchIdentifier = fhir.IBackboneElement & { 
  /**
   * A number appearing on the outer packaging of a specific batch.
   */
  outerPackaging: fhir.IIdentifier|null;
  /**
   * A number appearing on the immediate packaging (and not the outer packaging).
   */
  immediatePackaging?: fhir.IIdentifier|undefined;
}

/**
 * A packaging item, as a contained for medicine, possibly with other packaging items within.
 */
export type IMedicinalProductPackagedPackageItem = fhir.IBackboneElement & { 
  /**
   * Including possibly Data Carrier Identifier.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The physical type of the container of the medicine.
   */
  type: fhir.ICodeableConcept|null;
  /**
   * The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1.
   */
  quantity: fhir.IQuantity|null;
  /**
   * Material type of the package item.
   */
  material?: fhir.ICodeableConcept[]|undefined;
  /**
   * A possible alternate material for the packaging.
   */
  alternateMaterial?: fhir.ICodeableConcept[]|undefined;
  /**
   * A device accompanying a medicinal product.
   */
  device?: fhir.IReference[]|undefined;
  /**
   * The manufactured item as contained in the packaged medicinal product.
   */
  manufacturedItem?: fhir.IReference[]|undefined;
  /**
   * Allows containers within containers.
   */
  packageItem?: fhir.IMedicinalProductPackagedPackageItem[]|undefined;
  /**
   * Dimensions, color etc.
   */
  physicalCharacteristics?: fhir.IProdCharacteristic|undefined;
  /**
   * Other codeable characteristics.
   */
  otherCharacteristics?: fhir.ICodeableConcept[]|undefined;
  /**
   * Shelf Life and storage information.
   */
  shelfLifeStorage?: fhir.IProductShelfLife[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  manufacturer?: fhir.IReference[]|undefined;
}

/**
 * A medicinal product in a container or package.
 */
export type IMedicinalProductPackaged = fhir.IDomainResource & { 
  /**
   * Resource Type Name
   */
  resourceType: "MedicinalProductPackaged";
  /**
   * Unique identifier.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The product with this is a pack for.
   */
  subject?: fhir.IReference[]|undefined;
  /**
   * Textual description.
   */
  description?: string|undefined;
  /**
   * Extended properties for primitive element: MedicinalProductPackaged.description
   */
  _description?: fhir.IFhirElement|undefined;
  /**
   * The legal status of supply of the medicinal product as classified by the regulator.
   */
  legalStatusOfSupply?: fhir.ICodeableConcept|undefined;
  /**
   * Marketing information.
   */
  marketingStatus?: fhir.IMarketingStatus[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  marketingAuthorization?: fhir.IReference|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  manufacturer?: fhir.IReference[]|undefined;
  /**
   * Batch numbering.
   */
  batchIdentifier?: fhir.IMedicinalProductPackagedBatchIdentifier[]|undefined;
  /**
   * A packaging item, as a contained for medicine, possibly with other packaging items within.
   */
  packageItem: fhir.IMedicinalProductPackagedPackageItem[]|null;
}

/**
 * Batch numbering.
 */
export class MedicinalProductPackagedBatchIdentifier extends fhir.BackboneElement implements IMedicinalProductPackagedBatchIdentifier {
  /**
   * A number appearing on the outer packaging of a specific batch.
   */
  public outerPackaging: fhir.Identifier|null;
  /**
   * A number appearing on the immediate packaging (and not the outer packaging).
   */
  public immediatePackaging?: fhir.Identifier|undefined;
  /**
   * Default constructor for MedicinalProductPackagedBatchIdentifier - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<IMedicinalProductPackagedBatchIdentifier> = { }) {
    super(source);
    if (source['outerPackaging']) { this.outerPackaging = new fhir.Identifier(source.outerPackaging!); }
    else { this.outerPackaging = null; }
    if (source['immediatePackaging']) { this.immediatePackaging = new fhir.Identifier(source.immediatePackaging!); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():[string,string][] {
    var results:[string,string][] = super.doModelValidation();
    if (!this["outerPackaging"]) { results.push(["outerPackaging",'Missing required element: MedicinalProductPackaged.batchIdentifier.outerPackaging']); }
    if (this["outerPackaging"]) { results.push(...this.outerPackaging.doModelValidation()); }
    if (this["immediatePackaging"]) { results.push(...this.immediatePackaging.doModelValidation()); }
    return results;
  }
}

/**
 * A packaging item, as a contained for medicine, possibly with other packaging items within.
 */
export class MedicinalProductPackagedPackageItem extends fhir.BackboneElement implements IMedicinalProductPackagedPackageItem {
  /**
   * Including possibly Data Carrier Identifier.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The physical type of the container of the medicine.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1.
   */
  public quantity: fhir.Quantity|null;
  /**
   * Material type of the package item.
   */
  public material?: fhir.CodeableConcept[]|undefined;
  /**
   * A possible alternate material for the packaging.
   */
  public alternateMaterial?: fhir.CodeableConcept[]|undefined;
  /**
   * A device accompanying a medicinal product.
   */
  public device?: fhir.Reference[]|undefined;
  /**
   * The manufactured item as contained in the packaged medicinal product.
   */
  public manufacturedItem?: fhir.Reference[]|undefined;
  /**
   * Allows containers within containers.
   */
  public packageItem?: fhir.MedicinalProductPackagedPackageItem[]|undefined;
  /**
   * Dimensions, color etc.
   */
  public physicalCharacteristics?: fhir.ProdCharacteristic|undefined;
  /**
   * Other codeable characteristics.
   */
  public otherCharacteristics?: fhir.CodeableConcept[]|undefined;
  /**
   * Shelf Life and storage information.
   */
  public shelfLifeStorage?: fhir.ProductShelfLife[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  public manufacturer?: fhir.Reference[]|undefined;
  /**
   * Default constructor for MedicinalProductPackagedPackageItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<IMedicinalProductPackagedPackageItem> = { }) {
    super(source);
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type!); }
    else { this.type = null; }
    if (source['quantity']) { this.quantity = new fhir.Quantity(source.quantity!); }
    else { this.quantity = null; }
    if (source['material']) { this.material = source.material.map((x) => new fhir.CodeableConcept(x)); }
    if (source['alternateMaterial']) { this.alternateMaterial = source.alternateMaterial.map((x) => new fhir.CodeableConcept(x)); }
    if (source['device']) { this.device = source.device.map((x) => new fhir.Reference(x)); }
    if (source['manufacturedItem']) { this.manufacturedItem = source.manufacturedItem.map((x) => new fhir.Reference(x)); }
    if (source['packageItem']) { this.packageItem = source.packageItem.map((x) => new fhir.MedicinalProductPackagedPackageItem(x)); }
    if (source['physicalCharacteristics']) { this.physicalCharacteristics = new fhir.ProdCharacteristic(source.physicalCharacteristics!); }
    if (source['otherCharacteristics']) { this.otherCharacteristics = source.otherCharacteristics.map((x) => new fhir.CodeableConcept(x)); }
    if (source['shelfLifeStorage']) { this.shelfLifeStorage = source.shelfLifeStorage.map((x) => new fhir.ProductShelfLife(x)); }
    if (source['manufacturer']) { this.manufacturer = source.manufacturer.map((x) => new fhir.Reference(x)); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():[string,string][] {
    var results:[string,string][] = super.doModelValidation();
    if (this["identifier"]) { this.identifier.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (!this["type"]) { results.push(["type",'Missing required element: MedicinalProductPackaged.packageItem.type']); }
    if (this["type"]) { results.push(...this.type.doModelValidation()); }
    if (!this["quantity"]) { results.push(["quantity",'Missing required element: MedicinalProductPackaged.packageItem.quantity']); }
    if (this["quantity"]) { results.push(...this.quantity.doModelValidation()); }
    if (this["material"]) { this.material.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["alternateMaterial"]) { this.alternateMaterial.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["device"]) { this.device.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["manufacturedItem"]) { this.manufacturedItem.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["packageItem"]) { this.packageItem.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["physicalCharacteristics"]) { results.push(...this.physicalCharacteristics.doModelValidation()); }
    if (this["otherCharacteristics"]) { this.otherCharacteristics.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["shelfLifeStorage"]) { this.shelfLifeStorage.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["manufacturer"]) { this.manufacturer.forEach((x) => { results.push(...x.doModelValidation()); }) }
    return results;
  }
}

/**
 * A medicinal product in a container or package.
 */
export class MedicinalProductPackaged extends fhir.DomainResource implements IMedicinalProductPackaged {
  /**
   * Resource Type Name
   */
  public resourceType: "MedicinalProductPackaged";
  /**
   * Unique identifier.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The product with this is a pack for.
   */
  public subject?: fhir.Reference[]|undefined;
  /**
   * Textual description.
   */
  public description?: string|undefined;
  /**
   * Extended properties for primitive element: MedicinalProductPackaged.description
   */
  public _description?: fhir.FhirElement|undefined;
  /**
   * The legal status of supply of the medicinal product as classified by the regulator.
   */
  public legalStatusOfSupply?: fhir.CodeableConcept|undefined;
  /**
   * Marketing information.
   */
  public marketingStatus?: fhir.MarketingStatus[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  public marketingAuthorization?: fhir.Reference|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  public manufacturer?: fhir.Reference[]|undefined;
  /**
   * Batch numbering.
   */
  public batchIdentifier?: fhir.MedicinalProductPackagedBatchIdentifier[]|undefined;
  /**
   * A packaging item, as a contained for medicine, possibly with other packaging items within.
   */
  public packageItem: fhir.MedicinalProductPackagedPackageItem[]|null;
  /**
   * Default constructor for MedicinalProductPackaged - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<IMedicinalProductPackaged> = { }) {
    super(source);
    this.resourceType = 'MedicinalProductPackaged';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    if (source['subject']) { this.subject = source.subject.map((x) => new fhir.Reference(x)); }
    if (source['description']) { this.description = source.description; }
    if (source['_description']) { this._description = new fhir.FhirElement(source._description!); }
    if (source['legalStatusOfSupply']) { this.legalStatusOfSupply = new fhir.CodeableConcept(source.legalStatusOfSupply!); }
    if (source['marketingStatus']) { this.marketingStatus = source.marketingStatus.map((x) => new fhir.MarketingStatus(x)); }
    if (source['marketingAuthorization']) { this.marketingAuthorization = new fhir.Reference(source.marketingAuthorization!); }
    if (source['manufacturer']) { this.manufacturer = source.manufacturer.map((x) => new fhir.Reference(x)); }
    if (source['batchIdentifier']) { this.batchIdentifier = source.batchIdentifier.map((x) => new fhir.MedicinalProductPackagedBatchIdentifier(x)); }
    if (source['packageItem']) { this.packageItem = source.packageItem.map((x) => new fhir.MedicinalProductPackagedPackageItem(x)); }
    else { this.packageItem = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():[string,string][] {
    var results:[string,string][] = super.doModelValidation();
    if (!this["resourceType"]) { results.push(["resourceType",'Missing required element: MedicinalProductPackaged.resourceType']); }
    if (this["identifier"]) { this.identifier.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["subject"]) { this.subject.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["_description"]) { results.push(...this._description.doModelValidation()); }
    if (this["legalStatusOfSupply"]) { results.push(...this.legalStatusOfSupply.doModelValidation()); }
    if (this["marketingStatus"]) { this.marketingStatus.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["marketingAuthorization"]) { results.push(...this.marketingAuthorization.doModelValidation()); }
    if (this["manufacturer"]) { this.manufacturer.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (this["batchIdentifier"]) { this.batchIdentifier.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if ((!this["packageItem"]) || (this["packageItem"].length === 0)) { results.push(["packageItem",'Missing required element: MedicinalProductPackaged.packageItem']); }
    if (this["packageItem"]) { this.packageItem.forEach((x) => { results.push(...x.doModelValidation()); }) }
    return results;
  }
}
