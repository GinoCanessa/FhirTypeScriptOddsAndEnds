// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Batch numbering.
 */
export type IMedicinalProductPackagedBatchIdentifier = fhir.IBackboneElement & {
  /**
   * A number appearing on the immediate packaging (and not the outer packaging).
   */
  immediatePackaging?: fhir.IIdentifier|undefined;
  /**
   * A number appearing on the outer packaging of a specific batch.
   */
  outerPackaging: fhir.IIdentifier|null;
}
/**
 * A packaging item, as a contained for medicine, possibly with other packaging items within.
 */
export type IMedicinalProductPackagedPackageItem = fhir.IBackboneElement & {
  /**
   * A possible alternate material for the packaging.
   */
  alternateMaterial?: fhir.ICodeableConcept[]|undefined;
  /**
   * A device accompanying a medicinal product.
   */
  device?: fhir.IReference[]|undefined;
  /**
   * Including possibly Data Carrier Identifier.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The manufactured item as contained in the packaged medicinal product.
   */
  manufacturedItem?: fhir.IReference[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  manufacturer?: fhir.IReference[]|undefined;
  /**
   * Material type of the package item.
   */
  material?: fhir.ICodeableConcept[]|undefined;
  /**
   * Other codeable characteristics.
   */
  otherCharacteristics?: fhir.ICodeableConcept[]|undefined;
  /**
   * Allows containers within containers.
   */
  packageItem?: fhir.IMedicinalProductPackagedPackageItem[]|undefined;
  /**
   * Dimensions, color etc.
   */
  physicalCharacteristics?: fhir.IProdCharacteristic|undefined;
  /**
   * The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1.
   */
  quantity: fhir.IQuantity|null;
  /**
   * Shelf Life and storage information.
   */
  shelfLifeStorage?: fhir.IProductShelfLife[]|undefined;
  /**
   * The physical type of the container of the medicine.
   */
  type: fhir.ICodeableConcept|null;
}
/**
 * A medicinal product in a container or package.
 */
export type IMedicinalProductPackaged = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "MedicinalProductPackaged";
  /**
   * Batch numbering.
   */
  batchIdentifier?: fhir.IMedicinalProductPackagedBatchIdentifier[]|undefined;
  /**
   * Textual description.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * Unique identifier.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The legal status of supply of the medicinal product as classified by the regulator.
   */
  legalStatusOfSupply?: fhir.ICodeableConcept|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  manufacturer?: fhir.IReference[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  marketingAuthorization?: fhir.IReference|undefined;
  /**
   * Marketing information.
   */
  marketingStatus?: fhir.IMarketingStatus[]|undefined;
  /**
   * A packaging item, as a contained for medicine, possibly with other packaging items within.
   */
  packageItem: fhir.IMedicinalProductPackagedPackageItem[]|null;
  /**
   * The product with this is a pack for.
   */
  subject?: fhir.IReference[]|undefined;
}
/**
 * Batch numbering.
 */
export class MedicinalProductPackagedBatchIdentifier extends fhir.BackboneElement implements fhir.IMedicinalProductPackagedBatchIdentifier {
  /**
   * A number appearing on the immediate packaging (and not the outer packaging).
   */
  public immediatePackaging?: fhir.Identifier|undefined;
  /**
   * A number appearing on the outer packaging of a specific batch.
   */
  public outerPackaging: fhir.Identifier|null;
  /**
   * Default constructor for MedicinalProductPackagedBatchIdentifier - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IMedicinalProductPackagedBatchIdentifier> = {}) {
    super(source);
    if (source["immediatePackaging"]) { this.immediatePackaging = new fhir.Identifier(source.immediatePackaging!); }
    this.outerPackaging = null;
    if (source["outerPackaging"]) { this.outerPackaging = new fhir.Identifier(source.outerPackaging!); }
    if (this.outerPackaging === undefined) { this.outerPackaging = null }
  }
  /**
   * Check if the current MedicinalProductPackagedBatchIdentifier contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["outerPackaging"] === undefined) { missingElements.push("outerPackaging"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MedicinalProductPackagedBatchIdentifier from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IMedicinalProductPackagedBatchIdentifier):MedicinalProductPackagedBatchIdentifier {
    var dest:MedicinalProductPackagedBatchIdentifier = new MedicinalProductPackagedBatchIdentifier(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `MedicinalProductPackagedBatchIdentifier is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A packaging item, as a contained for medicine, possibly with other packaging items within.
 */
export class MedicinalProductPackagedPackageItem extends fhir.BackboneElement implements fhir.IMedicinalProductPackagedPackageItem {
  /**
   * A possible alternate material for the packaging.
   */
  public alternateMaterial?: fhir.CodeableConcept[]|undefined;
  /**
   * A device accompanying a medicinal product.
   */
  public device?: fhir.Reference[]|undefined;
  /**
   * Including possibly Data Carrier Identifier.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The manufactured item as contained in the packaged medicinal product.
   */
  public manufacturedItem?: fhir.Reference[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  public manufacturer?: fhir.Reference[]|undefined;
  /**
   * Material type of the package item.
   */
  public material?: fhir.CodeableConcept[]|undefined;
  /**
   * Other codeable characteristics.
   */
  public otherCharacteristics?: fhir.CodeableConcept[]|undefined;
  /**
   * Allows containers within containers.
   */
  public packageItem?: fhir.MedicinalProductPackagedPackageItem[]|undefined;
  /**
   * Dimensions, color etc.
   */
  public physicalCharacteristics?: fhir.ProdCharacteristic|undefined;
  /**
   * The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1.
   */
  public quantity: fhir.Quantity|null;
  /**
   * Shelf Life and storage information.
   */
  public shelfLifeStorage?: fhir.ProductShelfLife[]|undefined;
  /**
   * The physical type of the container of the medicine.
   */
  public type: fhir.CodeableConcept|null;
  /**
   * Default constructor for MedicinalProductPackagedPackageItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IMedicinalProductPackagedPackageItem> = {}) {
    super(source);
    if (source["alternateMaterial"]) { this.alternateMaterial = source.alternateMaterial.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["device"]) { this.device = source.device.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["manufacturedItem"]) { this.manufacturedItem = source.manufacturedItem.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["manufacturer"]) { this.manufacturer = source.manufacturer.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["material"]) { this.material = source.material.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["otherCharacteristics"]) { this.otherCharacteristics = source.otherCharacteristics.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["packageItem"]) { this.packageItem = source.packageItem.map((x:Partial<fhir.IMedicinalProductPackagedPackageItem>) => new fhir.MedicinalProductPackagedPackageItem(x)); }
    if (source["physicalCharacteristics"]) { this.physicalCharacteristics = new fhir.ProdCharacteristic(source.physicalCharacteristics!); }
    this.quantity = null;
    if (source["quantity"]) { this.quantity = new fhir.Quantity(source.quantity!); }
    if (this.quantity === undefined) { this.quantity = null }
    if (source["shelfLifeStorage"]) { this.shelfLifeStorage = source.shelfLifeStorage.map((x:Partial<fhir.IProductShelfLife>) => new fhir.ProductShelfLife(x)); }
    this.type = null;
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
    if (this.type === undefined) { this.type = null }
  }
  /**
   * Check if the current MedicinalProductPackagedPackageItem contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["quantity"] === undefined) { missingElements.push("quantity"); }
    if (this["type"] === undefined) { missingElements.push("type"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MedicinalProductPackagedPackageItem from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IMedicinalProductPackagedPackageItem):MedicinalProductPackagedPackageItem {
    var dest:MedicinalProductPackagedPackageItem = new MedicinalProductPackagedPackageItem(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `MedicinalProductPackagedPackageItem is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A medicinal product in a container or package.
 */
export class MedicinalProductPackaged extends fhir.DomainResource implements fhir.IMedicinalProductPackaged {
  /**
   * Resource Type Name
   */
  public override resourceType: "MedicinalProductPackaged";
  /**
   * Batch numbering.
   */
  public batchIdentifier?: fhir.MedicinalProductPackagedBatchIdentifier[]|undefined;
  /**
   * Textual description.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * Unique identifier.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The legal status of supply of the medicinal product as classified by the regulator.
   */
  public legalStatusOfSupply?: fhir.CodeableConcept|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  public manufacturer?: fhir.Reference[]|undefined;
  /**
   * Manufacturer of this Package Item.
   */
  public marketingAuthorization?: fhir.Reference|undefined;
  /**
   * Marketing information.
   */
  public marketingStatus?: fhir.MarketingStatus[]|undefined;
  /**
   * A packaging item, as a contained for medicine, possibly with other packaging items within.
   */
  public packageItem: fhir.MedicinalProductPackagedPackageItem[]|null;
  /**
   * The product with this is a pack for.
   */
  public subject?: fhir.Reference[]|undefined;
  /**
   * Default constructor for MedicinalProductPackaged - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IMedicinalProductPackaged> = {}) {
    super(source);
    this.resourceType = 'MedicinalProductPackaged';
    if (source["batchIdentifier"]) { this.batchIdentifier = source.batchIdentifier.map((x:Partial<fhir.IMedicinalProductPackagedBatchIdentifier>) => new fhir.MedicinalProductPackagedBatchIdentifier(x)); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["legalStatusOfSupply"]) { this.legalStatusOfSupply = new fhir.CodeableConcept(source.legalStatusOfSupply!); }
    if (source["manufacturer"]) { this.manufacturer = source.manufacturer.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["marketingAuthorization"]) { this.marketingAuthorization = new fhir.Reference(source.marketingAuthorization!); }
    if (source["marketingStatus"]) { this.marketingStatus = source.marketingStatus.map((x:Partial<fhir.IMarketingStatus>) => new fhir.MarketingStatus(x)); }
    this.packageItem = null;
    if (source["packageItem"]) { this.packageItem = source.packageItem.map((x:Partial<fhir.IMedicinalProductPackagedPackageItem>) => new fhir.MedicinalProductPackagedPackageItem(x)); }
    if (this.packageItem === undefined) { this.packageItem = null }
    if (source["subject"]) { this.subject = source.subject.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
  }
  /**
   * Check if the current MedicinalProductPackaged contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if ((!this["packageItem"]) || (this["packageItem"].length === 0)) { missingElements.push("packageItem"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MedicinalProductPackaged from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.IMedicinalProductPackaged):MedicinalProductPackaged {
    var dest:MedicinalProductPackaged = new MedicinalProductPackaged(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `MedicinalProductPackaged is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
