// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * A container for slots of time that may be available for booking appointments.
 */
export type ISchedule = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "Schedule";
  /**
   * This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   */
  active?: boolean|undefined;
  _active?: fhir.IFhirElement|undefined;
  /**
   * The capacity to support multiple referenced resource types should be used in cases where the specific resources themselves cannot be scheduled without the other, and thus only make sense to the system exposing them as a group. Common examples of this are where the combination of a practitioner and a room (Location) are always required by a system.
   */
  actor: fhir.IReference[]|null;
  /**
   * Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
   */
  comment?: string|undefined;
  _comment?: fhir.IFhirElement|undefined;
  /**
   * External Ids for this item.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
   */
  planningHorizon?: fhir.IPeriod|undefined;
  /**
   * A broad categorization of the service that is to be performed during this appointment.
   */
  serviceCategory?: fhir.ICodeableConcept[]|undefined;
  /**
   * The specific service that is to be performed during this appointment.
   */
  serviceType?: fhir.ICodeableConcept[]|undefined;
  /**
   * The specialty of a practitioner that would be required to perform the service requested in this appointment.
   */
  specialty?: fhir.ICodeableConcept[]|undefined;
}
/**
 * A container for slots of time that may be available for booking appointments.
 */
export class Schedule extends fhir.DomainResource implements fhir.ISchedule {
  /**
   * Resource Type Name
   */
  public override resourceType: "Schedule";
  /**
   * This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   */
  public active?: boolean|undefined;
  public _active?: fhir.FhirElement|undefined;
  /**
   * The capacity to support multiple referenced resource types should be used in cases where the specific resources themselves cannot be scheduled without the other, and thus only make sense to the system exposing them as a group. Common examples of this are where the combination of a practitioner and a room (Location) are always required by a system.
   */
  public actor: fhir.Reference[]|null;
  /**
   * Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
   */
  public comment?: string|undefined;
  public _comment?: fhir.FhirElement|undefined;
  /**
   * External Ids for this item.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
   */
  public planningHorizon?: fhir.Period|undefined;
  /**
   * A broad categorization of the service that is to be performed during this appointment.
   */
  public serviceCategory?: fhir.CodeableConcept[]|undefined;
  /**
   * The specific service that is to be performed during this appointment.
   */
  public serviceType?: fhir.CodeableConcept[]|undefined;
  /**
   * The specialty of a practitioner that would be required to perform the service requested in this appointment.
   */
  public specialty?: fhir.CodeableConcept[]|undefined;
  /**
   * Default constructor for Schedule - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISchedule> = {}) {
    super(source);
    this.resourceType = 'Schedule';
    if (source["active"]) { this.active = source.active; }
    if (source["_active"]) { this._active = new fhir.FhirElement(source._active!); }
    this.actor = null;
    if (source["actor"]) { this.actor = source.actor.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (this.actor === undefined) { this.actor = null }
    if (source["comment"]) { this.comment = source.comment; }
    if (source["_comment"]) { this._comment = new fhir.FhirElement(source._comment!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["planningHorizon"]) { this.planningHorizon = new fhir.Period(source.planningHorizon!); }
    if (source["serviceCategory"]) { this.serviceCategory = source.serviceCategory.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["serviceType"]) { this.serviceType = source.serviceType.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["specialty"]) { this.specialty = source.specialty.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
  }
  /**
   * Check if the current Schedule contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if ((!this["actor"]) || (this["actor"].length === 0)) { missingElements.push("actor"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Schedule from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ISchedule):Schedule {
    var dest:Schedule = new Schedule(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `Schedule is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
