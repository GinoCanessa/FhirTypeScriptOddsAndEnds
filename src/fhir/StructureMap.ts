// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
 */
export type IStructureMapStructure = fhir.IBackboneElement & {
  /**
   * This is needed if both types have the same name (e.g. version conversion).
   */
  alias?: string|undefined;
  _alias?: fhir.IFhirElement|undefined;
  /**
   * Documentation that describes how the structure is used in the mapping.
   */
  documentation?: string|undefined;
  _documentation?: fhir.IFhirElement|undefined;
  /**
   * How the referenced structure is used in this mapping.
   */
  mode: StructureMapStructureModeEnum|null;
  _mode?: fhir.IFhirElement|undefined;
  /**
   * The canonical reference to the structure.
   */
  url: string|null;
  _url?: fhir.IFhirElement|undefined;
}
/**
 * If no inputs are named, then the entry mappings are type based.
 */
export type IStructureMapGroupInput = fhir.IBackboneElement & {
  /**
   * Documentation for this instance of data.
   */
  documentation?: string|undefined;
  _documentation?: fhir.IFhirElement|undefined;
  /**
   * Mode for this instance of data.
   */
  mode: StructureMapGroupInputModeEnum|null;
  _mode?: fhir.IFhirElement|undefined;
  /**
   * Name for this instance of data.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Type for this instance of data.
   */
  type?: string|undefined;
  _type?: fhir.IFhirElement|undefined;
}
/**
 * Source inputs to the mapping.
 */
export type IStructureMapGroupRuleSource = fhir.IBackboneElement & {
  /**
   * FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
   */
  check?: string|undefined;
  _check?: fhir.IFhirElement|undefined;
  /**
   * FHIRPath expression  - must be true or the rule does not apply.
   */
  condition?: string|undefined;
  _condition?: fhir.IFhirElement|undefined;
  /**
   * Type or variable this rule applies to.
   */
  context: string|null;
  _context?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueBase64Binary?: string|undefined;
  _defaultValueBase64Binary?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueBoolean?: boolean|undefined;
  _defaultValueBoolean?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCanonical?: string|undefined;
  _defaultValueCanonical?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCode?: string|undefined;
  _defaultValueCode?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDate?: string|undefined;
  _defaultValueDate?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDateTime?: string|undefined;
  _defaultValueDateTime?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDecimal?: number|undefined;
  _defaultValueDecimal?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueId?: string|undefined;
  _defaultValueId?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueInstant?: string|undefined;
  _defaultValueInstant?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueInteger?: number|undefined;
  _defaultValueInteger?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueMarkdown?: string|undefined;
  _defaultValueMarkdown?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueOid?: string|undefined;
  _defaultValueOid?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValuePositiveInt?: number|undefined;
  _defaultValuePositiveInt?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueString?: string|undefined;
  _defaultValueString?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueTime?: string|undefined;
  _defaultValueTime?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUnsignedInt?: number|undefined;
  _defaultValueUnsignedInt?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUri?: string|undefined;
  _defaultValueUri?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUrl?: string|undefined;
  _defaultValueUrl?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUuid?: string|undefined;
  _defaultValueUuid?: fhir.IFhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAddress?: fhir.IAddress|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAge?: fhir.IAge|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAnnotation?: fhir.IAnnotation|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAttachment?: fhir.IAttachment|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCoding?: fhir.ICoding|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueContactPoint?: fhir.IContactPoint|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCount?: fhir.ICount|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDistance?: fhir.IDistance|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDuration?: fhir.IDuration|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueHumanName?: fhir.IHumanName|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueIdentifier?: fhir.IIdentifier|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueMoney?: fhir.IMoney|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValuePeriod?: fhir.IPeriod|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueQuantity?: fhir.IQuantity|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueRange?: fhir.IRange|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueRatio?: fhir.IRatio|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueReference?: fhir.IReference|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueSampledData?: fhir.ISampledData|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueSignature?: fhir.ISignature|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueTiming?: fhir.ITiming|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueContactDetail?: fhir.IContactDetail|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueContributor?: fhir.IContributor|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDataRequirement?: fhir.IDataRequirement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueExpression?: fhir.IExpression|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueParameterDefinition?: fhir.IParameterDefinition|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueRelatedArtifact?: fhir.IRelatedArtifact|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueTriggerDefinition?: fhir.ITriggerDefinition|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUsageContext?: fhir.IUsageContext|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDosage?: fhir.IDosage|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueMeta?: fhir.IMeta|undefined;
  /**
   * Optional field for this source.
   */
  element?: string|undefined;
  _element?: fhir.IFhirElement|undefined;
  /**
   * How to handle the list mode for this element.
   */
  listMode?: StructureMapGroupRuleSourceListModeEnum|undefined;
  _listMode?: fhir.IFhirElement|undefined;
  /**
   * This is typically used for recording that something Is not transformed to the target for some reason.
   */
  logMessage?: string|undefined;
  _logMessage?: fhir.IFhirElement|undefined;
  /**
   * Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
   */
  max?: string|undefined;
  _max?: fhir.IFhirElement|undefined;
  /**
   * Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
   */
  min?: number|undefined;
  _min?: fhir.IFhirElement|undefined;
  /**
   * Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
   */
  type?: string|undefined;
  _type?: fhir.IFhirElement|undefined;
  /**
   * Named context for field, if a field is specified.
   */
  variable?: string|undefined;
  _variable?: fhir.IFhirElement|undefined;
}
/**
 * Parameters to the transform.
 */
export type IStructureMapGroupRuleTargetParameter = fhir.IBackboneElement & {
  /**
   * Parameter value - variable or literal.
   */
  valueId?: string|undefined;
  _valueId?: fhir.IFhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  valueString?: string|undefined;
  _valueString?: fhir.IFhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  valueBoolean?: boolean|undefined;
  _valueBoolean?: fhir.IFhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  valueInteger?: number|undefined;
  _valueInteger?: fhir.IFhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  valueDecimal?: number|undefined;
  _valueDecimal?: fhir.IFhirElement|undefined;
}
/**
 * Content to create because of this mapping rule.
 */
export type IStructureMapGroupRuleTarget = fhir.IBackboneElement & {
  /**
   * Type or variable this rule applies to.
   */
  context?: string|undefined;
  _context?: fhir.IFhirElement|undefined;
  /**
   * How to interpret the context.
   */
  contextType?: StructureMapGroupRuleTargetContextTypeEnum|undefined;
  _contextType?: fhir.IFhirElement|undefined;
  /**
   * Field to create in the context.
   */
  element?: string|undefined;
  _element?: fhir.IFhirElement|undefined;
  /**
   * If field is a list, how to manage the list.
   */
  listMode?: StructureMapGroupRuleTargetListModeEnum[]|undefined;
  _listMode?: fhir.IFhirElement[]|undefined;
  /**
   * Internal rule reference for shared list items.
   */
  listRuleId?: string|undefined;
  _listRuleId?: fhir.IFhirElement|undefined;
  /**
   * Parameters to the transform.
   */
  parameter?: fhir.IStructureMapGroupRuleTargetParameter[]|undefined;
  /**
   * How the data is copied / created.
   */
  transform?: StructureMapGroupRuleTargetTransformEnum|undefined;
  _transform?: fhir.IFhirElement|undefined;
  /**
   * Named context for field, if desired, and a field is specified.
   */
  variable?: string|undefined;
  _variable?: fhir.IFhirElement|undefined;
}
/**
 * Which other rules to apply in the context of this rule.
 */
export type IStructureMapGroupRuleDependent = fhir.IBackboneElement & {
  /**
   * Name of a rule or group to apply.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Variable to pass to the rule or group.
   */
  variable: string[]|null;
  _variable?: fhir.IFhirElement[]|undefined;
}
/**
 * Transform Rule from source to target.
 */
export type IStructureMapGroupRule = fhir.IBackboneElement & {
  /**
   * Which other rules to apply in the context of this rule.
   */
  dependent?: fhir.IStructureMapGroupRuleDependent[]|undefined;
  /**
   * Documentation for this instance of data.
   */
  documentation?: string|undefined;
  _documentation?: fhir.IFhirElement|undefined;
  /**
   * Name of the rule for internal references.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Rules contained in this rule.
   */
  rule?: fhir.IStructureMapGroupRule[]|undefined;
  /**
   * Source inputs to the mapping.
   */
  source: fhir.IStructureMapGroupRuleSource[]|null;
  /**
   * Content to create because of this mapping rule.
   */
  target?: fhir.IStructureMapGroupRuleTarget[]|undefined;
}
/**
 * Organizes the mapping into manageable chunks for human review/ease of maintenance.
 */
export type IStructureMapGroup = fhir.IBackboneElement & {
  /**
   * Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
   */
  documentation?: string|undefined;
  _documentation?: fhir.IFhirElement|undefined;
  /**
   * Another group that this group adds rules to.
   */
  extends?: string|undefined;
  _extends?: fhir.IFhirElement|undefined;
  /**
   * If no inputs are named, then the entry mappings are type based.
   */
  input: fhir.IStructureMapGroupInput[]|null;
  /**
   * A unique name for the group for the convenience of human readers.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Transform Rule from source to target.
   */
  rule: fhir.IStructureMapGroupRule[]|null;
  /**
   * Not applicable if the underlying model is untyped. There can only be one default mapping for any particular type combination.
   */
  typeMode: StructureMapGroupTypeModeEnum|null;
  _typeMode?: fhir.IFhirElement|undefined;
}
/**
 * A Map of relationships between 2 structures that can be used to transform data.
 */
export type IStructureMap = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "StructureMap";
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  contact?: fhir.IContactDetail[]|undefined;
  /**
   * A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
   */
  copyright?: string|undefined;
  _copyright?: fhir.IFhirElement|undefined;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the structure map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  date?: string|undefined;
  _date?: fhir.IFhirElement|undefined;
  /**
   * This description can be used to capture details such as why the structure map was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the structure map as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the structure map is presumed to be the predominant language in the place the structure map was created).
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * Allows filtering of structure maps that are appropriate for use versus not.
   */
  experimental?: boolean|undefined;
  _experimental?: fhir.IFhirElement|undefined;
  /**
   * Organizes the mapping into manageable chunks for human review/ease of maintenance.
   */
  group: fhir.IStructureMapGroup[]|null;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this structure map outside of FHIR, where it is not possible to use the logical URI.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * Other maps used by this map (canonical URLs).
   */
  import?: string[]|undefined;
  _import?: fhir.IFhirElement[]|undefined;
  /**
   * It may be possible for the structure map to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  jurisdiction?: fhir.ICodeableConcept[]|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the structure map is the organization or individual primarily responsible for the maintenance and upkeep of the structure map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the structure map. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: string|undefined;
  _publisher?: fhir.IFhirElement|undefined;
  /**
   * This element does not describe the usage of the structure map. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this structure map.
   */
  purpose?: string|undefined;
  _purpose?: fhir.IFhirElement|undefined;
  /**
   * Allows filtering of structure maps that are appropriate for use versus not.
   */
  status: StructureMapStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
  /**
   * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
   */
  structure?: fhir.IStructureMapStructure[]|undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  title?: string|undefined;
  _title?: fhir.IFhirElement|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  url: string|null;
  _url?: fhir.IFhirElement|undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: fhir.IUsageContext[]|undefined;
  /**
   * There may be different structure map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the structure map with the format [url]|[version].
   */
  version?: string|undefined;
  _version?: fhir.IFhirElement|undefined;
}
/**
 * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
 */
export class StructureMapStructure extends fhir.BackboneElement implements fhir.IStructureMapStructure {
  /**
   * This is needed if both types have the same name (e.g. version conversion).
   */
  public alias?: string|undefined;
  public _alias?: fhir.FhirElement|undefined;
  /**
   * Documentation that describes how the structure is used in the mapping.
   */
  public documentation?: string|undefined;
  public _documentation?: fhir.FhirElement|undefined;
  /**
   * How the referenced structure is used in this mapping.
   */
  public mode: StructureMapStructureModeEnum|null;
  public _mode?: fhir.FhirElement|undefined;
  /**
   * The canonical reference to the structure.
   */
  public url: string|null;
  public _url?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMapStructure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapStructure> = {}) {
    super(source);
    if (source["alias"]) { this.alias = source.alias; }
    if (source["_alias"]) { this._alias = new fhir.FhirElement(source._alias!); }
    if (source["documentation"]) { this.documentation = source.documentation; }
    if (source["_documentation"]) { this._documentation = new fhir.FhirElement(source._documentation!); }
    this.mode = null;
    if (source["mode"]) { this.mode = source.mode; }
    if (this.mode === undefined) { this.mode = null }
    if (source["_mode"]) { this._mode = new fhir.FhirElement(source._mode!); }
    this.url = null;
    if (source["url"]) { this.url = source.url; }
    if (this.url === undefined) { this.url = null }
    if (source["_url"]) { this._url = new fhir.FhirElement(source._url!); }
  }
  /**
   * Check if the current StructureMapStructure contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["mode"] === undefined) { missingElements.push("mode"); }
    if (this["url"] === undefined) { missingElements.push("url"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapStructure from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapStructure):StructureMapStructure {
    var dest:StructureMapStructure = new StructureMapStructure(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapStructure is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * If no inputs are named, then the entry mappings are type based.
 */
export class StructureMapGroupInput extends fhir.BackboneElement implements fhir.IStructureMapGroupInput {
  /**
   * Documentation for this instance of data.
   */
  public documentation?: string|undefined;
  public _documentation?: fhir.FhirElement|undefined;
  /**
   * Mode for this instance of data.
   */
  public mode: StructureMapGroupInputModeEnum|null;
  public _mode?: fhir.FhirElement|undefined;
  /**
   * Name for this instance of data.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Type for this instance of data.
   */
  public type?: string|undefined;
  public _type?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMapGroupInput - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroupInput> = {}) {
    super(source);
    if (source["documentation"]) { this.documentation = source.documentation; }
    if (source["_documentation"]) { this._documentation = new fhir.FhirElement(source._documentation!); }
    this.mode = null;
    if (source["mode"]) { this.mode = source.mode; }
    if (this.mode === undefined) { this.mode = null }
    if (source["_mode"]) { this._mode = new fhir.FhirElement(source._mode!); }
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["type"]) { this.type = source.type; }
    if (source["_type"]) { this._type = new fhir.FhirElement(source._type!); }
  }
  /**
   * Check if the current StructureMapGroupInput contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["mode"] === undefined) { missingElements.push("mode"); }
    if (this["name"] === undefined) { missingElements.push("name"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroupInput from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroupInput):StructureMapGroupInput {
    var dest:StructureMapGroupInput = new StructureMapGroupInput(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroupInput is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Source inputs to the mapping.
 */
export class StructureMapGroupRuleSource extends fhir.BackboneElement implements fhir.IStructureMapGroupRuleSource {
  /**
   * FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
   */
  public check?: string|undefined;
  public _check?: fhir.FhirElement|undefined;
  /**
   * FHIRPath expression  - must be true or the rule does not apply.
   */
  public condition?: string|undefined;
  public _condition?: fhir.FhirElement|undefined;
  /**
   * Type or variable this rule applies to.
   */
  public context: string|null;
  public _context?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueBase64Binary?: string|undefined;
  public _defaultValueBase64Binary?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueBoolean?: boolean|undefined;
  public _defaultValueBoolean?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueCanonical?: string|undefined;
  public _defaultValueCanonical?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueCode?: string|undefined;
  public _defaultValueCode?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDate?: string|undefined;
  public _defaultValueDate?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDateTime?: string|undefined;
  public _defaultValueDateTime?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDecimal?: number|undefined;
  public _defaultValueDecimal?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueId?: string|undefined;
  public _defaultValueId?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueInstant?: string|undefined;
  public _defaultValueInstant?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueInteger?: number|undefined;
  public _defaultValueInteger?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueMarkdown?: string|undefined;
  public _defaultValueMarkdown?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueOid?: string|undefined;
  public _defaultValueOid?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValuePositiveInt?: number|undefined;
  public _defaultValuePositiveInt?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueString?: string|undefined;
  public _defaultValueString?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueTime?: string|undefined;
  public _defaultValueTime?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueUnsignedInt?: number|undefined;
  public _defaultValueUnsignedInt?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueUri?: string|undefined;
  public _defaultValueUri?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueUrl?: string|undefined;
  public _defaultValueUrl?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueUuid?: string|undefined;
  public _defaultValueUuid?: fhir.FhirElement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueAddress?: fhir.Address|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueAge?: fhir.Age|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueAnnotation?: fhir.Annotation|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueAttachment?: fhir.Attachment|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueCoding?: fhir.Coding|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueContactPoint?: fhir.ContactPoint|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueCount?: fhir.Count|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDistance?: fhir.Distance|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDuration?: fhir.Duration|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueHumanName?: fhir.HumanName|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueIdentifier?: fhir.Identifier|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueMoney?: fhir.Money|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValuePeriod?: fhir.Period|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueQuantity?: fhir.Quantity|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueRange?: fhir.Range|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueRatio?: fhir.Ratio|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueReference?: fhir.Reference|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueSampledData?: fhir.SampledData|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueSignature?: fhir.Signature|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueTiming?: fhir.Timing|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueContactDetail?: fhir.ContactDetail|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueContributor?: fhir.Contributor|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDataRequirement?: fhir.DataRequirement|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueExpression?: fhir.Expression|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueParameterDefinition?: fhir.ParameterDefinition|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueRelatedArtifact?: fhir.RelatedArtifact|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueTriggerDefinition?: fhir.TriggerDefinition|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueUsageContext?: fhir.UsageContext|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueDosage?: fhir.Dosage|undefined;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  public defaultValueMeta?: fhir.Meta|undefined;
  /**
   * Optional field for this source.
   */
  public element?: string|undefined;
  public _element?: fhir.FhirElement|undefined;
  /**
   * How to handle the list mode for this element.
   */
  public listMode?: StructureMapGroupRuleSourceListModeEnum|undefined;
  public _listMode?: fhir.FhirElement|undefined;
  /**
   * This is typically used for recording that something Is not transformed to the target for some reason.
   */
  public logMessage?: string|undefined;
  public _logMessage?: fhir.FhirElement|undefined;
  /**
   * Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
   */
  public max?: string|undefined;
  public _max?: fhir.FhirElement|undefined;
  /**
   * Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
   */
  public min?: number|undefined;
  public _min?: fhir.FhirElement|undefined;
  /**
   * Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
   */
  public type?: string|undefined;
  public _type?: fhir.FhirElement|undefined;
  /**
   * Named context for field, if a field is specified.
   */
  public variable?: string|undefined;
  public _variable?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMapGroupRuleSource - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroupRuleSource> = {}) {
    super(source);
    if (source["check"]) { this.check = source.check; }
    if (source["_check"]) { this._check = new fhir.FhirElement(source._check!); }
    if (source["condition"]) { this.condition = source.condition; }
    if (source["_condition"]) { this._condition = new fhir.FhirElement(source._condition!); }
    this.context = null;
    if (source["context"]) { this.context = source.context; }
    if (this.context === undefined) { this.context = null }
    if (source["_context"]) { this._context = new fhir.FhirElement(source._context!); }
    if (source["defaultValueBase64Binary"]) { this.defaultValueBase64Binary = source.defaultValueBase64Binary; }
    if (source["_defaultValueBase64Binary"]) { this._defaultValueBase64Binary = new fhir.FhirElement(source._defaultValueBase64Binary!); }
    if (source["defaultValueBoolean"]) { this.defaultValueBoolean = source.defaultValueBoolean; }
    if (source["_defaultValueBoolean"]) { this._defaultValueBoolean = new fhir.FhirElement(source._defaultValueBoolean!); }
    if (source["defaultValueCanonical"]) { this.defaultValueCanonical = source.defaultValueCanonical; }
    if (source["_defaultValueCanonical"]) { this._defaultValueCanonical = new fhir.FhirElement(source._defaultValueCanonical!); }
    if (source["defaultValueCode"]) { this.defaultValueCode = source.defaultValueCode; }
    if (source["_defaultValueCode"]) { this._defaultValueCode = new fhir.FhirElement(source._defaultValueCode!); }
    if (source["defaultValueDate"]) { this.defaultValueDate = source.defaultValueDate; }
    if (source["_defaultValueDate"]) { this._defaultValueDate = new fhir.FhirElement(source._defaultValueDate!); }
    if (source["defaultValueDateTime"]) { this.defaultValueDateTime = source.defaultValueDateTime; }
    if (source["_defaultValueDateTime"]) { this._defaultValueDateTime = new fhir.FhirElement(source._defaultValueDateTime!); }
    if (source["defaultValueDecimal"]) { this.defaultValueDecimal = source.defaultValueDecimal; }
    if (source["_defaultValueDecimal"]) { this._defaultValueDecimal = new fhir.FhirElement(source._defaultValueDecimal!); }
    if (source["defaultValueId"]) { this.defaultValueId = source.defaultValueId; }
    if (source["_defaultValueId"]) { this._defaultValueId = new fhir.FhirElement(source._defaultValueId!); }
    if (source["defaultValueInstant"]) { this.defaultValueInstant = source.defaultValueInstant; }
    if (source["_defaultValueInstant"]) { this._defaultValueInstant = new fhir.FhirElement(source._defaultValueInstant!); }
    if (source["defaultValueInteger"]) { this.defaultValueInteger = source.defaultValueInteger; }
    if (source["_defaultValueInteger"]) { this._defaultValueInteger = new fhir.FhirElement(source._defaultValueInteger!); }
    if (source["defaultValueMarkdown"]) { this.defaultValueMarkdown = source.defaultValueMarkdown; }
    if (source["_defaultValueMarkdown"]) { this._defaultValueMarkdown = new fhir.FhirElement(source._defaultValueMarkdown!); }
    if (source["defaultValueOid"]) { this.defaultValueOid = source.defaultValueOid; }
    if (source["_defaultValueOid"]) { this._defaultValueOid = new fhir.FhirElement(source._defaultValueOid!); }
    if (source["defaultValuePositiveInt"]) { this.defaultValuePositiveInt = source.defaultValuePositiveInt; }
    if (source["_defaultValuePositiveInt"]) { this._defaultValuePositiveInt = new fhir.FhirElement(source._defaultValuePositiveInt!); }
    if (source["defaultValueString"]) { this.defaultValueString = source.defaultValueString; }
    if (source["_defaultValueString"]) { this._defaultValueString = new fhir.FhirElement(source._defaultValueString!); }
    if (source["defaultValueTime"]) { this.defaultValueTime = source.defaultValueTime; }
    if (source["_defaultValueTime"]) { this._defaultValueTime = new fhir.FhirElement(source._defaultValueTime!); }
    if (source["defaultValueUnsignedInt"]) { this.defaultValueUnsignedInt = source.defaultValueUnsignedInt; }
    if (source["_defaultValueUnsignedInt"]) { this._defaultValueUnsignedInt = new fhir.FhirElement(source._defaultValueUnsignedInt!); }
    if (source["defaultValueUri"]) { this.defaultValueUri = source.defaultValueUri; }
    if (source["_defaultValueUri"]) { this._defaultValueUri = new fhir.FhirElement(source._defaultValueUri!); }
    if (source["defaultValueUrl"]) { this.defaultValueUrl = source.defaultValueUrl; }
    if (source["_defaultValueUrl"]) { this._defaultValueUrl = new fhir.FhirElement(source._defaultValueUrl!); }
    if (source["defaultValueUuid"]) { this.defaultValueUuid = source.defaultValueUuid; }
    if (source["_defaultValueUuid"]) { this._defaultValueUuid = new fhir.FhirElement(source._defaultValueUuid!); }
    if (source["defaultValueAddress"]) { this.defaultValueAddress = new fhir.Address(source.defaultValueAddress!); }
    if (source["defaultValueAge"]) { this.defaultValueAge = new fhir.Age(source.defaultValueAge!); }
    if (source["defaultValueAnnotation"]) { this.defaultValueAnnotation = new fhir.Annotation(source.defaultValueAnnotation!); }
    if (source["defaultValueAttachment"]) { this.defaultValueAttachment = new fhir.Attachment(source.defaultValueAttachment!); }
    if (source["defaultValueCodeableConcept"]) { this.defaultValueCodeableConcept = new fhir.CodeableConcept(source.defaultValueCodeableConcept!); }
    if (source["defaultValueCoding"]) { this.defaultValueCoding = new fhir.Coding(source.defaultValueCoding!); }
    if (source["defaultValueContactPoint"]) { this.defaultValueContactPoint = new fhir.ContactPoint(source.defaultValueContactPoint!); }
    if (source["defaultValueCount"]) { this.defaultValueCount = new fhir.Count(source.defaultValueCount!); }
    if (source["defaultValueDistance"]) { this.defaultValueDistance = new fhir.Distance(source.defaultValueDistance!); }
    if (source["defaultValueDuration"]) { this.defaultValueDuration = new fhir.Duration(source.defaultValueDuration!); }
    if (source["defaultValueHumanName"]) { this.defaultValueHumanName = new fhir.HumanName(source.defaultValueHumanName!); }
    if (source["defaultValueIdentifier"]) { this.defaultValueIdentifier = new fhir.Identifier(source.defaultValueIdentifier!); }
    if (source["defaultValueMoney"]) { this.defaultValueMoney = new fhir.Money(source.defaultValueMoney!); }
    if (source["defaultValuePeriod"]) { this.defaultValuePeriod = new fhir.Period(source.defaultValuePeriod!); }
    if (source["defaultValueQuantity"]) { this.defaultValueQuantity = new fhir.Quantity(source.defaultValueQuantity!); }
    if (source["defaultValueRange"]) { this.defaultValueRange = new fhir.Range(source.defaultValueRange!); }
    if (source["defaultValueRatio"]) { this.defaultValueRatio = new fhir.Ratio(source.defaultValueRatio!); }
    if (source["defaultValueReference"]) { this.defaultValueReference = new fhir.Reference(source.defaultValueReference!); }
    if (source["defaultValueSampledData"]) { this.defaultValueSampledData = new fhir.SampledData(source.defaultValueSampledData!); }
    if (source["defaultValueSignature"]) { this.defaultValueSignature = new fhir.Signature(source.defaultValueSignature!); }
    if (source["defaultValueTiming"]) { this.defaultValueTiming = new fhir.Timing(source.defaultValueTiming!); }
    if (source["defaultValueContactDetail"]) { this.defaultValueContactDetail = new fhir.ContactDetail(source.defaultValueContactDetail!); }
    if (source["defaultValueContributor"]) { this.defaultValueContributor = new fhir.Contributor(source.defaultValueContributor!); }
    if (source["defaultValueDataRequirement"]) { this.defaultValueDataRequirement = new fhir.DataRequirement(source.defaultValueDataRequirement!); }
    if (source["defaultValueExpression"]) { this.defaultValueExpression = new fhir.Expression(source.defaultValueExpression!); }
    if (source["defaultValueParameterDefinition"]) { this.defaultValueParameterDefinition = new fhir.ParameterDefinition(source.defaultValueParameterDefinition!); }
    if (source["defaultValueRelatedArtifact"]) { this.defaultValueRelatedArtifact = new fhir.RelatedArtifact(source.defaultValueRelatedArtifact!); }
    if (source["defaultValueTriggerDefinition"]) { this.defaultValueTriggerDefinition = new fhir.TriggerDefinition(source.defaultValueTriggerDefinition!); }
    if (source["defaultValueUsageContext"]) { this.defaultValueUsageContext = new fhir.UsageContext(source.defaultValueUsageContext!); }
    if (source["defaultValueDosage"]) { this.defaultValueDosage = new fhir.Dosage(source.defaultValueDosage!); }
    if (source["defaultValueMeta"]) { this.defaultValueMeta = new fhir.Meta(source.defaultValueMeta!); }
    if (source["element"]) { this.element = source.element; }
    if (source["_element"]) { this._element = new fhir.FhirElement(source._element!); }
    if (source["listMode"]) { this.listMode = source.listMode; }
    if (source["_listMode"]) { this._listMode = new fhir.FhirElement(source._listMode!); }
    if (source["logMessage"]) { this.logMessage = source.logMessage; }
    if (source["_logMessage"]) { this._logMessage = new fhir.FhirElement(source._logMessage!); }
    if (source["max"]) { this.max = source.max; }
    if (source["_max"]) { this._max = new fhir.FhirElement(source._max!); }
    if (source["min"]) { this.min = source.min; }
    if (source["_min"]) { this._min = new fhir.FhirElement(source._min!); }
    if (source["type"]) { this.type = source.type; }
    if (source["_type"]) { this._type = new fhir.FhirElement(source._type!); }
    if (source["variable"]) { this.variable = source.variable; }
    if (source["_variable"]) { this._variable = new fhir.FhirElement(source._variable!); }
  }
  /**
   * Check if the current StructureMapGroupRuleSource contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["context"] === undefined) { missingElements.push("context"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroupRuleSource from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroupRuleSource):StructureMapGroupRuleSource {
    var dest:StructureMapGroupRuleSource = new StructureMapGroupRuleSource(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroupRuleSource is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Parameters to the transform.
 */
export class StructureMapGroupRuleTargetParameter extends fhir.BackboneElement implements fhir.IStructureMapGroupRuleTargetParameter {
  /**
   * Parameter value - variable or literal.
   */
  public valueId?: string|undefined;
  public _valueId?: fhir.FhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  public valueString?: string|undefined;
  public _valueString?: fhir.FhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  public valueBoolean?: boolean|undefined;
  public _valueBoolean?: fhir.FhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  public valueInteger?: number|undefined;
  public _valueInteger?: fhir.FhirElement|undefined;
  /**
   * Parameter value - variable or literal.
   */
  public valueDecimal?: number|undefined;
  public _valueDecimal?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMapGroupRuleTargetParameter - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroupRuleTargetParameter> = {}) {
    super(source);
    if (source["valueId"]) { this.valueId = source.valueId; }
    if (source["_valueId"]) { this._valueId = new fhir.FhirElement(source._valueId!); }
    if (source["valueString"]) { this.valueString = source.valueString; }
    if (source["_valueString"]) { this._valueString = new fhir.FhirElement(source._valueString!); }
    if (source["valueBoolean"]) { this.valueBoolean = source.valueBoolean; }
    if (source["_valueBoolean"]) { this._valueBoolean = new fhir.FhirElement(source._valueBoolean!); }
    if (source["valueInteger"]) { this.valueInteger = source.valueInteger; }
    if (source["_valueInteger"]) { this._valueInteger = new fhir.FhirElement(source._valueInteger!); }
    if (source["valueDecimal"]) { this.valueDecimal = source.valueDecimal; }
    if (source["_valueDecimal"]) { this._valueDecimal = new fhir.FhirElement(source._valueDecimal!); }
  }
  /**
   * Check if the current StructureMapGroupRuleTargetParameter contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroupRuleTargetParameter from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroupRuleTargetParameter):StructureMapGroupRuleTargetParameter {
    var dest:StructureMapGroupRuleTargetParameter = new StructureMapGroupRuleTargetParameter(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroupRuleTargetParameter is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Content to create because of this mapping rule.
 */
export class StructureMapGroupRuleTarget extends fhir.BackboneElement implements fhir.IStructureMapGroupRuleTarget {
  /**
   * Type or variable this rule applies to.
   */
  public context?: string|undefined;
  public _context?: fhir.FhirElement|undefined;
  /**
   * How to interpret the context.
   */
  public contextType?: StructureMapGroupRuleTargetContextTypeEnum|undefined;
  public _contextType?: fhir.FhirElement|undefined;
  /**
   * Field to create in the context.
   */
  public element?: string|undefined;
  public _element?: fhir.FhirElement|undefined;
  /**
   * If field is a list, how to manage the list.
   */
  public listMode?: StructureMapGroupRuleTargetListModeEnum[]|undefined;
  public _listMode?: fhir.FhirElement[]|undefined;
  /**
   * Internal rule reference for shared list items.
   */
  public listRuleId?: string|undefined;
  public _listRuleId?: fhir.FhirElement|undefined;
  /**
   * Parameters to the transform.
   */
  public parameter?: fhir.StructureMapGroupRuleTargetParameter[]|undefined;
  /**
   * How the data is copied / created.
   */
  public transform?: StructureMapGroupRuleTargetTransformEnum|undefined;
  public _transform?: fhir.FhirElement|undefined;
  /**
   * Named context for field, if desired, and a field is specified.
   */
  public variable?: string|undefined;
  public _variable?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMapGroupRuleTarget - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroupRuleTarget> = {}) {
    super(source);
    if (source["context"]) { this.context = source.context; }
    if (source["_context"]) { this._context = new fhir.FhirElement(source._context!); }
    if (source["contextType"]) { this.contextType = source.contextType; }
    if (source["_contextType"]) { this._contextType = new fhir.FhirElement(source._contextType!); }
    if (source["element"]) { this.element = source.element; }
    if (source["_element"]) { this._element = new fhir.FhirElement(source._element!); }
    if (source["listMode"]) { this.listMode = source.listMode.map((x) => (x)); }
    if (source["_listMode"]) { this._listMode = source._listMode.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["listRuleId"]) { this.listRuleId = source.listRuleId; }
    if (source["_listRuleId"]) { this._listRuleId = new fhir.FhirElement(source._listRuleId!); }
    if (source["parameter"]) { this.parameter = source.parameter.map((x:Partial<fhir.IStructureMapGroupRuleTargetParameter>) => new fhir.StructureMapGroupRuleTargetParameter(x)); }
    if (source["transform"]) { this.transform = source.transform; }
    if (source["_transform"]) { this._transform = new fhir.FhirElement(source._transform!); }
    if (source["variable"]) { this.variable = source.variable; }
    if (source["_variable"]) { this._variable = new fhir.FhirElement(source._variable!); }
  }
  /**
   * Check if the current StructureMapGroupRuleTarget contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroupRuleTarget from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroupRuleTarget):StructureMapGroupRuleTarget {
    var dest:StructureMapGroupRuleTarget = new StructureMapGroupRuleTarget(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroupRuleTarget is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Which other rules to apply in the context of this rule.
 */
export class StructureMapGroupRuleDependent extends fhir.BackboneElement implements fhir.IStructureMapGroupRuleDependent {
  /**
   * Name of a rule or group to apply.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Variable to pass to the rule or group.
   */
  public variable: string[]|null;
  public _variable?: fhir.FhirElement[]|undefined;
  /**
   * Default constructor for StructureMapGroupRuleDependent - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroupRuleDependent> = {}) {
    super(source);
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    this.variable = null;
    if (source["variable"]) { this.variable = source.variable.map((x) => (x)); }
    if (this.variable === undefined) { this.variable = null }
    if (source["_variable"]) { this._variable = source._variable.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
  }
  /**
   * Check if the current StructureMapGroupRuleDependent contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["name"] === undefined) { missingElements.push("name"); }
    if ((!this["variable"]) || (this["variable"].length === 0)) { missingElements.push("variable"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroupRuleDependent from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroupRuleDependent):StructureMapGroupRuleDependent {
    var dest:StructureMapGroupRuleDependent = new StructureMapGroupRuleDependent(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroupRuleDependent is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Transform Rule from source to target.
 */
export class StructureMapGroupRule extends fhir.BackboneElement implements fhir.IStructureMapGroupRule {
  /**
   * Which other rules to apply in the context of this rule.
   */
  public dependent?: fhir.StructureMapGroupRuleDependent[]|undefined;
  /**
   * Documentation for this instance of data.
   */
  public documentation?: string|undefined;
  public _documentation?: fhir.FhirElement|undefined;
  /**
   * Name of the rule for internal references.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Rules contained in this rule.
   */
  public rule?: fhir.StructureMapGroupRule[]|undefined;
  /**
   * Source inputs to the mapping.
   */
  public source: fhir.StructureMapGroupRuleSource[]|null;
  /**
   * Content to create because of this mapping rule.
   */
  public target?: fhir.StructureMapGroupRuleTarget[]|undefined;
  /**
   * Default constructor for StructureMapGroupRule - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroupRule> = {}) {
    super(source);
    if (source["dependent"]) { this.dependent = source.dependent.map((x:Partial<fhir.IStructureMapGroupRuleDependent>) => new fhir.StructureMapGroupRuleDependent(x)); }
    if (source["documentation"]) { this.documentation = source.documentation; }
    if (source["_documentation"]) { this._documentation = new fhir.FhirElement(source._documentation!); }
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["rule"]) { this.rule = source.rule.map((x:Partial<fhir.IStructureMapGroupRule>) => new fhir.StructureMapGroupRule(x)); }
    this.source = null;
    if (source["source"]) { this.source = source.source.map((x:Partial<fhir.IStructureMapGroupRuleSource>) => new fhir.StructureMapGroupRuleSource(x)); }
    if (this.source === undefined) { this.source = null }
    if (source["target"]) { this.target = source.target.map((x:Partial<fhir.IStructureMapGroupRuleTarget>) => new fhir.StructureMapGroupRuleTarget(x)); }
  }
  /**
   * Check if the current StructureMapGroupRule contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["name"] === undefined) { missingElements.push("name"); }
    if ((!this["source"]) || (this["source"].length === 0)) { missingElements.push("source"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroupRule from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroupRule):StructureMapGroupRule {
    var dest:StructureMapGroupRule = new StructureMapGroupRule(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroupRule is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Organizes the mapping into manageable chunks for human review/ease of maintenance.
 */
export class StructureMapGroup extends fhir.BackboneElement implements fhir.IStructureMapGroup {
  /**
   * Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
   */
  public documentation?: string|undefined;
  public _documentation?: fhir.FhirElement|undefined;
  /**
   * Another group that this group adds rules to.
   */
  public extends?: string|undefined;
  public _extends?: fhir.FhirElement|undefined;
  /**
   * If no inputs are named, then the entry mappings are type based.
   */
  public input: fhir.StructureMapGroupInput[]|null;
  /**
   * A unique name for the group for the convenience of human readers.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Transform Rule from source to target.
   */
  public rule: fhir.StructureMapGroupRule[]|null;
  /**
   * Not applicable if the underlying model is untyped. There can only be one default mapping for any particular type combination.
   */
  public typeMode: StructureMapGroupTypeModeEnum|null;
  public _typeMode?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMapGroup - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMapGroup> = {}) {
    super(source);
    if (source["documentation"]) { this.documentation = source.documentation; }
    if (source["_documentation"]) { this._documentation = new fhir.FhirElement(source._documentation!); }
    if (source["extends"]) { this.extends = source.extends; }
    if (source["_extends"]) { this._extends = new fhir.FhirElement(source._extends!); }
    this.input = null;
    if (source["input"]) { this.input = source.input.map((x:Partial<fhir.IStructureMapGroupInput>) => new fhir.StructureMapGroupInput(x)); }
    if (this.input === undefined) { this.input = null }
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    this.rule = null;
    if (source["rule"]) { this.rule = source.rule.map((x:Partial<fhir.IStructureMapGroupRule>) => new fhir.StructureMapGroupRule(x)); }
    if (this.rule === undefined) { this.rule = null }
    this.typeMode = null;
    if (source["typeMode"]) { this.typeMode = source.typeMode; }
    if (this.typeMode === undefined) { this.typeMode = null }
    if (source["_typeMode"]) { this._typeMode = new fhir.FhirElement(source._typeMode!); }
  }
  /**
   * Check if the current StructureMapGroup contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if ((!this["input"]) || (this["input"].length === 0)) { missingElements.push("input"); }
    if (this["name"] === undefined) { missingElements.push("name"); }
    if ((!this["rule"]) || (this["rule"].length === 0)) { missingElements.push("rule"); }
    if (this["typeMode"] === undefined) { missingElements.push("typeMode"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMapGroup from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMapGroup):StructureMapGroup {
    var dest:StructureMapGroup = new StructureMapGroup(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMapGroup is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A Map of relationships between 2 structures that can be used to transform data.
 */
export class StructureMap extends fhir.DomainResource implements fhir.IStructureMap {
  /**
   * Resource Type Name
   */
  public override resourceType: "StructureMap";
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  public contact?: fhir.ContactDetail[]|undefined;
  /**
   * A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
   */
  public copyright?: string|undefined;
  public _copyright?: fhir.FhirElement|undefined;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the structure map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  public date?: string|undefined;
  public _date?: fhir.FhirElement|undefined;
  /**
   * This description can be used to capture details such as why the structure map was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the structure map as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the structure map is presumed to be the predominant language in the place the structure map was created).
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * Allows filtering of structure maps that are appropriate for use versus not.
   */
  public experimental?: boolean|undefined;
  public _experimental?: fhir.FhirElement|undefined;
  /**
   * Organizes the mapping into manageable chunks for human review/ease of maintenance.
   */
  public group: fhir.StructureMapGroup[]|null;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this structure map outside of FHIR, where it is not possible to use the logical URI.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * Other maps used by this map (canonical URLs).
   */
  public import?: string[]|undefined;
  public _import?: fhir.FhirElement[]|undefined;
  /**
   * It may be possible for the structure map to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  public jurisdiction?: fhir.CodeableConcept[]|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the structure map is the organization or individual primarily responsible for the maintenance and upkeep of the structure map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the structure map. This item SHOULD be populated unless the information is available from context.
   */
  public publisher?: string|undefined;
  public _publisher?: fhir.FhirElement|undefined;
  /**
   * This element does not describe the usage of the structure map. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this structure map.
   */
  public purpose?: string|undefined;
  public _purpose?: fhir.FhirElement|undefined;
  /**
   * Allows filtering of structure maps that are appropriate for use versus not.
   */
  public status: StructureMapStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
   */
  public structure?: fhir.StructureMapStructure[]|undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  public title?: string|undefined;
  public _title?: fhir.FhirElement|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  public url: string|null;
  public _url?: fhir.FhirElement|undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  public useContext?: fhir.UsageContext[]|undefined;
  /**
   * There may be different structure map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the structure map with the format [url]|[version].
   */
  public version?: string|undefined;
  public _version?: fhir.FhirElement|undefined;
  /**
   * Default constructor for StructureMap - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IStructureMap> = {}) {
    super(source);
    this.resourceType = 'StructureMap';
    if (source["contact"]) { this.contact = source.contact.map((x:Partial<fhir.IContactDetail>) => new fhir.ContactDetail(x)); }
    if (source["copyright"]) { this.copyright = source.copyright; }
    if (source["_copyright"]) { this._copyright = new fhir.FhirElement(source._copyright!); }
    if (source["date"]) { this.date = source.date; }
    if (source["_date"]) { this._date = new fhir.FhirElement(source._date!); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["experimental"]) { this.experimental = source.experimental; }
    if (source["_experimental"]) { this._experimental = new fhir.FhirElement(source._experimental!); }
    this.group = null;
    if (source["group"]) { this.group = source.group.map((x:Partial<fhir.IStructureMapGroup>) => new fhir.StructureMapGroup(x)); }
    if (this.group === undefined) { this.group = null }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["import"]) { this.import = source.import.map((x) => (x)); }
    if (source["_import"]) { this._import = source._import.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["jurisdiction"]) { this.jurisdiction = source.jurisdiction.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["publisher"]) { this.publisher = source.publisher; }
    if (source["_publisher"]) { this._publisher = new fhir.FhirElement(source._publisher!); }
    if (source["purpose"]) { this.purpose = source.purpose; }
    if (source["_purpose"]) { this._purpose = new fhir.FhirElement(source._purpose!); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["structure"]) { this.structure = source.structure.map((x:Partial<fhir.IStructureMapStructure>) => new fhir.StructureMapStructure(x)); }
    if (source["title"]) { this.title = source.title; }
    if (source["_title"]) { this._title = new fhir.FhirElement(source._title!); }
    this.url = null;
    if (source["url"]) { this.url = source.url; }
    if (this.url === undefined) { this.url = null }
    if (source["_url"]) { this._url = new fhir.FhirElement(source._url!); }
    if (source["useContext"]) { this.useContext = source.useContext.map((x:Partial<fhir.IUsageContext>) => new fhir.UsageContext(x)); }
    if (source["version"]) { this.version = source.version; }
    if (source["_version"]) { this._version = new fhir.FhirElement(source._version!); }
  }
  /**
   * Check if the current StructureMap contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if ((!this["group"]) || (this["group"].length === 0)) { missingElements.push("group"); }
    if (this["name"] === undefined) { missingElements.push("name"); }
    if (this["status"] === undefined) { missingElements.push("status"); }
    if (this["url"] === undefined) { missingElements.push("url"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a StructureMap from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IStructureMap):StructureMap {
    var dest:StructureMap = new StructureMap(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `StructureMap is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the StructureMap.structure.mode field
 */
export enum StructureMapStructureModeEnum {
  SOURCE = "source",
  QUERIED = "queried",
  TARGET = "target",
  PRODUCED = "produced",
}
/**
 * Code Values for the StructureMap.group.input.mode field
 */
export enum StructureMapGroupInputModeEnum {
  SOURCE = "source",
  TARGET = "target",
}
/**
 * Code Values for the StructureMap.group.rule.source.listMode field
 */
export enum StructureMapGroupRuleSourceListModeEnum {
  FIRST = "first",
  NOT_FIRST = "not_first",
  LAST = "last",
  NOT_LAST = "not_last",
  ONLY_ONE = "only_one",
}
/**
 * Code Values for the StructureMap.group.rule.target.contextType field
 */
export enum StructureMapGroupRuleTargetContextTypeEnum {
  TYPE = "type",
  VARIABLE = "variable",
}
/**
 * Code Values for the StructureMap.group.rule.target.listMode field
 */
export enum StructureMapGroupRuleTargetListModeEnum {
  FIRST = "first",
  SHARE = "share",
  LAST = "last",
  COLLATE = "collate",
}
/**
 * Code Values for the StructureMap.group.rule.target.transform field
 */
export enum StructureMapGroupRuleTargetTransformEnum {
  CREATE = "create",
  COPY = "copy",
  TRUNCATE = "truncate",
  ESCAPE = "escape",
  CAST = "cast",
  APPEND = "append",
  TRANSLATE = "translate",
  REFERENCE = "reference",
  DATEOP = "dateOp",
  UUID = "uuid",
  POINTER = "pointer",
  EVALUATE = "evaluate",
  CC = "cc",
  C = "c",
  QTY = "qty",
  ID = "id",
  CP = "cp",
}
/**
 * Code Values for the StructureMap.group.typeMode field
 */
export enum StructureMapGroupTypeModeEnum {
  NONE = "none",
  TYPES = "types",
  TYPE_AND_TYPES = "type-and-types",
}
/**
 * Code Values for the StructureMap.status field
 */
export enum StructureMapStatusEnum {
  DRAFT = "draft",
  ACTIVE = "active",
  RETIRED = "retired",
  UNKNOWN = "unknown",
}
