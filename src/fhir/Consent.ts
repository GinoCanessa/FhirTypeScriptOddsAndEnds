// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Consent

import * as fhir from '../fhir.js';

import { SecurityRoleTypeValueSet, SecurityRoleTypeValueSetType,} from '../fhirValueSets/SecurityRoleTypeValueSet.js';
import { SecurityRoleTypeValueSetEnum } from '../valueSetEnums.js';
import { ConsentDataMeaningValueSet, ConsentDataMeaningValueSetType,} from '../fhirValueSets/ConsentDataMeaningValueSet.js';
import { ConsentDataMeaningValueSetEnum } from '../valueSetEnums.js';
import { ConsentProvisionTypeValueSet, ConsentProvisionTypeValueSetType,} from '../fhirValueSets/ConsentProvisionTypeValueSet.js';
import { ConsentProvisionTypeValueSetEnum } from '../valueSetEnums.js';
import { ConsentActionValueSet, ConsentActionValueSetType,} from '../fhirValueSets/ConsentActionValueSet.js';
import { ConsentActionValueSetEnum } from '../valueSetEnums.js';
import { SecurityLabelsValueSet, SecurityLabelsValueSetType,} from '../fhirValueSets/SecurityLabelsValueSet.js';
import { SecurityLabelsValueSetEnum } from '../valueSetEnums.js';
import { V3PurposeOfUseValueSet, V3PurposeOfUseValueSetType,} from '../fhirValueSets/V3PurposeOfUseValueSet.js';
import { V3PurposeOfUseValueSetEnum } from '../valueSetEnums.js';
import { ConsentContentClassValueSet, ConsentContentClassValueSetType,} from '../fhirValueSets/ConsentContentClassValueSet.js';
import { ConsentContentClassValueSetEnum } from '../valueSetEnums.js';
import { ConsentContentCodeValueSet, ConsentContentCodeValueSetType,} from '../fhirValueSets/ConsentContentCodeValueSet.js';
import { ConsentContentCodeValueSetEnum } from '../valueSetEnums.js';
import { ConsentStateCodesValueSet, ConsentStateCodesValueSetType,} from '../fhirValueSets/ConsentStateCodesValueSet.js';
import { ConsentStateCodesValueSetEnum } from '../valueSetEnums.js';
import { ConsentScopeValueSet, ConsentScopeValueSetType,} from '../fhirValueSets/ConsentScopeValueSet.js';
import { ConsentScopeValueSetEnum } from '../valueSetEnums.js';
import { ConsentCategoryValueSet, ConsentCategoryValueSetType,} from '../fhirValueSets/ConsentCategoryValueSet.js';
import { ConsentCategoryValueSetEnum } from '../valueSetEnums.js';
import { ConsentPolicyValueSet, ConsentPolicyValueSetType,} from '../fhirValueSets/ConsentPolicyValueSet.js';
import { ConsentPolicyValueSetEnum } from '../valueSetEnums.js';
import { IssueTypeValueSetEnum } from '../valueSetEnums.js';
import { IssueSeverityValueSetEnum } from '../valueSetEnums.js';
/**
 * Valid arguments for the ConsentPolicy type.
 */
export interface ConsentPolicyArgs extends fhir.BackboneElementArgs {
  /**
   * Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
   */
  authority?: fhir.FhirUri|string|undefined;
  /**
   * This element is for discoverability / documentation and does not modify or qualify the policy rules.
   */
  uri?: fhir.FhirUri|string|undefined;
}

/**
 * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
 */
export class ConsentPolicy extends fhir.BackboneElement {
  readonly __dataType:string = 'ConsentPolicy';
  /**
   * Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
   */
  public authority?: fhir.FhirUri|undefined;
  /**
   * This element is for discoverability / documentation and does not modify or qualify the policy rules.
   */
  public uri?: fhir.FhirUri|undefined;
  /**
   * Default constructor for ConsentPolicy - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentPolicyArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['authority']) { this.authority = new fhir.FhirUri({value: source.authority}); }
    if (source['uri']) { this.uri = new fhir.FhirUri({value: source.uri}); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (this["authority"]) { outcome.issue!.push(...this.authority.doModelValidation().issue!); }
    if (this["uri"]) { outcome.issue!.push(...this.uri.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the ConsentVerification type.
 */
export interface ConsentVerificationArgs extends fhir.BackboneElementArgs {
  /**
   * Has the instruction been verified.
   */
  verified: fhir.FhirBoolean|boolean|undefined;
  /**
   * Who verified the instruction (Patient, Relative or other Authorized Person).
   */
  verifiedWith?: fhir.ReferenceArgs|undefined;
  /**
   * Date verification was collected.
   */
  verificationDate?: fhir.FhirDateTime|string|undefined;
}

/**
 * Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
 */
export class ConsentVerification extends fhir.BackboneElement {
  readonly __dataType:string = 'ConsentVerification';
  /**
   * Has the instruction been verified.
   */
  public verified: fhir.FhirBoolean|null;
  /**
   * Who verified the instruction (Patient, Relative or other Authorized Person).
   */
  public verifiedWith?: fhir.Reference|undefined;
  /**
   * Date verification was collected.
   */
  public verificationDate?: fhir.FhirDateTime|undefined;
  /**
   * Default constructor for ConsentVerification - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentVerificationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['verified']) { this.verified = new fhir.FhirBoolean({value: source.verified}); }
    else { this.verified = null; }
    if (source['verifiedWith']) { this.verifiedWith = new fhir.Reference(source.verifiedWith); }
    if (source['verificationDate']) { this.verificationDate = new fhir.FhirDateTime({value: source.verificationDate}); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['verified']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property verified:fhir.FhirBoolean fhir: Consent.verification.verified:boolean", }));
    }
    if (this["verified"]) { outcome.issue!.push(...this.verified.doModelValidation().issue!); }
    if (this["verifiedWith"]) { outcome.issue!.push(...this.verifiedWith.doModelValidation().issue!); }
    if (this["verificationDate"]) { outcome.issue!.push(...this.verificationDate.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the ConsentProvisionActor type.
 */
export interface ConsentProvisionActorArgs extends fhir.BackboneElementArgs {
  /**
   * How the individual is involved in the resources content that is described in the exception.
   */
  role: fhir.CodeableConceptArgs|null;
  /**
   * The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  reference: fhir.ReferenceArgs|null;
}

/**
 * Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
 */
export class ConsentProvisionActor extends fhir.BackboneElement {
  readonly __dataType:string = 'ConsentProvisionActor';
  /**
   * How the individual is involved in the resources content that is described in the exception.
   */
  public role: fhir.CodeableConcept|null;
  /**
   * The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  public reference: fhir.Reference|null;
  /**
   * Default constructor for ConsentProvisionActor - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentProvisionActorArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    else { this.role = null; }
    if (source['reference']) { this.reference = new fhir.Reference(source.reference); }
    else { this.reference = null; }
  }
  /**
   * Extensible-bound Value Set for role
   */
  public static roleExtensibleValueSet():SecurityRoleTypeValueSetType {
    return SecurityRoleTypeValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['role']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property role:fhir.CodeableConcept fhir: Consent.provision.actor.role:CodeableConcept", }));
    }
    if (this["role"]) { outcome.issue!.push(...this.role.doModelValidation().issue!); }
    if (!this['reference']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property reference:fhir.Reference fhir: Consent.provision.actor.reference:Reference", }));
    }
    if (this["reference"]) { outcome.issue!.push(...this.reference.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the ConsentProvisionData type.
 */
export interface ConsentProvisionDataArgs extends fhir.BackboneElementArgs {
  /**
   * How the resource reference is interpreted when testing consent restrictions.
   */
  meaning: ConsentDataMeaningValueSetEnum|null;
  /**
   * A reference to a specific resource that defines which resources are covered by this consent.
   */
  reference: fhir.ReferenceArgs|null;
}

/**
 * The resources controlled by this rule if specific resources are referenced.
 */
export class ConsentProvisionData extends fhir.BackboneElement {
  readonly __dataType:string = 'ConsentProvisionData';
  /**
   * How the resource reference is interpreted when testing consent restrictions.
   */
  public meaning: ConsentDataMeaningValueSetEnum|null;
  /**
   * A reference to a specific resource that defines which resources are covered by this consent.
   */
  public reference: fhir.Reference|null;
  /**
   * Default constructor for ConsentProvisionData - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentProvisionDataArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['meaning']) { this.meaning = source.meaning; }
    else { this.meaning = null; }
    if (source['reference']) { this.reference = new fhir.Reference(source.reference); }
    else { this.reference = null; }
  }
  /**
   * Required-bound Value Set for meaning
   */
  public static meaningRequiredValueSet():ConsentDataMeaningValueSetType {
    return ConsentDataMeaningValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['meaning']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property meaning:ConsentDataMeaningValueSetEnum fhir: Consent.provision.data.meaning:code", }));
    }
    if (!this['reference']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property reference:fhir.Reference fhir: Consent.provision.data.reference:Reference", }));
    }
    if (this["reference"]) { outcome.issue!.push(...this.reference.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the ConsentProvision type.
 */
export interface ConsentProvisionArgs extends fhir.BackboneElementArgs {
  /**
   * Action  to take - permit or deny - when the rule conditions are met.  Not permitted in root rule, required in all nested rules.
   */
  type?: ConsentProvisionTypeValueSetEnum|undefined;
  /**
   * The timeframe in this rule is valid.
   */
  period?: fhir.PeriodArgs|undefined;
  /**
   * Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  actor?: fhir.ConsentProvisionActorArgs[]|undefined;
  /**
   * Note that this is the direct action (not the grounds for the action covered in the purpose element). At present, the only action in the understood and tested scope of this resource is 'read'.
   */
  action?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * If the consent specifies a security label of "R" then it applies to all resources that are labeled "R" or lower. E.g. for Confidentiality, it's a high water mark. For other kinds of security labels, subsumption logic applies. When the purpose of use tag is on the data, access request purpose of use shall not conflict.
   */
  securityLabel?: fhir.CodingArgs[]|undefined;
  /**
   * When the purpose of use tag is on the data, access request purpose of use shall not conflict.
   */
  purpose?: fhir.CodingArgs[]|undefined;
  /**
   * Multiple types are or'ed together. The intention of the contentType element is that the codes refer to profiles or document types defined in a standard or an implementation guide somewhere.
   */
  class?: fhir.CodingArgs[]|undefined;
  /**
   * Typical use of this is a Document code with class = CDA.
   */
  code?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * This has a different sense to the Consent.period - that is when the consent agreement holds. This is the time period of the data that is controlled by the agreement.
   */
  dataPeriod?: fhir.PeriodArgs|undefined;
  /**
   * The resources controlled by this rule if specific resources are referenced.
   */
  data?: fhir.ConsentProvisionDataArgs[]|undefined;
  /**
   * Rules which provide exceptions to the base rule or subrules.
   */
  provision?: fhir.ConsentProvisionArgs[]|undefined;
}

/**
 * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
 */
export class ConsentProvision extends fhir.BackboneElement {
  readonly __dataType:string = 'ConsentProvision';
  /**
   * Action  to take - permit or deny - when the rule conditions are met.  Not permitted in root rule, required in all nested rules.
   */
  public type?: ConsentProvisionTypeValueSetEnum|undefined;
  /**
   * The timeframe in this rule is valid.
   */
  public period?: fhir.Period|undefined;
  /**
   * Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
   */
  public actor?: fhir.ConsentProvisionActor[]|undefined = [];
  /**
   * Note that this is the direct action (not the grounds for the action covered in the purpose element). At present, the only action in the understood and tested scope of this resource is 'read'.
   */
  public action?: fhir.CodeableConcept[]|undefined = [];
  /**
   * If the consent specifies a security label of "R" then it applies to all resources that are labeled "R" or lower. E.g. for Confidentiality, it's a high water mark. For other kinds of security labels, subsumption logic applies. When the purpose of use tag is on the data, access request purpose of use shall not conflict.
   */
  public securityLabel?: fhir.Coding[]|undefined = [];
  /**
   * When the purpose of use tag is on the data, access request purpose of use shall not conflict.
   */
  public purpose?: fhir.Coding[]|undefined = [];
  /**
   * Multiple types are or'ed together. The intention of the contentType element is that the codes refer to profiles or document types defined in a standard or an implementation guide somewhere.
   */
  public class?: fhir.Coding[]|undefined = [];
  /**
   * Typical use of this is a Document code with class = CDA.
   */
  public code?: fhir.CodeableConcept[]|undefined = [];
  /**
   * This has a different sense to the Consent.period - that is when the consent agreement holds. This is the time period of the data that is controlled by the agreement.
   */
  public dataPeriod?: fhir.Period|undefined;
  /**
   * The resources controlled by this rule if specific resources are referenced.
   */
  public data?: fhir.ConsentProvisionData[]|undefined = [];
  /**
   * Rules which provide exceptions to the base rule or subrules.
   */
  public provision?: fhir.ConsentProvision[]|undefined = [];
  /**
   * Default constructor for ConsentProvision - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentProvisionArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = source.type; }
    if (source['period']) { this.period = new fhir.Period(source.period); }
    if (source['actor']) { this.actor = source.actor.map((x) => new fhir.ConsentProvisionActor(x)); }
    if (source['action']) { this.action = source.action.map((x) => new fhir.CodeableConcept(x)); }
    if (source['securityLabel']) { this.securityLabel = source.securityLabel.map((x) => new fhir.Coding(x)); }
    if (source['purpose']) { this.purpose = source.purpose.map((x) => new fhir.Coding(x)); }
    if (source['class']) { this.class = source.class.map((x) => new fhir.Coding(x)); }
    if (source['code']) { this.code = source.code.map((x) => new fhir.CodeableConcept(x)); }
    if (source['dataPeriod']) { this.dataPeriod = new fhir.Period(source.dataPeriod); }
    if (source['data']) { this.data = source.data.map((x) => new fhir.ConsentProvisionData(x)); }
    if (source['provision']) { this.provision = source.provision.map((x) => new fhir.ConsentProvision(x)); }
  }
  /**
   * Required-bound Value Set for type
   */
  public static typeRequiredValueSet():ConsentProvisionTypeValueSetType {
    return ConsentProvisionTypeValueSet;
  }
  /**
   * Example-bound Value Set for action
   */
  public static actionExampleValueSet():ConsentActionValueSetType {
    return ConsentActionValueSet;
  }
  /**
   * Extensible-bound Value Set for securityLabel
   */
  public static securityLabelExtensibleValueSet():SecurityLabelsValueSetType {
    return SecurityLabelsValueSet;
  }
  /**
   * Extensible-bound Value Set for purpose
   */
  public static purposeExtensibleValueSet():V3PurposeOfUseValueSetType {
    return V3PurposeOfUseValueSet;
  }
  /**
   * Extensible-bound Value Set for class
   */
  public static classExtensibleValueSet():ConsentContentClassValueSetType {
    return ConsentContentClassValueSet;
  }
  /**
   * Example-bound Value Set for code
   */
  public static codeExampleValueSet():ConsentContentCodeValueSetType {
    return ConsentContentCodeValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (this["period"]) { outcome.issue!.push(...this.period.doModelValidation().issue!); }
    if (this["actor"]) { this.actor.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["action"]) { this.action.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["securityLabel"]) { this.securityLabel.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["purpose"]) { this.purpose.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["class"]) { this.class.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["code"]) { this.code.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["dataPeriod"]) { outcome.issue!.push(...this.dataPeriod.doModelValidation().issue!); }
    if (this["data"]) { this.data.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["provision"]) { this.provision.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
/**
 * Valid arguments for the Consent type.
 */
export interface ConsentArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Consent"|undefined;
  /**
   * This identifier identifies this copy of the consent. Where this identifier is also used elsewhere as the identifier for a consent record (e.g. a CDA consent document) then the consent details are expected to be the same.
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes rejected and entered-in-error that mark the Consent as not currently valid.
   */
  status: ConsentStateCodesValueSetEnum|null;
  /**
   * A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible.
   */
  scope: fhir.CodeableConceptArgs|null;
  /**
   * A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
   */
  category: fhir.CodeableConceptArgs[]|null;
  /**
   * Commonly, the patient the consent pertains to is the author, but for young and old people, it may be some other person.
   */
  patient?: fhir.ReferenceArgs|undefined;
  /**
   * This is not the time of the original consent, but the time that this statement was made or derived.
   */
  dateTime?: fhir.FhirDateTime|string|undefined;
  /**
   * Commonly, the patient the consent pertains to is the consentor, but particularly for young and old people, it may be some other person - e.g. a legal guardian.
   */
  performer?: fhir.ReferenceArgs[]|undefined;
  /**
   * The organization that manages the consent, and the framework within which it is executed.
   */
  organization?: fhir.ReferenceArgs[]|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  source?: fhir.Attachment|fhir.Reference|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  sourceAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  sourceReference?: fhir.ReferenceArgs|undefined;
  /**
   * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
   */
  policy?: fhir.ConsentPolicyArgs[]|undefined;
  /**
   * If the policyRule is absent, computable consent would need to be constructed from the elements of the Consent resource.
   */
  policyRule?: fhir.CodeableConceptArgs|undefined;
  /**
   * Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
   */
  verification?: fhir.ConsentVerificationArgs[]|undefined;
  /**
   * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
   */
  provision?: fhir.ConsentProvisionArgs|undefined;
}

/**
 * A record of a healthcare consumer’s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
 */
export class Consent extends fhir.DomainResource {
  readonly __dataType:string = 'Consent';
  /**
   * Resource Type Name
   */
  public resourceType: "Consent";
  /**
   * This identifier identifies this copy of the consent. Where this identifier is also used elsewhere as the identifier for a consent record (e.g. a CDA consent document) then the consent details are expected to be the same.
   */
  public identifier?: fhir.Identifier[]|undefined = [];
  /**
   * This element is labeled as a modifier because the status contains the codes rejected and entered-in-error that mark the Consent as not currently valid.
   */
  public status: ConsentStateCodesValueSetEnum|null;
  /**
   * A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible.
   */
  public scope: fhir.CodeableConcept|null;
  /**
   * A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
   */
  public category: fhir.CodeableConcept[]|null = [];
  /**
   * Commonly, the patient the consent pertains to is the author, but for young and old people, it may be some other person.
   */
  public patient?: fhir.Reference|undefined;
  /**
   * This is not the time of the original consent, but the time that this statement was made or derived.
   */
  public dateTime?: fhir.FhirDateTime|undefined;
  /**
   * Commonly, the patient the consent pertains to is the consentor, but particularly for young and old people, it may be some other person - e.g. a legal guardian.
   */
  public performer?: fhir.Reference[]|undefined = [];
  /**
   * The organization that manages the consent, and the framework within which it is executed.
   */
  public organization?: fhir.Reference[]|undefined = [];
  /**
   * The source can be contained inline (Attachment), referenced directly (Consent), referenced in a consent repository (DocumentReference), or simply by an identifier (Identifier), e.g. a CDA document id.
   */
  public source?: (fhir.Attachment|fhir.Reference)|undefined;
  readonly __sourceIsChoice:true = true;
  /**
   * The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
   */
  public policy?: fhir.ConsentPolicy[]|undefined = [];
  /**
   * If the policyRule is absent, computable consent would need to be constructed from the elements of the Consent resource.
   */
  public policyRule?: fhir.CodeableConcept|undefined;
  /**
   * Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
   */
  public verification?: fhir.ConsentVerification[]|undefined = [];
  /**
   * An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
   */
  public provision?: fhir.ConsentProvision|undefined;
  /**
   * Default constructor for Consent - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ConsentArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Consent';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    if (source['status']) { this.status = source.status; }
    else { this.status = null; }
    if (source['scope']) { this.scope = new fhir.CodeableConcept(source.scope); }
    else { this.scope = null; }
    if (source['category']) { this.category = source.category.map((x) => new fhir.CodeableConcept(x)); }
    else { this.category = null; }
    if (source['patient']) { this.patient = new fhir.Reference(source.patient); }
    if (source['dateTime']) { this.dateTime = new fhir.FhirDateTime({value: source.dateTime}); }
    if (source['performer']) { this.performer = source.performer.map((x) => new fhir.Reference(x)); }
    if (source['organization']) { this.organization = source.organization.map((x) => new fhir.Reference(x)); }
    if (source['source']) { this.source = source.source; }
    else if (source['sourceAttachment']) { this.source = new fhir.Attachment(source.sourceAttachment); }
    else if (source['sourceReference']) { this.source = new fhir.Reference(source.sourceReference); }
    if (source['policy']) { this.policy = source.policy.map((x) => new fhir.ConsentPolicy(x)); }
    if (source['policyRule']) { this.policyRule = new fhir.CodeableConcept(source.policyRule); }
    if (source['verification']) { this.verification = source.verification.map((x) => new fhir.ConsentVerification(x)); }
    if (source['provision']) { this.provision = new fhir.ConsentProvision(source.provision); }
  }
  /**
   * Required-bound Value Set for status
   */
  public static statusRequiredValueSet():ConsentStateCodesValueSetType {
    return ConsentStateCodesValueSet;
  }
  /**
   * Extensible-bound Value Set for scope
   */
  public static scopeExtensibleValueSet():ConsentScopeValueSetType {
    return ConsentScopeValueSet;
  }
  /**
   * Extensible-bound Value Set for category
   */
  public static categoryExtensibleValueSet():ConsentCategoryValueSetType {
    return ConsentCategoryValueSet;
  }
  /**
   * Extensible-bound Value Set for policyRule
   */
  public static policyRuleExtensibleValueSet():ConsentPolicyValueSetType {
    return ConsentPolicyValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['resourceType']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property resourceType:'Consent' fhir: Consent.resourceType:'Consent'", }));
    }
    if (this["identifier"]) { this.identifier.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (!this['status']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property status:ConsentStateCodesValueSetEnum fhir: Consent.status:code", }));
    }
    if (!this['scope']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property scope:fhir.CodeableConcept fhir: Consent.scope:CodeableConcept", }));
    }
    if (this["scope"]) { outcome.issue!.push(...this.scope.doModelValidation().issue!); }
    if (!this['category']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property category:fhir.CodeableConcept[] fhir: Consent.category:CodeableConcept", }));
    } else if (!Array.isArray(this.category)) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.StructuralIssue,  diagnostics: "Found scalar in array property category:fhir.CodeableConcept[] fhir: Consent.category:CodeableConcept", }));
    } else if (this.category.length === 0) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityValueSetEnum.Error, code: IssueTypeValueSetEnum.RequiredElementMissing,  diagnostics: "Missing required property category:fhir.CodeableConcept[] fhir: Consent.category:CodeableConcept", }));
    }
    if (this["category"]) { this.category.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["patient"]) { outcome.issue!.push(...this.patient.doModelValidation().issue!); }
    if (this["dateTime"]) { outcome.issue!.push(...this.dateTime.doModelValidation().issue!); }
    if (this["performer"]) { this.performer.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["organization"]) { this.organization.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["policy"]) { this.policy.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["policyRule"]) { outcome.issue!.push(...this.policyRule.doModelValidation().issue!); }
    if (this["verification"]) { this.verification.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    if (this["provision"]) { outcome.issue!.push(...this.provision.doModelValidation().issue!); }
    return outcome;
  }
  /**
   * Function to strip invalid element values for serialization.
   */
  public toJSON() {
    return fhir.fhirToJson(this);
  }
}
