// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * More detailed availability information may be provided in associated Schedule/Slot resources.
 */
export type IPractitionerRoleAvailableTime = fhir.IBackboneElement & {
  /**
   * Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   */
  allDay?: boolean|undefined;
  _allDay?: fhir.IFhirElement|undefined;
  /**
   * The timezone is expected to be for where this HealthcareService is provided at.
   */
  availableEndTime?: string|undefined;
  _availableEndTime?: fhir.IFhirElement|undefined;
  /**
   * The timezone is expected to be for where this HealthcareService is provided at.
   */
  availableStartTime?: string|undefined;
  _availableStartTime?: fhir.IFhirElement|undefined;
  /**
   * Indicates which days of the week are available between the start and end Times.
   */
  daysOfWeek?: PractitionerRoleAvailableTimeDaysOfWeekEnum[]|undefined;
  _daysOfWeek?: fhir.IFhirElement[]|undefined;
}
/**
 * The practitioner is not available or performing this role during this period of time due to the provided reason.
 */
export type IPractitionerRoleNotAvailable = fhir.IBackboneElement & {
  /**
   * The reason that can be presented to the user as to why this time is not available.
   */
  description: string|null;
  _description?: fhir.IFhirElement|undefined;
  /**
   * Service is not available (seasonally or for a public holiday) from this date.
   */
  during?: fhir.IPeriod|undefined;
}
/**
 * A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 */
export type IPractitionerRole = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "PractitionerRole";
  /**
   * If this value is false, you may refer to the period to see when the role was in active use. If there is no period specified, no inference can be made about when it was active.
   */
  active?: boolean|undefined;
  _active?: fhir.IFhirElement|undefined;
  /**
   * A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   */
  availabilityExceptions?: string|undefined;
  _availabilityExceptions?: fhir.IFhirElement|undefined;
  /**
   * More detailed availability information may be provided in associated Schedule/Slot resources.
   */
  availableTime?: fhir.IPractitionerRoleAvailableTime[]|undefined;
  /**
   * A person may have more than one role.
   */
  code?: fhir.ICodeableConcept[]|undefined;
  /**
   * Technical endpoints providing access to services operated for the practitioner with this role.
   */
  endpoint?: fhir.IReference[]|undefined;
  /**
   * The list of healthcare services that this worker provides for this role's Organization/Location(s).
   */
  healthcareService?: fhir.IReference[]|undefined;
  /**
   * Business Identifiers that are specific to a role/location.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The location(s) at which this practitioner provides care.
   */
  location?: fhir.IReference[]|undefined;
  /**
   * The practitioner is not available or performing this role during this period of time due to the provided reason.
   */
  notAvailable?: fhir.IPractitionerRoleNotAvailable[]|undefined;
  /**
   * The organization where the Practitioner performs the roles associated.
   */
  organization?: fhir.IReference|undefined;
  /**
   * The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
   */
  period?: fhir.IPeriod|undefined;
  /**
   * Practitioner that is able to provide the defined services for the organization.
   */
  practitioner?: fhir.IReference|undefined;
  /**
   * Specific specialty of the practitioner.
   */
  specialty?: fhir.ICodeableConcept[]|undefined;
  /**
   * Contact details that are specific to the role/location/service.
   */
  telecom?: fhir.IContactPoint[]|undefined;
}
/**
 * More detailed availability information may be provided in associated Schedule/Slot resources.
 */
export class PractitionerRoleAvailableTime extends fhir.BackboneElement implements fhir.IPractitionerRoleAvailableTime {
  /**
   * Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   */
  public allDay?: boolean|undefined;
  public _allDay?: fhir.FhirElement|undefined;
  /**
   * The timezone is expected to be for where this HealthcareService is provided at.
   */
  public availableEndTime?: string|undefined;
  public _availableEndTime?: fhir.FhirElement|undefined;
  /**
   * The timezone is expected to be for where this HealthcareService is provided at.
   */
  public availableStartTime?: string|undefined;
  public _availableStartTime?: fhir.FhirElement|undefined;
  /**
   * Indicates which days of the week are available between the start and end Times.
   */
  public daysOfWeek?: PractitionerRoleAvailableTimeDaysOfWeekEnum[]|undefined;
  public _daysOfWeek?: fhir.FhirElement[]|undefined;
  /**
   * Default constructor for PractitionerRoleAvailableTime - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IPractitionerRoleAvailableTime> = {}) {
    super(source);
    if (source["allDay"]) { this.allDay = source.allDay; }
    if (source["_allDay"]) { this._allDay = new fhir.FhirElement(source._allDay!); }
    if (source["availableEndTime"]) { this.availableEndTime = source.availableEndTime; }
    if (source["_availableEndTime"]) { this._availableEndTime = new fhir.FhirElement(source._availableEndTime!); }
    if (source["availableStartTime"]) { this.availableStartTime = source.availableStartTime; }
    if (source["_availableStartTime"]) { this._availableStartTime = new fhir.FhirElement(source._availableStartTime!); }
    if (source["daysOfWeek"]) { this.daysOfWeek = source.daysOfWeek.map((x) => (x)); }
    if (source["_daysOfWeek"]) { this._daysOfWeek = source._daysOfWeek.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
  }
  /**
   * Check if the current PractitionerRoleAvailableTime contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a PractitionerRoleAvailableTime from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IPractitionerRoleAvailableTime):PractitionerRoleAvailableTime {
    var dest:PractitionerRoleAvailableTime = new PractitionerRoleAvailableTime(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `PractitionerRoleAvailableTime is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The practitioner is not available or performing this role during this period of time due to the provided reason.
 */
export class PractitionerRoleNotAvailable extends fhir.BackboneElement implements fhir.IPractitionerRoleNotAvailable {
  /**
   * The reason that can be presented to the user as to why this time is not available.
   */
  public description: string|null;
  public _description?: fhir.FhirElement|undefined;
  /**
   * Service is not available (seasonally or for a public holiday) from this date.
   */
  public during?: fhir.Period|undefined;
  /**
   * Default constructor for PractitionerRoleNotAvailable - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IPractitionerRoleNotAvailable> = {}) {
    super(source);
    this.description = null;
    if (source["description"]) { this.description = source.description; }
    if (this.description === undefined) { this.description = null }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["during"]) { this.during = new fhir.Period(source.during!); }
  }
  /**
   * Check if the current PractitionerRoleNotAvailable contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["description"] === undefined) { missingElements.push("description"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a PractitionerRoleNotAvailable from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IPractitionerRoleNotAvailable):PractitionerRoleNotAvailable {
    var dest:PractitionerRoleNotAvailable = new PractitionerRoleNotAvailable(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `PractitionerRoleNotAvailable is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 */
export class PractitionerRole extends fhir.DomainResource implements fhir.IPractitionerRole {
  /**
   * Resource Type Name
   */
  public override resourceType: "PractitionerRole";
  /**
   * If this value is false, you may refer to the period to see when the role was in active use. If there is no period specified, no inference can be made about when it was active.
   */
  public active?: boolean|undefined;
  public _active?: fhir.FhirElement|undefined;
  /**
   * A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   */
  public availabilityExceptions?: string|undefined;
  public _availabilityExceptions?: fhir.FhirElement|undefined;
  /**
   * More detailed availability information may be provided in associated Schedule/Slot resources.
   */
  public availableTime?: fhir.PractitionerRoleAvailableTime[]|undefined;
  /**
   * A person may have more than one role.
   */
  public code?: fhir.CodeableConcept[]|undefined;
  /**
   * Technical endpoints providing access to services operated for the practitioner with this role.
   */
  public endpoint?: fhir.Reference[]|undefined;
  /**
   * The list of healthcare services that this worker provides for this role's Organization/Location(s).
   */
  public healthcareService?: fhir.Reference[]|undefined;
  /**
   * Business Identifiers that are specific to a role/location.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The location(s) at which this practitioner provides care.
   */
  public location?: fhir.Reference[]|undefined;
  /**
   * The practitioner is not available or performing this role during this period of time due to the provided reason.
   */
  public notAvailable?: fhir.PractitionerRoleNotAvailable[]|undefined;
  /**
   * The organization where the Practitioner performs the roles associated.
   */
  public organization?: fhir.Reference|undefined;
  /**
   * The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
   */
  public period?: fhir.Period|undefined;
  /**
   * Practitioner that is able to provide the defined services for the organization.
   */
  public practitioner?: fhir.Reference|undefined;
  /**
   * Specific specialty of the practitioner.
   */
  public specialty?: fhir.CodeableConcept[]|undefined;
  /**
   * Contact details that are specific to the role/location/service.
   */
  public telecom?: fhir.ContactPoint[]|undefined;
  /**
   * Default constructor for PractitionerRole - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.IPractitionerRole> = {}) {
    super(source);
    this.resourceType = 'PractitionerRole';
    if (source["active"]) { this.active = source.active; }
    if (source["_active"]) { this._active = new fhir.FhirElement(source._active!); }
    if (source["availabilityExceptions"]) { this.availabilityExceptions = source.availabilityExceptions; }
    if (source["_availabilityExceptions"]) { this._availabilityExceptions = new fhir.FhirElement(source._availabilityExceptions!); }
    if (source["availableTime"]) { this.availableTime = source.availableTime.map((x:Partial<fhir.IPractitionerRoleAvailableTime>) => new fhir.PractitionerRoleAvailableTime(x)); }
    if (source["code"]) { this.code = source.code.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["endpoint"]) { this.endpoint = source.endpoint.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["healthcareService"]) { this.healthcareService = source.healthcareService.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["location"]) { this.location = source.location.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["notAvailable"]) { this.notAvailable = source.notAvailable.map((x:Partial<fhir.IPractitionerRoleNotAvailable>) => new fhir.PractitionerRoleNotAvailable(x)); }
    if (source["organization"]) { this.organization = new fhir.Reference(source.organization!); }
    if (source["period"]) { this.period = new fhir.Period(source.period!); }
    if (source["practitioner"]) { this.practitioner = new fhir.Reference(source.practitioner!); }
    if (source["specialty"]) { this.specialty = source.specialty.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["telecom"]) { this.telecom = source.telecom.map((x:Partial<fhir.IContactPoint>) => new fhir.ContactPoint(x)); }
  }
  /**
   * Check if the current PractitionerRole contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a PractitionerRole from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.IPractitionerRole):PractitionerRole {
    var dest:PractitionerRole = new PractitionerRole(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `PractitionerRole is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the PractitionerRole.availableTime.daysOfWeek field
 */
export enum PractitionerRoleAvailableTimeDaysOfWeekEnum {
  MON = "mon",
  TUE = "tue",
  WED = "wed",
  THU = "thu",
  FRI = "fri",
  SAT = "sat",
  SUN = "sun",
}
