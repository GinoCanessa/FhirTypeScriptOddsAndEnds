// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
 */
export type ITerminologyCapabilitiesSoftware = fhir.IBackboneElement & {
  /**
   * Name the software is known by.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
  /**
   * If possible, a version should be specified, as statements are likely to be different for different versions of software.
   */
  version?: string|undefined;
  _version?: fhir.IFhirElement|undefined;
}
/**
 * Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
export type ITerminologyCapabilitiesImplementation = fhir.IBackboneElement & {
  /**
   * Information about the specific installation that this terminology capability statement relates to.
   */
  description: string|null;
  _description?: fhir.IFhirElement|undefined;
  /**
   * An absolute base URL for the implementation.
   */
  url?: string|undefined;
  _url?: fhir.IFhirElement|undefined;
}
/**
 * Filter Properties supported.
 */
export type ITerminologyCapabilitiesCodeSystemVersionFilter = fhir.IBackboneElement & {
  /**
   * Code of the property supported.
   */
  code: string|null;
  _code?: fhir.IFhirElement|undefined;
  /**
   * Operations supported for the property.
   */
  op: string[]|null;
  _op?: fhir.IFhirElement[]|undefined;
}
/**
 * Language translations might not be available for all codes.
 */
export type ITerminologyCapabilitiesCodeSystemVersion = fhir.IBackboneElement & {
  /**
   * For version-less code systems, there should be a single version with no identifier.
   */
  code?: string|undefined;
  _code?: fhir.IFhirElement|undefined;
  /**
   * If the compositional grammar defined by the code system is supported.
   */
  compositional?: boolean|undefined;
  _compositional?: fhir.IFhirElement|undefined;
  /**
   * Filter Properties supported.
   */
  filter?: fhir.ITerminologyCapabilitiesCodeSystemVersionFilter[]|undefined;
  /**
   * If this is the default version for this code system.
   */
  isDefault?: boolean|undefined;
  _isDefault?: fhir.IFhirElement|undefined;
  /**
   * Language Displays supported.
   */
  language?: string[]|undefined;
  _language?: fhir.IFhirElement[]|undefined;
  /**
   * Properties supported for $lookup.
   */
  property?: string[]|undefined;
  _property?: fhir.IFhirElement[]|undefined;
}
/**
 * The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
 */
export type ITerminologyCapabilitiesCodeSystem = fhir.IBackboneElement & {
  /**
   * True if subsumption is supported for this version of the code system.
   */
  subsumption?: boolean|undefined;
  _subsumption?: fhir.IFhirElement|undefined;
  /**
   * URI for the Code System.
   */
  uri?: string|undefined;
  _uri?: fhir.IFhirElement|undefined;
  /**
   * Language translations might not be available for all codes.
   */
  version?: fhir.ITerminologyCapabilitiesCodeSystemVersion[]|undefined;
}
/**
 * Supported expansion parameter.
 */
export type ITerminologyCapabilitiesExpansionParameter = fhir.IBackboneElement & {
  /**
   * Description of support for parameter.
   */
  documentation?: string|undefined;
  _documentation?: fhir.IFhirElement|undefined;
  /**
   * Expansion Parameter name.
   */
  name: string|null;
  _name?: fhir.IFhirElement|undefined;
}
/**
 * Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
 */
export type ITerminologyCapabilitiesExpansion = fhir.IBackboneElement & {
  /**
   * Whether the server can return nested value sets.
   */
  hierarchical?: boolean|undefined;
  _hierarchical?: fhir.IFhirElement|undefined;
  /**
   * Allow request for incomplete expansions?
   */
  incomplete?: boolean|undefined;
  _incomplete?: fhir.IFhirElement|undefined;
  /**
   * Whether the server supports paging on expansion.
   */
  paging?: boolean|undefined;
  _paging?: fhir.IFhirElement|undefined;
  /**
   * Supported expansion parameter.
   */
  parameter?: fhir.ITerminologyCapabilitiesExpansionParameter[]|undefined;
  /**
   * This documentation should cover things like case sensitivity,  use of punctuation if not ignored, what wild cards are supported (if any), whether text is starts with or contains, and whether word order matters.
   */
  textFilter?: string|undefined;
  _textFilter?: fhir.IFhirElement|undefined;
}
/**
 * Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
 */
export type ITerminologyCapabilitiesValidateCode = fhir.IBackboneElement & {
  /**
   * Whether translations are validated.
   */
  translations: boolean|null;
  _translations?: fhir.IFhirElement|undefined;
}
/**
 * Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
 */
export type ITerminologyCapabilitiesTranslation = fhir.IBackboneElement & {
  /**
   * Whether the client must identify the map.
   */
  needsMap: boolean|null;
  _needsMap?: fhir.IFhirElement|undefined;
}
/**
 * Whether the $closure operation is supported.
 */
export type ITerminologyCapabilitiesClosure = fhir.IBackboneElement & {
  /**
   * If cross-system closure is supported.
   */
  translation?: boolean|undefined;
  _translation?: fhir.IFhirElement|undefined;
}
/**
 * A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
export type ITerminologyCapabilities = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "TerminologyCapabilities";
  /**
   * Whether the $closure operation is supported.
   */
  closure?: fhir.ITerminologyCapabilitiesClosure|undefined;
  /**
   * See notes on the [ValueSet](valueset.html#) resource.
   */
  codeSearch?: TerminologyCapabilitiesCodeSearchEnum|undefined;
  _codeSearch?: fhir.IFhirElement|undefined;
  /**
   * The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
   */
  codeSystem?: fhir.ITerminologyCapabilitiesCodeSystem[]|undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  contact?: fhir.IContactDetail[]|undefined;
  /**
   * A copyright statement relating to the terminology capabilities and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the terminology capabilities.
   */
  copyright?: string|undefined;
  _copyright?: fhir.IFhirElement|undefined;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the terminology capabilities. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  date: string|null;
  _date?: fhir.IFhirElement|undefined;
  /**
   * This description can be used to capture details such as why the terminology capabilities was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the terminology capabilities as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the terminology capabilities is presumed to be the predominant language in the place the terminology capabilities was created).This does not need to be populated if the description is adequately implied by the software or implementation details.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
   */
  expansion?: fhir.ITerminologyCapabilitiesExpansion|undefined;
  /**
   * Allows filtering of terminology capabilitiess that are appropriate for use versus not.
   */
  experimental?: boolean|undefined;
  _experimental?: fhir.IFhirElement|undefined;
  /**
   * Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
   */
  implementation?: fhir.ITerminologyCapabilitiesImplementation|undefined;
  /**
   * It may be possible for the terminology capabilities to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  jurisdiction?: fhir.ICodeableConcept[]|undefined;
  /**
   * The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind, not instance of software) or a class of implementation (e.g. a desired purchase).
   */
  kind: TerminologyCapabilitiesKindEnum|null;
  _kind?: fhir.IFhirElement|undefined;
  /**
   * Whether the server supports lockedDate.
   */
  lockedDate?: boolean|undefined;
  _lockedDate?: fhir.IFhirElement|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  name?: string|undefined;
  _name?: fhir.IFhirElement|undefined;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the terminology capabilities is the organization or individual primarily responsible for the maintenance and upkeep of the terminology capabilities. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the terminology capabilities. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: string|undefined;
  _publisher?: fhir.IFhirElement|undefined;
  /**
   * This element does not describe the usage of the terminology capabilities. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this terminology capabilities.
   */
  purpose?: string|undefined;
  _purpose?: fhir.IFhirElement|undefined;
  /**
   * Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
   */
  software?: fhir.ITerminologyCapabilitiesSoftware|undefined;
  /**
   * Allows filtering of terminology capabilitiess that are appropriate for use versus not.This is not intended for use with actual capability statements, but where capability statements are used to describe possible or desired systems.
   */
  status: TerminologyCapabilitiesStatusEnum|null;
  _status?: fhir.IFhirElement|undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  title?: string|undefined;
  _title?: fhir.IFhirElement|undefined;
  /**
   * Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
   */
  translation?: fhir.ITerminologyCapabilitiesTranslation|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  url?: string|undefined;
  _url?: fhir.IFhirElement|undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: fhir.IUsageContext[]|undefined;
  /**
   * Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
   */
  validateCode?: fhir.ITerminologyCapabilitiesValidateCode|undefined;
  /**
   * There may be different terminology capabilities instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the terminology capabilities with the format [url]|[version].
   */
  version?: string|undefined;
  _version?: fhir.IFhirElement|undefined;
}
/**
 * Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
 */
export class TerminologyCapabilitiesSoftware extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesSoftware {
  /**
   * Name the software is known by.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * If possible, a version should be specified, as statements are likely to be different for different versions of software.
   */
  public version?: string|undefined;
  public _version?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesSoftware - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesSoftware> = {}) {
    super(source);
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["version"]) { this.version = source.version; }
    if (source["_version"]) { this._version = new fhir.FhirElement(source._version!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesSoftware contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["name"] === undefined) { missingElements.push("name"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesSoftware from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesSoftware):TerminologyCapabilitiesSoftware {
    var dest:TerminologyCapabilitiesSoftware = new TerminologyCapabilitiesSoftware(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesSoftware is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
 */
export class TerminologyCapabilitiesImplementation extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesImplementation {
  /**
   * Information about the specific installation that this terminology capability statement relates to.
   */
  public description: string|null;
  public _description?: fhir.FhirElement|undefined;
  /**
   * An absolute base URL for the implementation.
   */
  public url?: string|undefined;
  public _url?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesImplementation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesImplementation> = {}) {
    super(source);
    this.description = null;
    if (source["description"]) { this.description = source.description; }
    if (this.description === undefined) { this.description = null }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["url"]) { this.url = source.url; }
    if (source["_url"]) { this._url = new fhir.FhirElement(source._url!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesImplementation contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["description"] === undefined) { missingElements.push("description"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesImplementation from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesImplementation):TerminologyCapabilitiesImplementation {
    var dest:TerminologyCapabilitiesImplementation = new TerminologyCapabilitiesImplementation(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesImplementation is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Filter Properties supported.
 */
export class TerminologyCapabilitiesCodeSystemVersionFilter extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesCodeSystemVersionFilter {
  /**
   * Code of the property supported.
   */
  public code: string|null;
  public _code?: fhir.FhirElement|undefined;
  /**
   * Operations supported for the property.
   */
  public op: string[]|null;
  public _op?: fhir.FhirElement[]|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesCodeSystemVersionFilter - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesCodeSystemVersionFilter> = {}) {
    super(source);
    this.code = null;
    if (source["code"]) { this.code = source.code; }
    if (this.code === undefined) { this.code = null }
    if (source["_code"]) { this._code = new fhir.FhirElement(source._code!); }
    this.op = null;
    if (source["op"]) { this.op = source.op.map((x) => (x)); }
    if (this.op === undefined) { this.op = null }
    if (source["_op"]) { this._op = source._op.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
  }
  /**
   * Check if the current TerminologyCapabilitiesCodeSystemVersionFilter contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    if ((!this["op"]) || (this["op"].length === 0)) { missingElements.push("op"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesCodeSystemVersionFilter from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesCodeSystemVersionFilter):TerminologyCapabilitiesCodeSystemVersionFilter {
    var dest:TerminologyCapabilitiesCodeSystemVersionFilter = new TerminologyCapabilitiesCodeSystemVersionFilter(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesCodeSystemVersionFilter is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Language translations might not be available for all codes.
 */
export class TerminologyCapabilitiesCodeSystemVersion extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesCodeSystemVersion {
  /**
   * For version-less code systems, there should be a single version with no identifier.
   */
  public code?: string|undefined;
  public _code?: fhir.FhirElement|undefined;
  /**
   * If the compositional grammar defined by the code system is supported.
   */
  public compositional?: boolean|undefined;
  public _compositional?: fhir.FhirElement|undefined;
  /**
   * Filter Properties supported.
   */
  public filter?: fhir.TerminologyCapabilitiesCodeSystemVersionFilter[]|undefined;
  /**
   * If this is the default version for this code system.
   */
  public isDefault?: boolean|undefined;
  public _isDefault?: fhir.FhirElement|undefined;
  /**
   * Language Displays supported.
   */
  public language?: string[]|undefined;
  public _language?: fhir.FhirElement[]|undefined;
  /**
   * Properties supported for $lookup.
   */
  public property?: string[]|undefined;
  public _property?: fhir.FhirElement[]|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesCodeSystemVersion - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesCodeSystemVersion> = {}) {
    super(source);
    if (source["code"]) { this.code = source.code; }
    if (source["_code"]) { this._code = new fhir.FhirElement(source._code!); }
    if (source["compositional"]) { this.compositional = source.compositional; }
    if (source["_compositional"]) { this._compositional = new fhir.FhirElement(source._compositional!); }
    if (source["filter"]) { this.filter = source.filter.map((x:Partial<fhir.ITerminologyCapabilitiesCodeSystemVersionFilter>) => new fhir.TerminologyCapabilitiesCodeSystemVersionFilter(x)); }
    if (source["isDefault"]) { this.isDefault = source.isDefault; }
    if (source["_isDefault"]) { this._isDefault = new fhir.FhirElement(source._isDefault!); }
    if (source["language"]) { this.language = source.language.map((x) => (x)); }
    if (source["_language"]) { this._language = source._language.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
    if (source["property"]) { this.property = source.property.map((x) => (x)); }
    if (source["_property"]) { this._property = source._property.map((x:Partial<fhir.IFhirElement>) => new fhir.FhirElement(x)); }
  }
  /**
   * Check if the current TerminologyCapabilitiesCodeSystemVersion contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesCodeSystemVersion from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesCodeSystemVersion):TerminologyCapabilitiesCodeSystemVersion {
    var dest:TerminologyCapabilitiesCodeSystemVersion = new TerminologyCapabilitiesCodeSystemVersion(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesCodeSystemVersion is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
 */
export class TerminologyCapabilitiesCodeSystem extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesCodeSystem {
  /**
   * True if subsumption is supported for this version of the code system.
   */
  public subsumption?: boolean|undefined;
  public _subsumption?: fhir.FhirElement|undefined;
  /**
   * URI for the Code System.
   */
  public uri?: string|undefined;
  public _uri?: fhir.FhirElement|undefined;
  /**
   * Language translations might not be available for all codes.
   */
  public version?: fhir.TerminologyCapabilitiesCodeSystemVersion[]|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesCodeSystem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesCodeSystem> = {}) {
    super(source);
    if (source["subsumption"]) { this.subsumption = source.subsumption; }
    if (source["_subsumption"]) { this._subsumption = new fhir.FhirElement(source._subsumption!); }
    if (source["uri"]) { this.uri = source.uri; }
    if (source["_uri"]) { this._uri = new fhir.FhirElement(source._uri!); }
    if (source["version"]) { this.version = source.version.map((x:Partial<fhir.ITerminologyCapabilitiesCodeSystemVersion>) => new fhir.TerminologyCapabilitiesCodeSystemVersion(x)); }
  }
  /**
   * Check if the current TerminologyCapabilitiesCodeSystem contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesCodeSystem from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesCodeSystem):TerminologyCapabilitiesCodeSystem {
    var dest:TerminologyCapabilitiesCodeSystem = new TerminologyCapabilitiesCodeSystem(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesCodeSystem is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Supported expansion parameter.
 */
export class TerminologyCapabilitiesExpansionParameter extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesExpansionParameter {
  /**
   * Description of support for parameter.
   */
  public documentation?: string|undefined;
  public _documentation?: fhir.FhirElement|undefined;
  /**
   * Expansion Parameter name.
   */
  public name: string|null;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesExpansionParameter - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesExpansionParameter> = {}) {
    super(source);
    if (source["documentation"]) { this.documentation = source.documentation; }
    if (source["_documentation"]) { this._documentation = new fhir.FhirElement(source._documentation!); }
    this.name = null;
    if (source["name"]) { this.name = source.name; }
    if (this.name === undefined) { this.name = null }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesExpansionParameter contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["name"] === undefined) { missingElements.push("name"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesExpansionParameter from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesExpansionParameter):TerminologyCapabilitiesExpansionParameter {
    var dest:TerminologyCapabilitiesExpansionParameter = new TerminologyCapabilitiesExpansionParameter(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesExpansionParameter is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
 */
export class TerminologyCapabilitiesExpansion extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesExpansion {
  /**
   * Whether the server can return nested value sets.
   */
  public hierarchical?: boolean|undefined;
  public _hierarchical?: fhir.FhirElement|undefined;
  /**
   * Allow request for incomplete expansions?
   */
  public incomplete?: boolean|undefined;
  public _incomplete?: fhir.FhirElement|undefined;
  /**
   * Whether the server supports paging on expansion.
   */
  public paging?: boolean|undefined;
  public _paging?: fhir.FhirElement|undefined;
  /**
   * Supported expansion parameter.
   */
  public parameter?: fhir.TerminologyCapabilitiesExpansionParameter[]|undefined;
  /**
   * This documentation should cover things like case sensitivity,  use of punctuation if not ignored, what wild cards are supported (if any), whether text is starts with or contains, and whether word order matters.
   */
  public textFilter?: string|undefined;
  public _textFilter?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesExpansion - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesExpansion> = {}) {
    super(source);
    if (source["hierarchical"]) { this.hierarchical = source.hierarchical; }
    if (source["_hierarchical"]) { this._hierarchical = new fhir.FhirElement(source._hierarchical!); }
    if (source["incomplete"]) { this.incomplete = source.incomplete; }
    if (source["_incomplete"]) { this._incomplete = new fhir.FhirElement(source._incomplete!); }
    if (source["paging"]) { this.paging = source.paging; }
    if (source["_paging"]) { this._paging = new fhir.FhirElement(source._paging!); }
    if (source["parameter"]) { this.parameter = source.parameter.map((x:Partial<fhir.ITerminologyCapabilitiesExpansionParameter>) => new fhir.TerminologyCapabilitiesExpansionParameter(x)); }
    if (source["textFilter"]) { this.textFilter = source.textFilter; }
    if (source["_textFilter"]) { this._textFilter = new fhir.FhirElement(source._textFilter!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesExpansion contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesExpansion from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesExpansion):TerminologyCapabilitiesExpansion {
    var dest:TerminologyCapabilitiesExpansion = new TerminologyCapabilitiesExpansion(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesExpansion is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
 */
export class TerminologyCapabilitiesValidateCode extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesValidateCode {
  /**
   * Whether translations are validated.
   */
  public translations: boolean|null;
  public _translations?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesValidateCode - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesValidateCode> = {}) {
    super(source);
    this.translations = null;
    if (source["translations"]) { this.translations = source.translations; }
    if (this.translations === undefined) { this.translations = null }
    if (source["_translations"]) { this._translations = new fhir.FhirElement(source._translations!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesValidateCode contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["translations"] === undefined) { missingElements.push("translations"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesValidateCode from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesValidateCode):TerminologyCapabilitiesValidateCode {
    var dest:TerminologyCapabilitiesValidateCode = new TerminologyCapabilitiesValidateCode(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesValidateCode is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
 */
export class TerminologyCapabilitiesTranslation extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesTranslation {
  /**
   * Whether the client must identify the map.
   */
  public needsMap: boolean|null;
  public _needsMap?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesTranslation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesTranslation> = {}) {
    super(source);
    this.needsMap = null;
    if (source["needsMap"]) { this.needsMap = source.needsMap; }
    if (this.needsMap === undefined) { this.needsMap = null }
    if (source["_needsMap"]) { this._needsMap = new fhir.FhirElement(source._needsMap!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesTranslation contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["needsMap"] === undefined) { missingElements.push("needsMap"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesTranslation from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesTranslation):TerminologyCapabilitiesTranslation {
    var dest:TerminologyCapabilitiesTranslation = new TerminologyCapabilitiesTranslation(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesTranslation is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Whether the $closure operation is supported.
 */
export class TerminologyCapabilitiesClosure extends fhir.BackboneElement implements fhir.ITerminologyCapabilitiesClosure {
  /**
   * If cross-system closure is supported.
   */
  public translation?: boolean|undefined;
  public _translation?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilitiesClosure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilitiesClosure> = {}) {
    super(source);
    if (source["translation"]) { this.translation = source.translation; }
    if (source["_translation"]) { this._translation = new fhir.FhirElement(source._translation!); }
  }
  /**
   * Check if the current TerminologyCapabilitiesClosure contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilitiesClosure from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilitiesClosure):TerminologyCapabilitiesClosure {
    var dest:TerminologyCapabilitiesClosure = new TerminologyCapabilitiesClosure(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilitiesClosure is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
 */
export class TerminologyCapabilities extends fhir.DomainResource implements fhir.ITerminologyCapabilities {
  /**
   * Resource Type Name
   */
  public override resourceType: "TerminologyCapabilities";
  /**
   * Whether the $closure operation is supported.
   */
  public closure?: fhir.TerminologyCapabilitiesClosure|undefined;
  /**
   * See notes on the [ValueSet](valueset.html#) resource.
   */
  public codeSearch?: TerminologyCapabilitiesCodeSearchEnum|undefined;
  public _codeSearch?: fhir.FhirElement|undefined;
  /**
   * The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
   */
  public codeSystem?: fhir.TerminologyCapabilitiesCodeSystem[]|undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  public contact?: fhir.ContactDetail[]|undefined;
  /**
   * A copyright statement relating to the terminology capabilities and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the terminology capabilities.
   */
  public copyright?: string|undefined;
  public _copyright?: fhir.FhirElement|undefined;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the terminology capabilities. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  public date: string|null;
  public _date?: fhir.FhirElement|undefined;
  /**
   * This description can be used to capture details such as why the terminology capabilities was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the terminology capabilities as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the terminology capabilities is presumed to be the predominant language in the place the terminology capabilities was created).This does not need to be populated if the description is adequately implied by the software or implementation details.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
   */
  public expansion?: fhir.TerminologyCapabilitiesExpansion|undefined;
  /**
   * Allows filtering of terminology capabilitiess that are appropriate for use versus not.
   */
  public experimental?: boolean|undefined;
  public _experimental?: fhir.FhirElement|undefined;
  /**
   * Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
   */
  public implementation?: fhir.TerminologyCapabilitiesImplementation|undefined;
  /**
   * It may be possible for the terminology capabilities to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  public jurisdiction?: fhir.CodeableConcept[]|undefined;
  /**
   * The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind, not instance of software) or a class of implementation (e.g. a desired purchase).
   */
  public kind: TerminologyCapabilitiesKindEnum|null;
  public _kind?: fhir.FhirElement|undefined;
  /**
   * Whether the server supports lockedDate.
   */
  public lockedDate?: boolean|undefined;
  public _lockedDate?: fhir.FhirElement|undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  public name?: string|undefined;
  public _name?: fhir.FhirElement|undefined;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the terminology capabilities is the organization or individual primarily responsible for the maintenance and upkeep of the terminology capabilities. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the terminology capabilities. This item SHOULD be populated unless the information is available from context.
   */
  public publisher?: string|undefined;
  public _publisher?: fhir.FhirElement|undefined;
  /**
   * This element does not describe the usage of the terminology capabilities. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this terminology capabilities.
   */
  public purpose?: string|undefined;
  public _purpose?: fhir.FhirElement|undefined;
  /**
   * Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
   */
  public software?: fhir.TerminologyCapabilitiesSoftware|undefined;
  /**
   * Allows filtering of terminology capabilitiess that are appropriate for use versus not.This is not intended for use with actual capability statements, but where capability statements are used to describe possible or desired systems.
   */
  public status: TerminologyCapabilitiesStatusEnum|null;
  public _status?: fhir.FhirElement|undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  public title?: string|undefined;
  public _title?: fhir.FhirElement|undefined;
  /**
   * Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
   */
  public translation?: fhir.TerminologyCapabilitiesTranslation|undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  public url?: string|undefined;
  public _url?: fhir.FhirElement|undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  public useContext?: fhir.UsageContext[]|undefined;
  /**
   * Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
   */
  public validateCode?: fhir.TerminologyCapabilitiesValidateCode|undefined;
  /**
   * There may be different terminology capabilities instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the terminology capabilities with the format [url]|[version].
   */
  public version?: string|undefined;
  public _version?: fhir.FhirElement|undefined;
  /**
   * Default constructor for TerminologyCapabilities - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ITerminologyCapabilities> = {}) {
    super(source);
    this.resourceType = 'TerminologyCapabilities';
    if (source["closure"]) { this.closure = new fhir.TerminologyCapabilitiesClosure(source.closure!); }
    if (source["codeSearch"]) { this.codeSearch = source.codeSearch; }
    if (source["_codeSearch"]) { this._codeSearch = new fhir.FhirElement(source._codeSearch!); }
    if (source["codeSystem"]) { this.codeSystem = source.codeSystem.map((x:Partial<fhir.ITerminologyCapabilitiesCodeSystem>) => new fhir.TerminologyCapabilitiesCodeSystem(x)); }
    if (source["contact"]) { this.contact = source.contact.map((x:Partial<fhir.IContactDetail>) => new fhir.ContactDetail(x)); }
    if (source["copyright"]) { this.copyright = source.copyright; }
    if (source["_copyright"]) { this._copyright = new fhir.FhirElement(source._copyright!); }
    this.date = null;
    if (source["date"]) { this.date = source.date; }
    if (this.date === undefined) { this.date = null }
    if (source["_date"]) { this._date = new fhir.FhirElement(source._date!); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["expansion"]) { this.expansion = new fhir.TerminologyCapabilitiesExpansion(source.expansion!); }
    if (source["experimental"]) { this.experimental = source.experimental; }
    if (source["_experimental"]) { this._experimental = new fhir.FhirElement(source._experimental!); }
    if (source["implementation"]) { this.implementation = new fhir.TerminologyCapabilitiesImplementation(source.implementation!); }
    if (source["jurisdiction"]) { this.jurisdiction = source.jurisdiction.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.kind = null;
    if (source["kind"]) { this.kind = source.kind; }
    if (this.kind === undefined) { this.kind = null }
    if (source["_kind"]) { this._kind = new fhir.FhirElement(source._kind!); }
    if (source["lockedDate"]) { this.lockedDate = source.lockedDate; }
    if (source["_lockedDate"]) { this._lockedDate = new fhir.FhirElement(source._lockedDate!); }
    if (source["name"]) { this.name = source.name; }
    if (source["_name"]) { this._name = new fhir.FhirElement(source._name!); }
    if (source["publisher"]) { this.publisher = source.publisher; }
    if (source["_publisher"]) { this._publisher = new fhir.FhirElement(source._publisher!); }
    if (source["purpose"]) { this.purpose = source.purpose; }
    if (source["_purpose"]) { this._purpose = new fhir.FhirElement(source._purpose!); }
    if (source["software"]) { this.software = new fhir.TerminologyCapabilitiesSoftware(source.software!); }
    this.status = null;
    if (source["status"]) { this.status = source.status; }
    if (this.status === undefined) { this.status = null }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["title"]) { this.title = source.title; }
    if (source["_title"]) { this._title = new fhir.FhirElement(source._title!); }
    if (source["translation"]) { this.translation = new fhir.TerminologyCapabilitiesTranslation(source.translation!); }
    if (source["url"]) { this.url = source.url; }
    if (source["_url"]) { this._url = new fhir.FhirElement(source._url!); }
    if (source["useContext"]) { this.useContext = source.useContext.map((x:Partial<fhir.IUsageContext>) => new fhir.UsageContext(x)); }
    if (source["validateCode"]) { this.validateCode = new fhir.TerminologyCapabilitiesValidateCode(source.validateCode!); }
    if (source["version"]) { this.version = source.version; }
    if (source["_version"]) { this._version = new fhir.FhirElement(source._version!); }
  }
  /**
   * Check if the current TerminologyCapabilities contains all required elements.
   */
  override checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["date"] === undefined) { missingElements.push("date"); }
    if (this["kind"] === undefined) { missingElements.push("kind"); }
    if (this["status"] === undefined) { missingElements.push("status"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a TerminologyCapabilities from an object that MUST contain all required elements.
   */
  static override fromStrict(source:fhir.ITerminologyCapabilities):TerminologyCapabilities {
    var dest:TerminologyCapabilities = new TerminologyCapabilities(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) { throw `TerminologyCapabilities is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the TerminologyCapabilities.codeSearch field
 */
export enum TerminologyCapabilitiesCodeSearchEnum {
  EXPLICIT = "explicit",
  ALL = "all",
}
/**
 * Code Values for the TerminologyCapabilities.kind field
 */
export enum TerminologyCapabilitiesKindEnum {
  INSTANCE = "instance",
  CAPABILITY = "capability",
  REQUIREMENTS = "requirements",
}
/**
 * Code Values for the TerminologyCapabilities.status field
 */
export enum TerminologyCapabilitiesStatusEnum {
  DRAFT = "draft",
  ACTIVE = "active",
  RETIRED = "retired",
  UNKNOWN = "unknown",
}
