// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Details concerning the specimen collection.
 */
export type ISpecimenCollection = fhir.IBackboneElement & {
  /**
   * If the use case requires  BodySite to be handled as a separate resource instead of an inline coded element (e.g. to identify and track separately)  then use the standard extension [bodySite](extension-bodysite.html).
   */
  bodySite?: fhir.ICodeableConcept|undefined;
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  collectedDateTime?: string|undefined;
  _collectedDateTime?: fhir.IFhirElement|undefined;
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  collectedPeriod?: fhir.IPeriod|undefined;
  /**
   * Person who collected the specimen.
   */
  collector?: fhir.IReference|undefined;
  /**
   * The span of time over which the collection of a specimen occurred.
   */
  duration?: fhir.IDuration|undefined;
  /**
   * Representing fasting status using this element is preferred to representing it with an observation using a 'pre-coordinated code'  such as  LOINC 2005-7 (Calcium [Moles/​time] in 2 hour Urine --12 hours fasting), or  using  a component observation ` such as `Observation.component code`  = LOINC 49541-6 (Fasting status - Reported).
   */
  fastingStatusCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Representing fasting status using this element is preferred to representing it with an observation using a 'pre-coordinated code'  such as  LOINC 2005-7 (Calcium [Moles/​time] in 2 hour Urine --12 hours fasting), or  using  a component observation ` such as `Observation.component code`  = LOINC 49541-6 (Fasting status - Reported).
   */
  fastingStatusDuration?: fhir.IDuration|undefined;
  /**
   * A coded value specifying the technique that is used to perform the procedure.
   */
  method?: fhir.ICodeableConcept|undefined;
  /**
   * The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
   */
  quantity?: fhir.IQuantity|undefined;
}
/**
 * Details concerning processing and processing steps for the specimen.
 */
export type ISpecimenProcessing = fhir.IBackboneElement & {
  /**
   * Material used in the processing step.
   */
  additive?: fhir.IReference[]|undefined;
  /**
   * Textual description of procedure.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * A coded value specifying the procedure used to process the specimen.
   */
  procedure?: fhir.ICodeableConcept|undefined;
  /**
   * A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
   */
  timeDateTime?: string|undefined;
  _timeDateTime?: fhir.IFhirElement|undefined;
  /**
   * A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
   */
  timePeriod?: fhir.IPeriod|undefined;
}
/**
 * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
 */
export type ISpecimenContainer = fhir.IBackboneElement & {
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  additiveReference?: fhir.IReference|undefined;
  /**
   * The capacity (volume or other measure) the container may contain.
   */
  capacity?: fhir.IQuantity|undefined;
  /**
   * Textual description of the container.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
   */
  specimenQuantity?: fhir.IQuantity|undefined;
  /**
   * The type of container associated with the specimen (e.g. slide, aliquot, etc.).
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * A sample to be used for analysis.
 */
export type ISpecimen = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "Specimen";
  /**
   * The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
   */
  accessionIdentifier?: fhir.IIdentifier|undefined;
  /**
   * Details concerning the specimen collection.
   */
  collection?: fhir.ISpecimenCollection|undefined;
  /**
   * Specimen condition is an observation made about the specimen.  It's a point-in-time assessment.  It can be used to assess its quality or appropriateness for a specific test.
   */
  condition?: fhir.ICodeableConcept[]|undefined;
  /**
   * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
   */
  container?: fhir.ISpecimenContainer[]|undefined;
  /**
   * Id for specimen.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * To communicate any details or issues about the specimen or during the specimen collection. (for example: broken vial, sent with patient, frozen).
   */
  note?: fhir.IAnnotation[]|undefined;
  /**
   * The parent specimen could be the source from which the current specimen is derived by some processing step (e.g. an aliquot or isolate or extracted nucleic acids from clinical samples) or one of many specimens that were combined to create a pooled sample.
   */
  parent?: fhir.IReference[]|undefined;
  /**
   * Details concerning processing and processing steps for the specimen.
   */
  processing?: fhir.ISpecimenProcessing[]|undefined;
  /**
   * Time when specimen was received for processing or testing.
   */
  receivedTime?: string|undefined;
  _receivedTime?: fhir.IFhirElement|undefined;
  /**
   * The request may be explicit or implied such with a ServiceRequest that requires a blood draw.
   */
  request?: fhir.IReference[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  status?: SpecimenStatusEnum|undefined;
  _status?: fhir.IFhirElement|undefined;
  /**
   * Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device.
   */
  subject?: fhir.IReference|undefined;
  /**
   * The type can change the way that a specimen is handled and drives what kind of analyses can properly be performed on the specimen. It is frequently used in diagnostic work flow decision making systems.
   */
  type?: fhir.ICodeableConcept|undefined;
}
/**
 * Details concerning the specimen collection.
 */
export class SpecimenCollection extends fhir.BackboneElement implements fhir.ISpecimenCollection {
  /**
   * If the use case requires  BodySite to be handled as a separate resource instead of an inline coded element (e.g. to identify and track separately)  then use the standard extension [bodySite](extension-bodysite.html).
   */
  public bodySite?: fhir.CodeableConcept|undefined;
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  public collectedDateTime?: string|undefined;
  public _collectedDateTime?: fhir.FhirElement|undefined;
  /**
   * Time when specimen was collected from subject - the physiologically relevant time.
   */
  public collectedPeriod?: fhir.Period|undefined;
  /**
   * Person who collected the specimen.
   */
  public collector?: fhir.Reference|undefined;
  /**
   * The span of time over which the collection of a specimen occurred.
   */
  public duration?: fhir.Duration|undefined;
  /**
   * Representing fasting status using this element is preferred to representing it with an observation using a 'pre-coordinated code'  such as  LOINC 2005-7 (Calcium [Moles/​time] in 2 hour Urine --12 hours fasting), or  using  a component observation ` such as `Observation.component code`  = LOINC 49541-6 (Fasting status - Reported).
   */
  public fastingStatusCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Representing fasting status using this element is preferred to representing it with an observation using a 'pre-coordinated code'  such as  LOINC 2005-7 (Calcium [Moles/​time] in 2 hour Urine --12 hours fasting), or  using  a component observation ` such as `Observation.component code`  = LOINC 49541-6 (Fasting status - Reported).
   */
  public fastingStatusDuration?: fhir.Duration|undefined;
  /**
   * A coded value specifying the technique that is used to perform the procedure.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * Default constructor for SpecimenCollection - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenCollection> = {}) {
    super(source);
    if (source["bodySite"]) { this.bodySite = new fhir.CodeableConcept(source.bodySite!); }
    if (source["collectedDateTime"]) { this.collectedDateTime = source.collectedDateTime; }
    if (source["_collectedDateTime"]) { this._collectedDateTime = new fhir.FhirElement(source._collectedDateTime!); }
    if (source["collectedPeriod"]) { this.collectedPeriod = new fhir.Period(source.collectedPeriod!); }
    if (source["collector"]) { this.collector = new fhir.Reference(source.collector!); }
    if (source["duration"]) { this.duration = new fhir.Duration(source.duration!); }
    if (source["fastingStatusCodeableConcept"]) { this.fastingStatusCodeableConcept = new fhir.CodeableConcept(source.fastingStatusCodeableConcept!); }
    if (source["fastingStatusDuration"]) { this.fastingStatusDuration = new fhir.Duration(source.fastingStatusDuration!); }
    if (source["method"]) { this.method = new fhir.CodeableConcept(source.method!); }
    if (source["quantity"]) { this.quantity = new fhir.Quantity(source.quantity!); }
  }
  /**
   * Check if the current SpecimenCollection contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenCollection from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenCollection):SpecimenCollection {
    var dest:SpecimenCollection = new SpecimenCollection(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenCollection is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Details concerning processing and processing steps for the specimen.
 */
export class SpecimenProcessing extends fhir.BackboneElement implements fhir.ISpecimenProcessing {
  /**
   * Material used in the processing step.
   */
  public additive?: fhir.Reference[]|undefined;
  /**
   * Textual description of procedure.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * A coded value specifying the procedure used to process the specimen.
   */
  public procedure?: fhir.CodeableConcept|undefined;
  /**
   * A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
   */
  public timeDateTime?: string|undefined;
  public _timeDateTime?: fhir.FhirElement|undefined;
  /**
   * A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
   */
  public timePeriod?: fhir.Period|undefined;
  /**
   * Default constructor for SpecimenProcessing - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenProcessing> = {}) {
    super(source);
    if (source["additive"]) { this.additive = source.additive.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["procedure"]) { this.procedure = new fhir.CodeableConcept(source.procedure!); }
    if (source["timeDateTime"]) { this.timeDateTime = source.timeDateTime; }
    if (source["_timeDateTime"]) { this._timeDateTime = new fhir.FhirElement(source._timeDateTime!); }
    if (source["timePeriod"]) { this.timePeriod = new fhir.Period(source.timePeriod!); }
  }
  /**
   * Check if the current SpecimenProcessing contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenProcessing from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenProcessing):SpecimenProcessing {
    var dest:SpecimenProcessing = new SpecimenProcessing(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenProcessing is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
 */
export class SpecimenContainer extends fhir.BackboneElement implements fhir.ISpecimenContainer {
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  public additiveCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
   */
  public additiveReference?: fhir.Reference|undefined;
  /**
   * The capacity (volume or other measure) the container may contain.
   */
  public capacity?: fhir.Quantity|undefined;
  /**
   * Textual description of the container.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
   */
  public specimenQuantity?: fhir.Quantity|undefined;
  /**
   * The type of container associated with the specimen (e.g. slide, aliquot, etc.).
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for SpecimenContainer - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimenContainer> = {}) {
    super(source);
    if (source["additiveCodeableConcept"]) { this.additiveCodeableConcept = new fhir.CodeableConcept(source.additiveCodeableConcept!); }
    if (source["additiveReference"]) { this.additiveReference = new fhir.Reference(source.additiveReference!); }
    if (source["capacity"]) { this.capacity = new fhir.Quantity(source.capacity!); }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["specimenQuantity"]) { this.specimenQuantity = new fhir.Quantity(source.specimenQuantity!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current SpecimenContainer contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SpecimenContainer from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimenContainer):SpecimenContainer {
    var dest:SpecimenContainer = new SpecimenContainer(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SpecimenContainer is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A sample to be used for analysis.
 */
export class Specimen extends fhir.DomainResource implements fhir.ISpecimen {
  /**
   * Resource Type Name
   */
  public override resourceType: "Specimen";
  /**
   * The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
   */
  public accessionIdentifier?: fhir.Identifier|undefined;
  /**
   * Details concerning the specimen collection.
   */
  public collection?: fhir.SpecimenCollection|undefined;
  /**
   * Specimen condition is an observation made about the specimen.  It's a point-in-time assessment.  It can be used to assess its quality or appropriateness for a specific test.
   */
  public condition?: fhir.CodeableConcept[]|undefined;
  /**
   * The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
   */
  public container?: fhir.SpecimenContainer[]|undefined;
  /**
   * Id for specimen.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * To communicate any details or issues about the specimen or during the specimen collection. (for example: broken vial, sent with patient, frozen).
   */
  public note?: fhir.Annotation[]|undefined;
  /**
   * The parent specimen could be the source from which the current specimen is derived by some processing step (e.g. an aliquot or isolate or extracted nucleic acids from clinical samples) or one of many specimens that were combined to create a pooled sample.
   */
  public parent?: fhir.Reference[]|undefined;
  /**
   * Details concerning processing and processing steps for the specimen.
   */
  public processing?: fhir.SpecimenProcessing[]|undefined;
  /**
   * Time when specimen was received for processing or testing.
   */
  public receivedTime?: string|undefined;
  public _receivedTime?: fhir.FhirElement|undefined;
  /**
   * The request may be explicit or implied such with a ServiceRequest that requires a blood draw.
   */
  public request?: fhir.Reference[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  public status?: SpecimenStatusEnum|undefined;
  public _status?: fhir.FhirElement|undefined;
  /**
   * Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device.
   */
  public subject?: fhir.Reference|undefined;
  /**
   * The type can change the way that a specimen is handled and drives what kind of analyses can properly be performed on the specimen. It is frequently used in diagnostic work flow decision making systems.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Default constructor for Specimen - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISpecimen> = {}) {
    super(source);
    this.resourceType = 'Specimen';
    if (source["accessionIdentifier"]) { this.accessionIdentifier = new fhir.Identifier(source.accessionIdentifier!); }
    if (source["collection"]) { this.collection = new fhir.SpecimenCollection(source.collection!); }
    if (source["condition"]) { this.condition = source.condition.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    if (source["container"]) { this.container = source.container.map((x:Partial<fhir.ISpecimenContainer>) => new fhir.SpecimenContainer(x)); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["note"]) { this.note = source.note.map((x:Partial<fhir.IAnnotation>) => new fhir.Annotation(x)); }
    if (source["parent"]) { this.parent = source.parent.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["processing"]) { this.processing = source.processing.map((x:Partial<fhir.ISpecimenProcessing>) => new fhir.SpecimenProcessing(x)); }
    if (source["receivedTime"]) { this.receivedTime = source.receivedTime; }
    if (source["_receivedTime"]) { this._receivedTime = new fhir.FhirElement(source._receivedTime!); }
    if (source["request"]) { this.request = source.request.map((x:Partial<fhir.IReference>) => new fhir.Reference(x)); }
    if (source["status"]) { this.status = source.status; }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
    if (source["subject"]) { this.subject = new fhir.Reference(source.subject!); }
    if (source["type"]) { this.type = new fhir.CodeableConcept(source.type!); }
  }
  /**
   * Check if the current Specimen contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Specimen from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISpecimen):Specimen {
    var dest:Specimen = new Specimen(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `Specimen is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the Specimen.status field
 */
export enum SpecimenStatusEnum {
  AVAILABLE = "available",
  UNAVAILABLE = "unavailable",
  UNSATISFACTORY = "unsatisfactory",
  ENTERED_IN_ERROR = "entered-in-error",
}
