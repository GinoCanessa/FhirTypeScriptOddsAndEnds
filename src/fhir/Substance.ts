// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhir from '../fhir'
/**
 * Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
 */
export type ISubstanceInstance = fhir.IBackboneElement & {
  /**
   * When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
   */
  expiry?: string|undefined;
  _expiry?: fhir.IFhirElement|undefined;
  /**
   * Identifier associated with the package/container (usually a label affixed directly).
   */
  identifier?: fhir.IIdentifier|undefined;
  /**
   * The amount of the substance.
   */
  quantity?: fhir.IQuantity|undefined;
}
/**
 * A substance can be composed of other substances.
 */
export type ISubstanceIngredient = fhir.IBackboneElement & {
  /**
   * The amount of the ingredient in the substance - a concentration ratio.
   */
  quantity?: fhir.IRatio|undefined;
  /**
   * Another substance that is a component of this substance.
   */
  substanceCodeableConcept?: fhir.ICodeableConcept|undefined;
  /**
   * Another substance that is a component of this substance.
   */
  substanceReference?: fhir.IReference|undefined;
}
/**
 * A homogeneous material with a definite composition.
 */
export type ISubstance = fhir.IDomainResource & {
  /**
   * Resource Type Name
   */
  resourceType: "Substance";
  /**
   * The level of granularity is defined by the category concepts in the value set.   More fine-grained filtering can be performed using the metadata and/or terminology hierarchy in Substance.code.
   */
  category?: fhir.ICodeableConcept[]|undefined;
  /**
   * This could be a reference to an externally defined code.  It could also be a locally assigned code (e.g. a formulary),  optionally with translations to the standard drug codes.
   */
  code: fhir.ICodeableConcept|null;
  /**
   * A description of the substance - its appearance, handling requirements, and other usage notes.
   */
  description?: string|undefined;
  _description?: fhir.IFhirElement|undefined;
  /**
   * This identifier is associated with the kind of substance in contrast to the  Substance.instance.identifier which is associated with the package/container.
   */
  identifier?: fhir.IIdentifier[]|undefined;
  /**
   * A substance can be composed of other substances.
   */
  ingredient?: fhir.ISubstanceIngredient[]|undefined;
  /**
   * Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
   */
  instance?: fhir.ISubstanceInstance[]|undefined;
  /**
   * A code to indicate if the substance is actively used.
   */
  status?: SubstanceStatusEnum|undefined;
  _status?: fhir.IFhirElement|undefined;
}
/**
 * Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
 */
export class SubstanceInstance extends fhir.BackboneElement implements fhir.ISubstanceInstance {
  /**
   * When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
   */
  public expiry?: string|undefined;
  public _expiry?: fhir.FhirElement|undefined;
  /**
   * Identifier associated with the package/container (usually a label affixed directly).
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * The amount of the substance.
   */
  public quantity?: fhir.Quantity|undefined;
  /**
   * Default constructor for SubstanceInstance - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceInstance> = {}) {
    super(source);
    if (source["expiry"]) { this.expiry = source.expiry; }
    if (source["_expiry"]) { this._expiry = new fhir.FhirElement(source._expiry!); }
    if (source["identifier"]) { this.identifier = new fhir.Identifier(source.identifier!); }
    if (source["quantity"]) { this.quantity = new fhir.Quantity(source.quantity!); }
  }
  /**
   * Check if the current SubstanceInstance contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceInstance from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceInstance):SubstanceInstance {
    var dest:SubstanceInstance = new SubstanceInstance(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceInstance is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A substance can be composed of other substances.
 */
export class SubstanceIngredient extends fhir.BackboneElement implements fhir.ISubstanceIngredient {
  /**
   * The amount of the ingredient in the substance - a concentration ratio.
   */
  public quantity?: fhir.Ratio|undefined;
  /**
   * Another substance that is a component of this substance.
   */
  public substanceCodeableConcept?: fhir.CodeableConcept|undefined;
  /**
   * Another substance that is a component of this substance.
   */
  public substanceReference?: fhir.Reference|undefined;
  /**
   * Default constructor for SubstanceIngredient - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstanceIngredient> = {}) {
    super(source);
    if (source["quantity"]) { this.quantity = new fhir.Ratio(source.quantity!); }
    if (source["substanceCodeableConcept"]) { this.substanceCodeableConcept = new fhir.CodeableConcept(source.substanceCodeableConcept!); }
    if (source["substanceReference"]) { this.substanceReference = new fhir.Reference(source.substanceReference!); }
  }
  /**
   * Check if the current SubstanceIngredient contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SubstanceIngredient from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstanceIngredient):SubstanceIngredient {
    var dest:SubstanceIngredient = new SubstanceIngredient(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `SubstanceIngredient is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * A homogeneous material with a definite composition.
 */
export class Substance extends fhir.DomainResource implements fhir.ISubstance {
  /**
   * Resource Type Name
   */
  public override resourceType: "Substance";
  /**
   * The level of granularity is defined by the category concepts in the value set.   More fine-grained filtering can be performed using the metadata and/or terminology hierarchy in Substance.code.
   */
  public category?: fhir.CodeableConcept[]|undefined;
  /**
   * This could be a reference to an externally defined code.  It could also be a locally assigned code (e.g. a formulary),  optionally with translations to the standard drug codes.
   */
  public code: fhir.CodeableConcept|null;
  /**
   * A description of the substance - its appearance, handling requirements, and other usage notes.
   */
  public description?: string|undefined;
  public _description?: fhir.FhirElement|undefined;
  /**
   * This identifier is associated with the kind of substance in contrast to the  Substance.instance.identifier which is associated with the package/container.
   */
  public identifier?: fhir.Identifier[]|undefined;
  /**
   * A substance can be composed of other substances.
   */
  public ingredient?: fhir.SubstanceIngredient[]|undefined;
  /**
   * Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
   */
  public instance?: fhir.SubstanceInstance[]|undefined;
  /**
   * A code to indicate if the substance is actively used.
   */
  public status?: SubstanceStatusEnum|undefined;
  public _status?: fhir.FhirElement|undefined;
  /**
   * Default constructor for Substance - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<fhir.ISubstance> = {}) {
    super(source);
    this.resourceType = 'Substance';
    if (source["category"]) { this.category = source.category.map((x:Partial<fhir.ICodeableConcept>) => new fhir.CodeableConcept(x)); }
    this.code = null;
    if (source["code"]) { this.code = new fhir.CodeableConcept(source.code!); }
    if (this.code === undefined) { this.code = null }
    if (source["description"]) { this.description = source.description; }
    if (source["_description"]) { this._description = new fhir.FhirElement(source._description!); }
    if (source["identifier"]) { this.identifier = source.identifier.map((x:Partial<fhir.IIdentifier>) => new fhir.Identifier(x)); }
    if (source["ingredient"]) { this.ingredient = source.ingredient.map((x:Partial<fhir.ISubstanceIngredient>) => new fhir.SubstanceIngredient(x)); }
    if (source["instance"]) { this.instance = source.instance.map((x:Partial<fhir.ISubstanceInstance>) => new fhir.SubstanceInstance(x)); }
    if (source["status"]) { this.status = source.status; }
    if (source["_status"]) { this._status = new fhir.FhirElement(source._status!); }
  }
  /**
   * Check if the current Substance contains all required elements.
   */
  override CheckRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    var parentMissing:string[] = super.CheckRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a Substance from an object that MUST contain all required elements.
   */
  static override FromStrict(source:fhir.ISubstance):Substance {
    var dest:Substance = new Substance(source);
    var missingElements:string[] = dest.CheckRequiredElements();
    if (missingElements.length !== 0) { throw `Substance is missing elements: ${missingElements.join(", ")}` }
    return dest;
  }
}
/**
 * Code Values for the Substance.status field
 */
export enum SubstanceStatusEnum {
  ACTIVE = "active",
  INACTIVE = "inactive",
  ENTERED_IN_ERROR = "entered-in-error",
}
