// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR ComplexType: Signature

import * as fhir from '../fhir.js'

import { SignatureTypeValueSet, SignatureTypeValueSetType, SignatureTypeValueSetEnum } from '../fhirValueSets/SignatureTypeValueSet.js'

/**
 * A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 */
export type ISignature = fhir.IFhirElement & { 
  /**
   * Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &amp;quot;Commitment Type Indication&amp;quot;.
   */
  type: fhir.ICoding[]|null;
  /**
   * This should agree with the information in the signature.
   */
  when: string|null;
  /**
   * Extended properties for primitive element: Signature.when
   */
  _when?: fhir.IFhirElement|undefined;
  /**
   * This should agree with the information in the signature.
   */
  who: fhir.IReference|null;
  /**
   * The party that can't sign. For example a child.
   */
  onBehalfOf?: fhir.IReference|undefined;
  /**
   * "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   */
  targetFormat?: string|undefined;
  /**
   * Extended properties for primitive element: Signature.targetFormat
   */
  _targetFormat?: fhir.IFhirElement|undefined;
  /**
   * A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   */
  sigFormat?: string|undefined;
  /**
   * Extended properties for primitive element: Signature.sigFormat
   */
  _sigFormat?: fhir.IFhirElement|undefined;
  /**
   * Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   */
  data?: string|undefined;
  /**
   * Extended properties for primitive element: Signature.data
   */
  _data?: fhir.IFhirElement|undefined;
}

/**
 * A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 */
export class Signature extends fhir.FhirElement implements ISignature {
  /**
   * Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &amp;quot;Commitment Type Indication&amp;quot;.
   */
  public type: fhir.Coding[]|null;
  /**
   * This should agree with the information in the signature.
   */
  public when: string|null;
  /**
   * Extended properties for primitive element: Signature.when
   */
  public _when?: fhir.FhirElement|undefined;
  /**
   * This should agree with the information in the signature.
   */
  public who: fhir.Reference|null;
  /**
   * The party that can't sign. For example a child.
   */
  public onBehalfOf?: fhir.Reference|undefined;
  /**
   * "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   */
  public targetFormat?: string|undefined;
  /**
   * Extended properties for primitive element: Signature.targetFormat
   */
  public _targetFormat?: fhir.FhirElement|undefined;
  /**
   * A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   */
  public sigFormat?: string|undefined;
  /**
   * Extended properties for primitive element: Signature.sigFormat
   */
  public _sigFormat?: fhir.FhirElement|undefined;
  /**
   * Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   */
  public data?: string|undefined;
  /**
   * Extended properties for primitive element: Signature.data
   */
  public _data?: fhir.FhirElement|undefined;
  /**
   * Default constructor for Signature - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<ISignature> = { }) {
    super(source);
    if (source['type']) { this.type = source.type.map((x) => new fhir.Coding(x)); }
    else { this.type = null; }
    if (source['when']) { this.when = source.when; }
    else { this.when = null; }
    if (source['_when']) { this._when = new fhir.FhirElement(source._when!); }
    if (source['who']) { this.who = new fhir.Reference(source.who!); }
    else { this.who = null; }
    if (source['onBehalfOf']) { this.onBehalfOf = new fhir.Reference(source.onBehalfOf!); }
    if (source['targetFormat']) { this.targetFormat = source.targetFormat; }
    if (source['_targetFormat']) { this._targetFormat = new fhir.FhirElement(source._targetFormat!); }
    if (source['sigFormat']) { this.sigFormat = source.sigFormat; }
    if (source['_sigFormat']) { this._sigFormat = new fhir.FhirElement(source._sigFormat!); }
    if (source['data']) { this.data = source.data; }
    if (source['_data']) { this._data = new fhir.FhirElement(source._data!); }
  }
  /**
   * Preferred-bound Value Set for type
   */
  public typePreferredValueSet():SignatureTypeValueSetType {
    return SignatureTypeValueSet;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():[string,string][] {
    var results:[string,string][] = super.doModelValidation();
    if ((!this["type"]) || (this["type"].length === 0)) { results.push(["type",'Missing required element: Signature.type']); }
    if (this["type"]) { this.type.forEach((x) => { results.push(...x.doModelValidation()); }) }
    if (!this["when"]) { results.push(["when",'Missing required element: Signature.when']); }
    if (this["_when"]) { results.push(...this._when.doModelValidation()); }
    if (!this["who"]) { results.push(["who",'Missing required element: Signature.who']); }
    if (this["who"]) { results.push(...this.who.doModelValidation()); }
    if (this["onBehalfOf"]) { results.push(...this.onBehalfOf.doModelValidation()); }
    if (this["_targetFormat"]) { results.push(...this._targetFormat.doModelValidation()); }
    if (this["_sigFormat"]) { results.push(...this._sigFormat.doModelValidation()); }
    if (this["_data"]) { results.push(...this._data.doModelValidation()); }
    return results;
  }
}
