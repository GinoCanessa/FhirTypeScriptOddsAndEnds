// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../models'
/**
 * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
 */
export class StructureMapStructure extends fhirModels.BackboneElement {
  /**
   * This is needed if both types have the same name (e.g. version conversion).
   */
  alias?: string;
  _alias?: fhirModels.Element;
  /**
   * Documentation that describes how the structure is used in the mapping.
   */
  documentation?: string;
  _documentation?: fhirModels.Element;
  /**
   * How the referenced structure is used in this mapping.
   */
  mode: StructureMapStructureModeEnum;
  _mode?: fhirModels.Element;
  /**
   * The canonical reference to the structure.
   */
  url: string;
  _url?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMapStructure) {
    super(source);
    if (source["alias"] !== undefined) { this.alias = source.alias; }
    if (source["_alias"] !== undefined) { this._alias = source._alias; }
    if (source["documentation"] !== undefined) { this.documentation = source.documentation; }
    if (source["_documentation"] !== undefined) { this._documentation = source._documentation; }
    if (source["mode"] === undefined) { throw 'Missing required element mode';}
    this.mode = source.mode;
    if (source["_mode"] !== undefined) { this._mode = source._mode; }
    if (source["url"] === undefined) { throw 'Missing required element url';}
    this.url = source.url;
    if (source["_url"] !== undefined) { this._url = source._url; }
  }
}
/**
 * Code Values for the StructureMap.structure.mode field
 */
export enum StructureMapStructureModeEnum {
  SOURCE = "source",
  QUERIED = "queried",
  TARGET = "target",
  PRODUCED = "produced",
}
/**
 * If no inputs are named, then the entry mappings are type based.
 */
export class StructureMapGroupInput extends fhirModels.BackboneElement {
  /**
   * Documentation for this instance of data.
   */
  documentation?: string;
  _documentation?: fhirModels.Element;
  /**
   * Mode for this instance of data.
   */
  mode: StructureMapGroupInputModeEnum;
  _mode?: fhirModels.Element;
  /**
   * Name for this instance of data.
   */
  name: string;
  _name?: fhirModels.Element;
  /**
   * Type for this instance of data.
   */
  type?: string;
  _type?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroupInput) {
    super(source);
    if (source["documentation"] !== undefined) { this.documentation = source.documentation; }
    if (source["_documentation"] !== undefined) { this._documentation = source._documentation; }
    if (source["mode"] === undefined) { throw 'Missing required element mode';}
    this.mode = source.mode;
    if (source["_mode"] !== undefined) { this._mode = source._mode; }
    if (source["name"] === undefined) { throw 'Missing required element name';}
    this.name = source.name;
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["type"] !== undefined) { this.type = source.type; }
    if (source["_type"] !== undefined) { this._type = source._type; }
  }
}
/**
 * Code Values for the StructureMap.group.input.mode field
 */
export enum StructureMapGroupInputModeEnum {
  SOURCE = "source",
  TARGET = "target",
}
/**
 * Source inputs to the mapping.
 */
export class StructureMapGroupRuleSource extends fhirModels.BackboneElement {
  /**
   * FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
   */
  check?: string;
  _check?: fhirModels.Element;
  /**
   * FHIRPath expression  - must be true or the rule does not apply.
   */
  condition?: string;
  _condition?: fhirModels.Element;
  /**
   * Type or variable this rule applies to.
   */
  context: string;
  _context?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueBase64Binary?: string;
  _defaultValueBase64Binary?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueBoolean?: boolean;
  _defaultValueBoolean?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCanonical?: string;
  _defaultValueCanonical?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCode?: string;
  _defaultValueCode?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDate?: string;
  _defaultValueDate?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDateTime?: string;
  _defaultValueDateTime?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDecimal?: number;
  _defaultValueDecimal?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueId?: string;
  _defaultValueId?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueInstant?: string;
  _defaultValueInstant?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueInteger?: number;
  _defaultValueInteger?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueMarkdown?: string;
  _defaultValueMarkdown?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueOid?: string;
  _defaultValueOid?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValuePositiveInt?: number;
  _defaultValuePositiveInt?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueString?: string;
  _defaultValueString?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueTime?: string;
  _defaultValueTime?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUnsignedInt?: number;
  _defaultValueUnsignedInt?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUri?: string;
  _defaultValueUri?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUrl?: string;
  _defaultValueUrl?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUuid?: string;
  _defaultValueUuid?: fhirModels.Element;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAddress?: fhirModels.Address;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAge?: fhirModels.Age;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAnnotation?: fhirModels.Annotation;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueAttachment?: fhirModels.Attachment;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCodeableConcept?: fhirModels.CodeableConcept;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCoding?: fhirModels.Coding;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueContactPoint?: fhirModels.ContactPoint;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueCount?: fhirModels.Count;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDistance?: fhirModels.Distance;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDuration?: fhirModels.Duration;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueHumanName?: fhirModels.HumanName;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueIdentifier?: fhirModels.Identifier;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueMoney?: fhirModels.Money;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValuePeriod?: fhirModels.Period;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueQuantity?: fhirModels.Quantity;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueRange?: fhirModels.Range;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueRatio?: fhirModels.Ratio;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueReference?: fhirModels.Reference;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueSampledData?: fhirModels.SampledData;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueSignature?: fhirModels.Signature;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueTiming?: fhirModels.Timing;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueContactDetail?: fhirModels.ContactDetail;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueContributor?: fhirModels.Contributor;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDataRequirement?: fhirModels.DataRequirement;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueExpression?: fhirModels.Expression;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueParameterDefinition?: fhirModels.ParameterDefinition;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueRelatedArtifact?: fhirModels.RelatedArtifact;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueTriggerDefinition?: fhirModels.TriggerDefinition;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueUsageContext?: fhirModels.UsageContext;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueDosage?: fhirModels.Dosage;
  /**
   * If there's a default value on an item that can repeat, it will only be used once.
   */
  defaultValueMeta?: fhirModels.Meta;
  /**
   * Optional field for this source.
   */
  element?: string;
  _element?: fhirModels.Element;
  /**
   * How to handle the list mode for this element.
   */
  listMode?: StructureMapGroupRuleSourceListModeEnum;
  _listMode?: fhirModels.Element;
  /**
   * This is typically used for recording that something Is not transformed to the target for some reason.
   */
  logMessage?: string;
  _logMessage?: fhirModels.Element;
  /**
   * Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
   */
  max?: string;
  _max?: fhirModels.Element;
  /**
   * Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
   */
  min?: number;
  _min?: fhirModels.Element;
  /**
   * Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
   */
  type?: string;
  _type?: fhirModels.Element;
  /**
   * Named context for field, if a field is specified.
   */
  variable?: string;
  _variable?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroupRuleSource) {
    super(source);
    if (source["check"] !== undefined) { this.check = source.check; }
    if (source["_check"] !== undefined) { this._check = source._check; }
    if (source["condition"] !== undefined) { this.condition = source.condition; }
    if (source["_condition"] !== undefined) { this._condition = source._condition; }
    if (source["context"] === undefined) { throw 'Missing required element context';}
    this.context = source.context;
    if (source["_context"] !== undefined) { this._context = source._context; }
    if (source["defaultValueBase64Binary"] !== undefined) { this.defaultValueBase64Binary = source.defaultValueBase64Binary; }
    if (source["_defaultValueBase64Binary"] !== undefined) { this._defaultValueBase64Binary = source._defaultValueBase64Binary; }
    if (source["defaultValueBoolean"] !== undefined) { this.defaultValueBoolean = source.defaultValueBoolean; }
    if (source["_defaultValueBoolean"] !== undefined) { this._defaultValueBoolean = source._defaultValueBoolean; }
    if (source["defaultValueCanonical"] !== undefined) { this.defaultValueCanonical = source.defaultValueCanonical; }
    if (source["_defaultValueCanonical"] !== undefined) { this._defaultValueCanonical = source._defaultValueCanonical; }
    if (source["defaultValueCode"] !== undefined) { this.defaultValueCode = source.defaultValueCode; }
    if (source["_defaultValueCode"] !== undefined) { this._defaultValueCode = source._defaultValueCode; }
    if (source["defaultValueDate"] !== undefined) { this.defaultValueDate = source.defaultValueDate; }
    if (source["_defaultValueDate"] !== undefined) { this._defaultValueDate = source._defaultValueDate; }
    if (source["defaultValueDateTime"] !== undefined) { this.defaultValueDateTime = source.defaultValueDateTime; }
    if (source["_defaultValueDateTime"] !== undefined) { this._defaultValueDateTime = source._defaultValueDateTime; }
    if (source["defaultValueDecimal"] !== undefined) { this.defaultValueDecimal = source.defaultValueDecimal; }
    if (source["_defaultValueDecimal"] !== undefined) { this._defaultValueDecimal = source._defaultValueDecimal; }
    if (source["defaultValueId"] !== undefined) { this.defaultValueId = source.defaultValueId; }
    if (source["_defaultValueId"] !== undefined) { this._defaultValueId = source._defaultValueId; }
    if (source["defaultValueInstant"] !== undefined) { this.defaultValueInstant = source.defaultValueInstant; }
    if (source["_defaultValueInstant"] !== undefined) { this._defaultValueInstant = source._defaultValueInstant; }
    if (source["defaultValueInteger"] !== undefined) { this.defaultValueInteger = source.defaultValueInteger; }
    if (source["_defaultValueInteger"] !== undefined) { this._defaultValueInteger = source._defaultValueInteger; }
    if (source["defaultValueMarkdown"] !== undefined) { this.defaultValueMarkdown = source.defaultValueMarkdown; }
    if (source["_defaultValueMarkdown"] !== undefined) { this._defaultValueMarkdown = source._defaultValueMarkdown; }
    if (source["defaultValueOid"] !== undefined) { this.defaultValueOid = source.defaultValueOid; }
    if (source["_defaultValueOid"] !== undefined) { this._defaultValueOid = source._defaultValueOid; }
    if (source["defaultValuePositiveInt"] !== undefined) { this.defaultValuePositiveInt = source.defaultValuePositiveInt; }
    if (source["_defaultValuePositiveInt"] !== undefined) { this._defaultValuePositiveInt = source._defaultValuePositiveInt; }
    if (source["defaultValueString"] !== undefined) { this.defaultValueString = source.defaultValueString; }
    if (source["_defaultValueString"] !== undefined) { this._defaultValueString = source._defaultValueString; }
    if (source["defaultValueTime"] !== undefined) { this.defaultValueTime = source.defaultValueTime; }
    if (source["_defaultValueTime"] !== undefined) { this._defaultValueTime = source._defaultValueTime; }
    if (source["defaultValueUnsignedInt"] !== undefined) { this.defaultValueUnsignedInt = source.defaultValueUnsignedInt; }
    if (source["_defaultValueUnsignedInt"] !== undefined) { this._defaultValueUnsignedInt = source._defaultValueUnsignedInt; }
    if (source["defaultValueUri"] !== undefined) { this.defaultValueUri = source.defaultValueUri; }
    if (source["_defaultValueUri"] !== undefined) { this._defaultValueUri = source._defaultValueUri; }
    if (source["defaultValueUrl"] !== undefined) { this.defaultValueUrl = source.defaultValueUrl; }
    if (source["_defaultValueUrl"] !== undefined) { this._defaultValueUrl = source._defaultValueUrl; }
    if (source["defaultValueUuid"] !== undefined) { this.defaultValueUuid = source.defaultValueUuid; }
    if (source["_defaultValueUuid"] !== undefined) { this._defaultValueUuid = source._defaultValueUuid; }
    if (source["defaultValueAddress"] !== undefined) { this.defaultValueAddress = source.defaultValueAddress; }
    if (source["defaultValueAge"] !== undefined) { this.defaultValueAge = source.defaultValueAge; }
    if (source["defaultValueAnnotation"] !== undefined) { this.defaultValueAnnotation = source.defaultValueAnnotation; }
    if (source["defaultValueAttachment"] !== undefined) { this.defaultValueAttachment = source.defaultValueAttachment; }
    if (source["defaultValueCodeableConcept"] !== undefined) { this.defaultValueCodeableConcept = source.defaultValueCodeableConcept; }
    if (source["defaultValueCoding"] !== undefined) { this.defaultValueCoding = source.defaultValueCoding; }
    if (source["defaultValueContactPoint"] !== undefined) { this.defaultValueContactPoint = source.defaultValueContactPoint; }
    if (source["defaultValueCount"] !== undefined) { this.defaultValueCount = source.defaultValueCount; }
    if (source["defaultValueDistance"] !== undefined) { this.defaultValueDistance = source.defaultValueDistance; }
    if (source["defaultValueDuration"] !== undefined) { this.defaultValueDuration = source.defaultValueDuration; }
    if (source["defaultValueHumanName"] !== undefined) { this.defaultValueHumanName = source.defaultValueHumanName; }
    if (source["defaultValueIdentifier"] !== undefined) { this.defaultValueIdentifier = source.defaultValueIdentifier; }
    if (source["defaultValueMoney"] !== undefined) { this.defaultValueMoney = source.defaultValueMoney; }
    if (source["defaultValuePeriod"] !== undefined) { this.defaultValuePeriod = source.defaultValuePeriod; }
    if (source["defaultValueQuantity"] !== undefined) { this.defaultValueQuantity = source.defaultValueQuantity; }
    if (source["defaultValueRange"] !== undefined) { this.defaultValueRange = source.defaultValueRange; }
    if (source["defaultValueRatio"] !== undefined) { this.defaultValueRatio = source.defaultValueRatio; }
    if (source["defaultValueReference"] !== undefined) { this.defaultValueReference = source.defaultValueReference; }
    if (source["defaultValueSampledData"] !== undefined) { this.defaultValueSampledData = source.defaultValueSampledData; }
    if (source["defaultValueSignature"] !== undefined) { this.defaultValueSignature = source.defaultValueSignature; }
    if (source["defaultValueTiming"] !== undefined) { this.defaultValueTiming = source.defaultValueTiming; }
    if (source["defaultValueContactDetail"] !== undefined) { this.defaultValueContactDetail = source.defaultValueContactDetail; }
    if (source["defaultValueContributor"] !== undefined) { this.defaultValueContributor = source.defaultValueContributor; }
    if (source["defaultValueDataRequirement"] !== undefined) { this.defaultValueDataRequirement = source.defaultValueDataRequirement; }
    if (source["defaultValueExpression"] !== undefined) { this.defaultValueExpression = source.defaultValueExpression; }
    if (source["defaultValueParameterDefinition"] !== undefined) { this.defaultValueParameterDefinition = source.defaultValueParameterDefinition; }
    if (source["defaultValueRelatedArtifact"] !== undefined) { this.defaultValueRelatedArtifact = source.defaultValueRelatedArtifact; }
    if (source["defaultValueTriggerDefinition"] !== undefined) { this.defaultValueTriggerDefinition = source.defaultValueTriggerDefinition; }
    if (source["defaultValueUsageContext"] !== undefined) { this.defaultValueUsageContext = source.defaultValueUsageContext; }
    if (source["defaultValueDosage"] !== undefined) { this.defaultValueDosage = source.defaultValueDosage; }
    if (source["defaultValueMeta"] !== undefined) { this.defaultValueMeta = source.defaultValueMeta; }
    if (source["element"] !== undefined) { this.element = source.element; }
    if (source["_element"] !== undefined) { this._element = source._element; }
    if (source["listMode"] !== undefined) { this.listMode = source.listMode; }
    if (source["_listMode"] !== undefined) { this._listMode = source._listMode; }
    if (source["logMessage"] !== undefined) { this.logMessage = source.logMessage; }
    if (source["_logMessage"] !== undefined) { this._logMessage = source._logMessage; }
    if (source["max"] !== undefined) { this.max = source.max; }
    if (source["_max"] !== undefined) { this._max = source._max; }
    if (source["min"] !== undefined) { this.min = source.min; }
    if (source["_min"] !== undefined) { this._min = source._min; }
    if (source["type"] !== undefined) { this.type = source.type; }
    if (source["_type"] !== undefined) { this._type = source._type; }
    if (source["variable"] !== undefined) { this.variable = source.variable; }
    if (source["_variable"] !== undefined) { this._variable = source._variable; }
  }
}
/**
 * Code Values for the StructureMap.group.rule.source.listMode field
 */
export enum StructureMapGroupRuleSourceListModeEnum {
  FIRST = "first",
  NOT_FIRST = "not_first",
  LAST = "last",
  NOT_LAST = "not_last",
  ONLY_ONE = "only_one",
}
/**
 * Parameters to the transform.
 */
export class StructureMapGroupRuleTargetParameter extends fhirModels.BackboneElement {
  /**
   * Parameter value - variable or literal.
   */
  valueId?: string;
  _valueId?: fhirModels.Element;
  /**
   * Parameter value - variable or literal.
   */
  valueString?: string;
  _valueString?: fhirModels.Element;
  /**
   * Parameter value - variable or literal.
   */
  valueBoolean?: boolean;
  _valueBoolean?: fhirModels.Element;
  /**
   * Parameter value - variable or literal.
   */
  valueInteger?: number;
  _valueInteger?: fhirModels.Element;
  /**
   * Parameter value - variable or literal.
   */
  valueDecimal?: number;
  _valueDecimal?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroupRuleTargetParameter) {
    super(source);
    if (source["valueId"] !== undefined) { this.valueId = source.valueId; }
    if (source["_valueId"] !== undefined) { this._valueId = source._valueId; }
    if (source["valueString"] !== undefined) { this.valueString = source.valueString; }
    if (source["_valueString"] !== undefined) { this._valueString = source._valueString; }
    if (source["valueBoolean"] !== undefined) { this.valueBoolean = source.valueBoolean; }
    if (source["_valueBoolean"] !== undefined) { this._valueBoolean = source._valueBoolean; }
    if (source["valueInteger"] !== undefined) { this.valueInteger = source.valueInteger; }
    if (source["_valueInteger"] !== undefined) { this._valueInteger = source._valueInteger; }
    if (source["valueDecimal"] !== undefined) { this.valueDecimal = source.valueDecimal; }
    if (source["_valueDecimal"] !== undefined) { this._valueDecimal = source._valueDecimal; }
  }
}
/**
 * Content to create because of this mapping rule.
 */
export class StructureMapGroupRuleTarget extends fhirModels.BackboneElement {
  /**
   * Type or variable this rule applies to.
   */
  context?: string;
  _context?: fhirModels.Element;
  /**
   * How to interpret the context.
   */
  contextType?: StructureMapGroupRuleTargetContextTypeEnum;
  _contextType?: fhirModels.Element;
  /**
   * Field to create in the context.
   */
  element?: string;
  _element?: fhirModels.Element;
  /**
   * If field is a list, how to manage the list.
   */
  listMode?: StructureMapGroupRuleTargetListModeEnum[];
  _listMode?: fhirModels.Element[];
  /**
   * Internal rule reference for shared list items.
   */
  listRuleId?: string;
  _listRuleId?: fhirModels.Element;
  /**
   * Parameters to the transform.
   */
  parameter?: fhirModels.StructureMapGroupRuleTargetParameter[];
  /**
   * How the data is copied / created.
   */
  transform?: StructureMapGroupRuleTargetTransformEnum;
  _transform?: fhirModels.Element;
  /**
   * Named context for field, if desired, and a field is specified.
   */
  variable?: string;
  _variable?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroupRuleTarget) {
    super(source);
    if (source["context"] !== undefined) { this.context = source.context; }
    if (source["_context"] !== undefined) { this._context = source._context; }
    if (source["contextType"] !== undefined) { this.contextType = source.contextType; }
    if (source["_contextType"] !== undefined) { this._contextType = source._contextType; }
    if (source["element"] !== undefined) { this.element = source.element; }
    if (source["_element"] !== undefined) { this._element = source._element; }
    if (source["listMode"] !== undefined) { this.listMode = source.listMode; }
    if (source["_listMode"] !== undefined) { this._listMode = source._listMode; }
    if (source["listRuleId"] !== undefined) { this.listRuleId = source.listRuleId; }
    if (source["_listRuleId"] !== undefined) { this._listRuleId = source._listRuleId; }
    if (source["parameter"] !== undefined) { this.parameter = source.parameter; }
    if (source["transform"] !== undefined) { this.transform = source.transform; }
    if (source["_transform"] !== undefined) { this._transform = source._transform; }
    if (source["variable"] !== undefined) { this.variable = source.variable; }
    if (source["_variable"] !== undefined) { this._variable = source._variable; }
  }
}
/**
 * Code Values for the StructureMap.group.rule.target.contextType field
 */
export enum StructureMapGroupRuleTargetContextTypeEnum {
  TYPE = "type",
  VARIABLE = "variable",
}
/**
 * Code Values for the StructureMap.group.rule.target.listMode field
 */
export enum StructureMapGroupRuleTargetListModeEnum {
  FIRST = "first",
  SHARE = "share",
  LAST = "last",
  COLLATE = "collate",
}
/**
 * Code Values for the StructureMap.group.rule.target.transform field
 */
export enum StructureMapGroupRuleTargetTransformEnum {
  CREATE = "create",
  COPY = "copy",
  TRUNCATE = "truncate",
  ESCAPE = "escape",
  CAST = "cast",
  APPEND = "append",
  TRANSLATE = "translate",
  REFERENCE = "reference",
  DATEOP = "dateOp",
  UUID = "uuid",
  POINTER = "pointer",
  EVALUATE = "evaluate",
  CC = "cc",
  C = "c",
  QTY = "qty",
  ID = "id",
  CP = "cp",
}
/**
 * Which other rules to apply in the context of this rule.
 */
export class StructureMapGroupRuleDependent extends fhirModels.BackboneElement {
  /**
   * Name of a rule or group to apply.
   */
  name: string;
  _name?: fhirModels.Element;
  /**
   * Variable to pass to the rule or group.
   */
  variable: string[];
  _variable?: fhirModels.Element[];
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroupRuleDependent) {
    super(source);
    if (source["name"] === undefined) { throw 'Missing required element name';}
    this.name = source.name;
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["variable"] === undefined) { throw 'Missing required element variable';}
    this.variable = source.variable;
    if (source["_variable"] !== undefined) { this._variable = source._variable; }
  }
}
/**
 * Transform Rule from source to target.
 */
export class StructureMapGroupRule extends fhirModels.BackboneElement {
  /**
   * Which other rules to apply in the context of this rule.
   */
  dependent?: fhirModels.StructureMapGroupRuleDependent[];
  /**
   * Documentation for this instance of data.
   */
  documentation?: string;
  _documentation?: fhirModels.Element;
  /**
   * Name of the rule for internal references.
   */
  name: string;
  _name?: fhirModels.Element;
  /**
   * Rules contained in this rule.
   */
  rule?: fhirModels.StructureMapGroupRule[];
  /**
   * Source inputs to the mapping.
   */
  source: fhirModels.StructureMapGroupRuleSource[];
  /**
   * Content to create because of this mapping rule.
   */
  target?: fhirModels.StructureMapGroupRuleTarget[];
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroupRule) {
    super(source);
    if (source["dependent"] !== undefined) { this.dependent = source.dependent; }
    if (source["documentation"] !== undefined) { this.documentation = source.documentation; }
    if (source["_documentation"] !== undefined) { this._documentation = source._documentation; }
    if (source["name"] === undefined) { throw 'Missing required element name';}
    this.name = source.name;
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["rule"] !== undefined) { this.rule = source.rule; }
    if (source["source"] === undefined) { throw 'Missing required element source';}
    this.source = source.source;
    if (source["target"] !== undefined) { this.target = source.target; }
  }
}
/**
 * Organizes the mapping into manageable chunks for human review/ease of maintenance.
 */
export class StructureMapGroup extends fhirModels.BackboneElement {
  /**
   * Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
   */
  documentation?: string;
  _documentation?: fhirModels.Element;
  /**
   * Another group that this group adds rules to.
   */
  extends?: string;
  _extends?: fhirModels.Element;
  /**
   * If no inputs are named, then the entry mappings are type based.
   */
  input: fhirModels.StructureMapGroupInput[];
  /**
   * A unique name for the group for the convenience of human readers.
   */
  name: string;
  _name?: fhirModels.Element;
  /**
   * Transform Rule from source to target.
   */
  rule: fhirModels.StructureMapGroupRule[];
  /**
   * Not applicable if the underlying model is untyped. There can only be one default mapping for any particular type combination.
   */
  typeMode: StructureMapGroupTypeModeEnum;
  _typeMode?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMapGroup) {
    super(source);
    if (source["documentation"] !== undefined) { this.documentation = source.documentation; }
    if (source["_documentation"] !== undefined) { this._documentation = source._documentation; }
    if (source["extends"] !== undefined) { this.extends = source.extends; }
    if (source["_extends"] !== undefined) { this._extends = source._extends; }
    if (source["input"] === undefined) { throw 'Missing required element input';}
    this.input = source.input;
    if (source["name"] === undefined) { throw 'Missing required element name';}
    this.name = source.name;
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["rule"] === undefined) { throw 'Missing required element rule';}
    this.rule = source.rule;
    if (source["typeMode"] === undefined) { throw 'Missing required element typeMode';}
    this.typeMode = source.typeMode;
    if (source["_typeMode"] !== undefined) { this._typeMode = source._typeMode; }
  }
}
/**
 * Code Values for the StructureMap.group.typeMode field
 */
export enum StructureMapGroupTypeModeEnum {
  NONE = "none",
  TYPES = "types",
  TYPE_AND_TYPES = "type-and-types",
}
/**
 * A Map of relationships between 2 structures that can be used to transform data.
 */
export class StructureMap extends fhirModels.DomainResource {
  /**
   * Resource Type Name
   */
  readonly resourceType: string = "StructureMap";
  /**
   * May be a web site, an email address, a telephone number, etc.
   */
  contact?: fhirModels.ContactDetail[];
  /**
   * A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
   */
  copyright?: string;
  _copyright?: fhirModels.Element;
  /**
   * Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the structure map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   */
  date?: string;
  _date?: fhirModels.Element;
  /**
   * This description can be used to capture details such as why the structure map was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the structure map as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the structure map is presumed to be the predominant language in the place the structure map was created).
   */
  description?: string;
  _description?: fhirModels.Element;
  /**
   * Allows filtering of structure maps that are appropriate for use versus not.
   */
  experimental?: boolean;
  _experimental?: fhirModels.Element;
  /**
   * Organizes the mapping into manageable chunks for human review/ease of maintenance.
   */
  group: fhirModels.StructureMapGroup[];
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this structure map outside of FHIR, where it is not possible to use the logical URI.
   */
  identifier?: fhirModels.Identifier[];
  /**
   * Other maps used by this map (canonical URLs).
   */
  import?: string[];
  _import?: fhirModels.Element[];
  /**
   * It may be possible for the structure map to be used in jurisdictions other than those for which it was originally designed or intended.
   */
  jurisdiction?: fhirModels.CodeableConcept[];
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  name: string;
  _name?: fhirModels.Element;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the structure map is the organization or individual primarily responsible for the maintenance and upkeep of the structure map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the structure map. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: string;
  _publisher?: fhirModels.Element;
  /**
   * This element does not describe the usage of the structure map. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this structure map.
   */
  purpose?: string;
  _purpose?: fhirModels.Element;
  /**
   * Allows filtering of structure maps that are appropriate for use versus not.
   */
  status: StructureMapStatusEnum;
  _status?: fhirModels.Element;
  /**
   * It is not necessary for a structure map to identify any dependent structures, though not listing them may restrict its usefulness.
   */
  structure?: fhirModels.StructureMapStructure[];
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  title?: string;
  _title?: fhirModels.Element;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  url: string;
  _url?: fhirModels.Element;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: fhirModels.UsageContext[];
  /**
   * There may be different structure map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the structure map with the format [url]|[version].
   */
  version?: string;
  _version?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: StructureMap) {
    super(source);
    if ((source['resourceType'] !== "StructureMap") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a StructureMap'; }
    if (source["contact"] !== undefined) { this.contact = source.contact; }
    if (source["copyright"] !== undefined) { this.copyright = source.copyright; }
    if (source["_copyright"] !== undefined) { this._copyright = source._copyright; }
    if (source["date"] !== undefined) { this.date = source.date; }
    if (source["_date"] !== undefined) { this._date = source._date; }
    if (source["description"] !== undefined) { this.description = source.description; }
    if (source["_description"] !== undefined) { this._description = source._description; }
    if (source["experimental"] !== undefined) { this.experimental = source.experimental; }
    if (source["_experimental"] !== undefined) { this._experimental = source._experimental; }
    if (source["group"] === undefined) { throw 'Missing required element group';}
    this.group = source.group;
    if (source["identifier"] !== undefined) { this.identifier = source.identifier; }
    if (source["import"] !== undefined) { this.import = source.import; }
    if (source["_import"] !== undefined) { this._import = source._import; }
    if (source["jurisdiction"] !== undefined) { this.jurisdiction = source.jurisdiction; }
    if (source["name"] === undefined) { throw 'Missing required element name';}
    this.name = source.name;
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["publisher"] !== undefined) { this.publisher = source.publisher; }
    if (source["_publisher"] !== undefined) { this._publisher = source._publisher; }
    if (source["purpose"] !== undefined) { this.purpose = source.purpose; }
    if (source["_purpose"] !== undefined) { this._purpose = source._purpose; }
    if (source["status"] === undefined) { throw 'Missing required element status';}
    this.status = source.status;
    if (source["_status"] !== undefined) { this._status = source._status; }
    if (source["structure"] !== undefined) { this.structure = source.structure; }
    if (source["title"] !== undefined) { this.title = source.title; }
    if (source["_title"] !== undefined) { this._title = source._title; }
    if (source["url"] === undefined) { throw 'Missing required element url';}
    this.url = source.url;
    if (source["_url"] !== undefined) { this._url = source._url; }
    if (source["useContext"] !== undefined) { this.useContext = source.useContext; }
    if (source["version"] !== undefined) { this.version = source.version; }
    if (source["_version"] !== undefined) { this._version = source._version; }
  }
}
/**
 * Code Values for the StructureMap.status field
 */
export enum StructureMapStatusEnum {
  DRAFT = "draft",
  ACTIVE = "active",
  RETIRED = "retired",
  UNKNOWN = "unknown",
}
