// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../models'
/**
 * Moiety, for structural modifications.
 */
export class SubstanceSpecificationMoiety extends fhirModels.BackboneElement {
  /**
   * Quantitative value for this moiety.
   */
  amountQuantity?: fhirModels.Quantity;
  /**
   * Quantitative value for this moiety.
   */
  amountString?: string;
  _amountString?: fhirModels.Element;
  /**
   * Identifier by which this moiety substance is known.
   */
  identifier?: fhirModels.Identifier;
  /**
   * Molecular formula.
   */
  molecularFormula?: string;
  _molecularFormula?: fhirModels.Element;
  /**
   * Textual name for this moiety substance.
   */
  name?: string;
  _name?: fhirModels.Element;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhirModels.CodeableConcept;
  /**
   * Role that the moiety is playing.
   */
  role?: fhirModels.CodeableConcept;
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationMoiety) {
    super(source);
    if (source["amountQuantity"] !== undefined) { this.amountQuantity = source.amountQuantity; }
    if (source["amountString"] !== undefined) { this.amountString = source.amountString; }
    if (source["_amountString"] !== undefined) { this._amountString = source._amountString; }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier; }
    if (source["molecularFormula"] !== undefined) { this.molecularFormula = source.molecularFormula; }
    if (source["_molecularFormula"] !== undefined) { this._molecularFormula = source._molecularFormula; }
    if (source["name"] !== undefined) { this.name = source.name; }
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["opticalActivity"] !== undefined) { this.opticalActivity = source.opticalActivity; }
    if (source["role"] !== undefined) { this.role = source.role; }
    if (source["stereochemistry"] !== undefined) { this.stereochemistry = source.stereochemistry; }
  }
}
/**
 * General specifications for this substance, including how it is related to other substances.
 */
export class SubstanceSpecificationProperty extends fhirModels.BackboneElement {
  /**
   * Quantitative value for this property.
   */
  amountQuantity?: fhirModels.Quantity;
  /**
   * Quantitative value for this property.
   */
  amountString?: string;
  _amountString?: fhirModels.Element;
  /**
   * A category for this property, e.g. Physical, Chemical, Enzymatic.
   */
  category?: fhirModels.CodeableConcept;
  /**
   * Property type e.g. viscosity, pH, isoelectric point.
   */
  code?: fhirModels.CodeableConcept;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstanceReference?: fhirModels.Reference;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstanceCodeableConcept?: fhirModels.CodeableConcept;
  /**
   * Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
   */
  parameters?: string;
  _parameters?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationProperty) {
    super(source);
    if (source["amountQuantity"] !== undefined) { this.amountQuantity = source.amountQuantity; }
    if (source["amountString"] !== undefined) { this.amountString = source.amountString; }
    if (source["_amountString"] !== undefined) { this._amountString = source._amountString; }
    if (source["category"] !== undefined) { this.category = source.category; }
    if (source["code"] !== undefined) { this.code = source.code; }
    if (source["definingSubstanceReference"] !== undefined) { this.definingSubstanceReference = source.definingSubstanceReference; }
    if (source["definingSubstanceCodeableConcept"] !== undefined) { this.definingSubstanceCodeableConcept = source.definingSubstanceCodeableConcept; }
    if (source["parameters"] !== undefined) { this.parameters = source.parameters; }
    if (source["_parameters"] !== undefined) { this._parameters = source._parameters; }
  }
}
/**
 * The molecular weight or weight range (for proteins, polymers or nucleic acids).
 */
export class SubstanceSpecificationStructureIsotopeMolecularWeight extends fhirModels.BackboneElement {
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  amount?: fhirModels.Quantity;
  /**
   * The method by which the molecular weight was determined.
   */
  method?: fhirModels.CodeableConcept;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  type?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationStructureIsotopeMolecularWeight) {
    super(source);
    if (source["amount"] !== undefined) { this.amount = source.amount; }
    if (source["method"] !== undefined) { this.method = source.method; }
    if (source["type"] !== undefined) { this.type = source.type; }
  }
}
/**
 * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
 */
export class SubstanceSpecificationStructureIsotope extends fhirModels.BackboneElement {
  /**
   * Half life - for a non-natural nuclide.
   */
  halfLife?: fhirModels.Quantity;
  /**
   * Substance identifier for each non-natural or radioisotope.
   */
  identifier?: fhirModels.Identifier;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhirModels.SubstanceSpecificationStructureIsotopeMolecularWeight;
  /**
   * Substance name for each non-natural or radioisotope.
   */
  name?: fhirModels.CodeableConcept;
  /**
   * The type of isotopic substitution present in a single substance.
   */
  substitution?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationStructureIsotope) {
    super(source);
    if (source["halfLife"] !== undefined) { this.halfLife = source.halfLife; }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier; }
    if (source["molecularWeight"] !== undefined) { this.molecularWeight = source.molecularWeight; }
    if (source["name"] !== undefined) { this.name = source.name; }
    if (source["substitution"] !== undefined) { this.substitution = source.substitution; }
  }
}
/**
 * Molecular structural representation.
 */
export class SubstanceSpecificationStructureRepresentation extends fhirModels.BackboneElement {
  /**
   * An attached file with the structural representation.
   */
  attachment?: fhirModels.Attachment;
  /**
   * The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
   */
  representation?: string;
  _representation?: fhirModels.Element;
  /**
   * The type of structure (e.g. Full, Partial, Representative).
   */
  type?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationStructureRepresentation) {
    super(source);
    if (source["attachment"] !== undefined) { this.attachment = source.attachment; }
    if (source["representation"] !== undefined) { this.representation = source.representation; }
    if (source["_representation"] !== undefined) { this._representation = source._representation; }
    if (source["type"] !== undefined) { this.type = source.type; }
  }
}
/**
 * Structural information.
 */
export class SubstanceSpecificationStructure extends fhirModels.BackboneElement {
  /**
   * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
   */
  isotope?: fhirModels.SubstanceSpecificationStructureIsotope[];
  /**
   * Molecular formula.
   */
  molecularFormula?: string;
  _molecularFormula?: fhirModels.Element;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  molecularFormulaByMoiety?: string;
  _molecularFormulaByMoiety?: fhirModels.Element;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhirModels.SubstanceSpecificationStructureIsotopeMolecularWeight;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhirModels.CodeableConcept;
  /**
   * Molecular structural representation.
   */
  representation?: fhirModels.SubstanceSpecificationStructureRepresentation[];
  /**
   * Supporting literature.
   */
  source?: fhirModels.Reference[];
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationStructure) {
    super(source);
    if (source["isotope"] !== undefined) { this.isotope = source.isotope; }
    if (source["molecularFormula"] !== undefined) { this.molecularFormula = source.molecularFormula; }
    if (source["_molecularFormula"] !== undefined) { this._molecularFormula = source._molecularFormula; }
    if (source["molecularFormulaByMoiety"] !== undefined) { this.molecularFormulaByMoiety = source.molecularFormulaByMoiety; }
    if (source["_molecularFormulaByMoiety"] !== undefined) { this._molecularFormulaByMoiety = source._molecularFormulaByMoiety; }
    if (source["molecularWeight"] !== undefined) { this.molecularWeight = source.molecularWeight; }
    if (source["opticalActivity"] !== undefined) { this.opticalActivity = source.opticalActivity; }
    if (source["representation"] !== undefined) { this.representation = source.representation; }
    if (source["source"] !== undefined) { this.source = source.source; }
    if (source["stereochemistry"] !== undefined) { this.stereochemistry = source.stereochemistry; }
  }
}
/**
 * Codes associated with the substance.
 */
export class SubstanceSpecificationCode extends fhirModels.BackboneElement {
  /**
   * The specific code.
   */
  code?: fhirModels.CodeableConcept;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  comment?: string;
  _comment?: fhirModels.Element;
  /**
   * Supporting literature.
   */
  source?: fhirModels.Reference[];
  /**
   * Status of the code assignment.
   */
  status?: fhirModels.CodeableConcept;
  /**
   * The date at which the code status is changed as part of the terminology maintenance.
   */
  statusDate?: string;
  _statusDate?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationCode) {
    super(source);
    if (source["code"] !== undefined) { this.code = source.code; }
    if (source["comment"] !== undefined) { this.comment = source.comment; }
    if (source["_comment"] !== undefined) { this._comment = source._comment; }
    if (source["source"] !== undefined) { this.source = source.source; }
    if (source["status"] !== undefined) { this.status = source.status; }
    if (source["statusDate"] !== undefined) { this.statusDate = source.statusDate; }
    if (source["_statusDate"] !== undefined) { this._statusDate = source._statusDate; }
  }
}
/**
 * Details of the official nature of this name.
 */
export class SubstanceSpecificationNameOfficial extends fhirModels.BackboneElement {
  /**
   * Which authority uses this official name.
   */
  authority?: fhirModels.CodeableConcept;
  /**
   * Date of official name change.
   */
  date?: string;
  _date?: fhirModels.Element;
  /**
   * The status of the official name.
   */
  status?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationNameOfficial) {
    super(source);
    if (source["authority"] !== undefined) { this.authority = source.authority; }
    if (source["date"] !== undefined) { this.date = source.date; }
    if (source["_date"] !== undefined) { this._date = source._date; }
    if (source["status"] !== undefined) { this.status = source.status; }
  }
}
/**
 * Names applicable to this substance.
 */
export class SubstanceSpecificationName extends fhirModels.BackboneElement {
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  domain?: fhirModels.CodeableConcept[];
  /**
   * The jurisdiction where this name applies.
   */
  jurisdiction?: fhirModels.CodeableConcept[];
  /**
   * Language of the name.
   */
  language?: fhirModels.CodeableConcept[];
  /**
   * The actual name.
   */
  name: string;
  _name?: fhirModels.Element;
  /**
   * Details of the official nature of this name.
   */
  official?: fhirModels.SubstanceSpecificationNameOfficial[];
  /**
   * If this is the preferred name for this substance.
   */
  preferred?: boolean;
  _preferred?: fhirModels.Element;
  /**
   * Supporting literature.
   */
  source?: fhirModels.Reference[];
  /**
   * The status of the name.
   */
  status?: fhirModels.CodeableConcept;
  /**
   * A synonym of this name.
   */
  synonym?: fhirModels.SubstanceSpecificationName[];
  /**
   * A translation for this name.
   */
  translation?: fhirModels.SubstanceSpecificationName[];
  /**
   * Name type.
   */
  type?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationName) {
    super(source);
    if (source["domain"] !== undefined) { this.domain = source.domain; }
    if (source["jurisdiction"] !== undefined) { this.jurisdiction = source.jurisdiction; }
    if (source["language"] !== undefined) { this.language = source.language; }
    if (source["name"] === undefined) { throw 'Missing required element name';}
    this.name = source.name;
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["official"] !== undefined) { this.official = source.official; }
    if (source["preferred"] !== undefined) { this.preferred = source.preferred; }
    if (source["_preferred"] !== undefined) { this._preferred = source._preferred; }
    if (source["source"] !== undefined) { this.source = source.source; }
    if (source["status"] !== undefined) { this.status = source.status; }
    if (source["synonym"] !== undefined) { this.synonym = source.synonym; }
    if (source["translation"] !== undefined) { this.translation = source.translation; }
    if (source["type"] !== undefined) { this.type = source.type; }
  }
}
/**
 * A link between this substance and another, with details of the relationship.
 */
export class SubstanceSpecificationRelationship extends fhirModels.BackboneElement {
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountQuantity?: fhirModels.Quantity;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRange?: fhirModels.Range;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRatio?: fhirModels.Ratio;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountString?: string;
  _amountString?: fhirModels.Element;
  /**
   * For use when the numeric.
   */
  amountRatioLowLimit?: fhirModels.Ratio;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  amountType?: fhirModels.CodeableConcept;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  isDefining?: boolean;
  _isDefining?: fhirModels.Element;
  /**
   * For example "salt to parent", "active moiety", "starting material".
   */
  relationship?: fhirModels.CodeableConcept;
  /**
   * Supporting literature.
   */
  source?: fhirModels.Reference[];
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceReference?: fhirModels.Reference;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceCodeableConcept?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecificationRelationship) {
    super(source);
    if (source["amountQuantity"] !== undefined) { this.amountQuantity = source.amountQuantity; }
    if (source["amountRange"] !== undefined) { this.amountRange = source.amountRange; }
    if (source["amountRatio"] !== undefined) { this.amountRatio = source.amountRatio; }
    if (source["amountString"] !== undefined) { this.amountString = source.amountString; }
    if (source["_amountString"] !== undefined) { this._amountString = source._amountString; }
    if (source["amountRatioLowLimit"] !== undefined) { this.amountRatioLowLimit = source.amountRatioLowLimit; }
    if (source["amountType"] !== undefined) { this.amountType = source.amountType; }
    if (source["isDefining"] !== undefined) { this.isDefining = source.isDefining; }
    if (source["_isDefining"] !== undefined) { this._isDefining = source._isDefining; }
    if (source["relationship"] !== undefined) { this.relationship = source.relationship; }
    if (source["source"] !== undefined) { this.source = source.source; }
    if (source["substanceReference"] !== undefined) { this.substanceReference = source.substanceReference; }
    if (source["substanceCodeableConcept"] !== undefined) { this.substanceCodeableConcept = source.substanceCodeableConcept; }
  }
}
/**
 * The detailed description of a substance, typically at a level beyond what is used for prescribing.
 */
export class SubstanceSpecification extends fhirModels.DomainResource {
  /**
   * Resource Type Name
   */
  readonly resourceType: string = "SubstanceSpecification";
  /**
   * Codes associated with the substance.
   */
  code?: fhirModels.SubstanceSpecificationCode[];
  /**
   * Textual comment about this record of a substance.
   */
  comment?: string;
  _comment?: fhirModels.Element;
  /**
   * Textual description of the substance.
   */
  description?: string;
  _description?: fhirModels.Element;
  /**
   * If the substance applies to only human or veterinary use.
   */
  domain?: fhirModels.CodeableConcept;
  /**
   * Identifier by which this substance is known.
   */
  identifier?: fhirModels.Identifier;
  /**
   * Moiety, for structural modifications.
   */
  moiety?: fhirModels.SubstanceSpecificationMoiety[];
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhirModels.SubstanceSpecificationStructureIsotopeMolecularWeight[];
  /**
   * Names applicable to this substance.
   */
  name?: fhirModels.SubstanceSpecificationName[];
  /**
   * Data items specific to nucleic acids.
   */
  nucleicAcid?: fhirModels.Reference;
  /**
   * Data items specific to polymers.
   */
  polymer?: fhirModels.Reference;
  /**
   * General specifications for this substance, including how it is related to other substances.
   */
  property?: fhirModels.SubstanceSpecificationProperty[];
  /**
   * Data items specific to proteins.
   */
  protein?: fhirModels.Reference;
  /**
   * General information detailing this substance.
   */
  referenceInformation?: fhirModels.Reference;
  /**
   * A link between this substance and another, with details of the relationship.
   */
  relationship?: fhirModels.SubstanceSpecificationRelationship[];
  /**
   * Supporting literature.
   */
  source?: fhirModels.Reference[];
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  sourceMaterial?: fhirModels.Reference;
  /**
   * Status of substance within the catalogue e.g. approved.
   */
  status?: fhirModels.CodeableConcept;
  /**
   * Structural information.
   */
  structure?: fhirModels.SubstanceSpecificationStructure;
  /**
   * High level categorization, e.g. polymer or nucleic acid.
   */
  type?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: SubstanceSpecification) {
    super(source);
    if ((source['resourceType'] !== "SubstanceSpecification") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a SubstanceSpecification'; }
    if (source["code"] !== undefined) { this.code = source.code; }
    if (source["comment"] !== undefined) { this.comment = source.comment; }
    if (source["_comment"] !== undefined) { this._comment = source._comment; }
    if (source["description"] !== undefined) { this.description = source.description; }
    if (source["_description"] !== undefined) { this._description = source._description; }
    if (source["domain"] !== undefined) { this.domain = source.domain; }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier; }
    if (source["moiety"] !== undefined) { this.moiety = source.moiety; }
    if (source["molecularWeight"] !== undefined) { this.molecularWeight = source.molecularWeight; }
    if (source["name"] !== undefined) { this.name = source.name; }
    if (source["nucleicAcid"] !== undefined) { this.nucleicAcid = source.nucleicAcid; }
    if (source["polymer"] !== undefined) { this.polymer = source.polymer; }
    if (source["property"] !== undefined) { this.property = source.property; }
    if (source["protein"] !== undefined) { this.protein = source.protein; }
    if (source["referenceInformation"] !== undefined) { this.referenceInformation = source.referenceInformation; }
    if (source["relationship"] !== undefined) { this.relationship = source.relationship; }
    if (source["source"] !== undefined) { this.source = source.source; }
    if (source["sourceMaterial"] !== undefined) { this.sourceMaterial = source.sourceMaterial; }
    if (source["status"] !== undefined) { this.status = source.status; }
    if (source["structure"] !== undefined) { this.structure = source.structure; }
    if (source["type"] !== undefined) { this.type = source.type; }
  }
}
