// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../models'
import * as fhirInterfaces from '../interfaces'
/**
 * The populations that make up the population group, one for each type of population appropriate for the measure.
 */
export class MeasureReportGroupPopulation extends fhirModels.BackboneElement implements fhirInterfaces.IMeasureReportGroupPopulation {
  /**
   * The type of the population.
   */
  code?: fhirModels.CodeableConcept|undefined;
  /**
   * The number of members of the population.
   */
  count?: number|undefined;
  _count?: fhirModels.Element|undefined;
  /**
   * This element refers to a List of subject level MeasureReport resources, one for each subject in this population.
   */
  subjectResults?: fhirModels.Reference|undefined;
  /**
   * Default constructor for MeasureReportGroupPopulation from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReportGroupPopulation>) {
    super(source);
    if (source["code"] !== undefined) { this.code = new fhirModels.CodeableConcept(source.code); }
    if (source["count"] !== undefined) { this.count = source.count; }
    if (source["_count"] !== undefined) { this._count = new fhirModels.Element(source._count); }
    if (source["subjectResults"] !== undefined) { this.subjectResults = new fhirModels.Reference(source.subjectResults); }
  }
  /**
   * Check if the current MeasureReportGroupPopulation contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReportGroupPopulation from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReportGroupPopulation):MeasureReportGroupPopulation {
    var dest:MeasureReportGroupPopulation = new MeasureReportGroupPopulation(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReportGroupPopulation is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * A stratifier component value.
 */
export class MeasureReportGroupStratifierStratumComponent extends fhirModels.BackboneElement implements fhirInterfaces.IMeasureReportGroupStratifierStratumComponent {
  /**
   * The code for the stratum component value.
   */
  code: fhirModels.CodeableConcept|undefined;
  /**
   * The stratum component value.
   */
  value: fhirModels.CodeableConcept|undefined;
  /**
   * Default constructor for MeasureReportGroupStratifierStratumComponent from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReportGroupStratifierStratumComponent>) {
    super(source);
    if (source["code"] !== undefined) { this.code = new fhirModels.CodeableConcept(source.code); }
    if (source["value"] !== undefined) { this.value = new fhirModels.CodeableConcept(source.value); }
  }
  /**
   * Check if the current MeasureReportGroupStratifierStratumComponent contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    if (this["value"] === undefined) { missingElements.push("value"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReportGroupStratifierStratumComponent from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReportGroupStratifierStratumComponent):MeasureReportGroupStratifierStratumComponent {
    var dest:MeasureReportGroupStratifierStratumComponent = new MeasureReportGroupStratifierStratumComponent(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReportGroupStratifierStratumComponent is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * The populations that make up the stratum, one for each type of population appropriate to the measure.
 */
export class MeasureReportGroupStratifierStratumPopulation extends fhirModels.BackboneElement implements fhirInterfaces.IMeasureReportGroupStratifierStratumPopulation {
  /**
   * The type of the population.
   */
  code?: fhirModels.CodeableConcept|undefined;
  /**
   * The number of members of the population in this stratum.
   */
  count?: number|undefined;
  _count?: fhirModels.Element|undefined;
  /**
   * This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum.
   */
  subjectResults?: fhirModels.Reference|undefined;
  /**
   * Default constructor for MeasureReportGroupStratifierStratumPopulation from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReportGroupStratifierStratumPopulation>) {
    super(source);
    if (source["code"] !== undefined) { this.code = new fhirModels.CodeableConcept(source.code); }
    if (source["count"] !== undefined) { this.count = source.count; }
    if (source["_count"] !== undefined) { this._count = new fhirModels.Element(source._count); }
    if (source["subjectResults"] !== undefined) { this.subjectResults = new fhirModels.Reference(source.subjectResults); }
  }
  /**
   * Check if the current MeasureReportGroupStratifierStratumPopulation contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReportGroupStratifierStratumPopulation from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReportGroupStratifierStratumPopulation):MeasureReportGroupStratifierStratumPopulation {
    var dest:MeasureReportGroupStratifierStratumPopulation = new MeasureReportGroupStratifierStratumPopulation(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReportGroupStratifierStratumPopulation is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
 */
export class MeasureReportGroupStratifierStratum extends fhirModels.BackboneElement implements fhirInterfaces.IMeasureReportGroupStratifierStratum {
  /**
   * A stratifier component value.
   */
  component?: fhirModels.MeasureReportGroupStratifierStratumComponent[]|undefined;
  /**
   * The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
   */
  measureScore?: fhirModels.Quantity|undefined;
  /**
   * The populations that make up the stratum, one for each type of population appropriate to the measure.
   */
  population?: fhirModels.MeasureReportGroupStratifierStratumPopulation[]|undefined;
  /**
   * The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
   */
  value?: fhirModels.CodeableConcept|undefined;
  /**
   * Default constructor for MeasureReportGroupStratifierStratum from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReportGroupStratifierStratum>) {
    super(source);
    if (source["component"] !== undefined) { this.component = source.component.map((x) => new fhirModels.MeasureReportGroupStratifierStratumComponent(x)); }
    if (source["measureScore"] !== undefined) { this.measureScore = new fhirModels.Quantity(source.measureScore); }
    if (source["population"] !== undefined) { this.population = source.population.map((x) => new fhirModels.MeasureReportGroupStratifierStratumPopulation(x)); }
    if (source["value"] !== undefined) { this.value = new fhirModels.CodeableConcept(source.value); }
  }
  /**
   * Check if the current MeasureReportGroupStratifierStratum contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReportGroupStratifierStratum from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReportGroupStratifierStratum):MeasureReportGroupStratifierStratum {
    var dest:MeasureReportGroupStratifierStratum = new MeasureReportGroupStratifierStratum(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReportGroupStratifierStratum is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
 */
export class MeasureReportGroupStratifier extends fhirModels.BackboneElement implements fhirInterfaces.IMeasureReportGroupStratifier {
  /**
   * The meaning of this stratifier, as defined in the measure definition.
   */
  code?: fhirModels.CodeableConcept[]|undefined;
  /**
   * This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
   */
  stratum?: fhirModels.MeasureReportGroupStratifierStratum[]|undefined;
  /**
   * Default constructor for MeasureReportGroupStratifier from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReportGroupStratifier>) {
    super(source);
    if (source["code"] !== undefined) { this.code = source.code.map((x) => new fhirModels.CodeableConcept(x)); }
    if (source["stratum"] !== undefined) { this.stratum = source.stratum.map((x) => new fhirModels.MeasureReportGroupStratifierStratum(x)); }
  }
  /**
   * Check if the current MeasureReportGroupStratifier contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReportGroupStratifier from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReportGroupStratifier):MeasureReportGroupStratifier {
    var dest:MeasureReportGroupStratifier = new MeasureReportGroupStratifier(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReportGroupStratifier is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * The results of the calculation, one for each population group in the measure.
 */
export class MeasureReportGroup extends fhirModels.BackboneElement implements fhirInterfaces.IMeasureReportGroup {
  /**
   * The meaning of the population group as defined in the measure definition.
   */
  code?: fhirModels.CodeableConcept|undefined;
  /**
   * The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
   */
  measureScore?: fhirModels.Quantity|undefined;
  /**
   * The populations that make up the population group, one for each type of population appropriate for the measure.
   */
  population?: fhirModels.MeasureReportGroupPopulation[]|undefined;
  /**
   * When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
   */
  stratifier?: fhirModels.MeasureReportGroupStratifier[]|undefined;
  /**
   * Default constructor for MeasureReportGroup from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReportGroup>) {
    super(source);
    if (source["code"] !== undefined) { this.code = new fhirModels.CodeableConcept(source.code); }
    if (source["measureScore"] !== undefined) { this.measureScore = new fhirModels.Quantity(source.measureScore); }
    if (source["population"] !== undefined) { this.population = source.population.map((x) => new fhirModels.MeasureReportGroupPopulation(x)); }
    if (source["stratifier"] !== undefined) { this.stratifier = source.stratifier.map((x) => new fhirModels.MeasureReportGroupStratifier(x)); }
  }
  /**
   * Check if the current MeasureReportGroup contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReportGroup from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReportGroup):MeasureReportGroup {
    var dest:MeasureReportGroup = new MeasureReportGroup(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReportGroup is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.
 */
export class MeasureReport extends fhirModels.DomainResource implements fhirInterfaces.IMeasureReport {
  /**
   * Resource Type Name
   */
  readonly resourceType = "MeasureReport";
  /**
   * The date this measure report was generated.
   */
  date?: string|undefined;
  _date?: fhirModels.Element|undefined;
  /**
   * A reference to a Bundle containing the Resources that were used in the calculation of this measure.
   */
  evaluatedResource?: fhirModels.Reference[]|undefined;
  /**
   * The results of the calculation, one for each population group in the measure.
   */
  group?: fhirModels.MeasureReportGroup[]|undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II data type - e.g. to identify this {{title}} outside of FHIR, where the logical URL is not possible to use.
   */
  identifier?: fhirModels.Identifier[]|undefined;
  /**
   * This element is typically defined by the measure, but reproduced here to ensure the measure score can be interpreted. The element is labeled as a modifier because it changes the interpretation of the reported measure score.
   */
  improvementNotation?: fhirModels.CodeableConcept|undefined;
  /**
   * A reference to the Measure that was calculated to produce this report.
   */
  measure: string|undefined;
  _measure?: fhirModels.Element|undefined;
  /**
   * The reporting period for which the report was calculated.
   */
  period: fhirModels.Period|undefined;
  /**
   * The individual, location, or organization that is reporting the data.
   */
  reporter?: fhirModels.Reference|undefined;
  /**
   * This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
   */
  status: MeasureReportStatusEnum|undefined;
  _status?: fhirModels.Element|undefined;
  /**
   * Optional subject identifying the individual or individuals the report is for.
   */
  subject?: fhirModels.Reference|undefined;
  /**
   * Data-collection reports are used only to communicate data-of-interest for a measure. They do not necessarily include all the data for a particular subject or population, but they may.
   */
  type: MeasureReportTypeEnum|undefined;
  _type?: fhirModels.Element|undefined;
  /**
   * Default constructor for MeasureReport from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IMeasureReport>) {
    super(source);
    if ((source['resourceType'] !== "MeasureReport") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a MeasureReport'; }
    if (source["date"] !== undefined) { this.date = source.date; }
    if (source["_date"] !== undefined) { this._date = new fhirModels.Element(source._date); }
    if (source["evaluatedResource"] !== undefined) { this.evaluatedResource = source.evaluatedResource.map((x) => new fhirModels.Reference(x)); }
    if (source["group"] !== undefined) { this.group = source.group.map((x) => new fhirModels.MeasureReportGroup(x)); }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x)); }
    if (source["improvementNotation"] !== undefined) { this.improvementNotation = new fhirModels.CodeableConcept(source.improvementNotation); }
    if (source["measure"] !== undefined) { this.measure = source.measure; }
    if (source["_measure"] !== undefined) { this._measure = new fhirModels.Element(source._measure); }
    if (source["period"] !== undefined) { this.period = new fhirModels.Period(source.period); }
    if (source["reporter"] !== undefined) { this.reporter = new fhirModels.Reference(source.reporter); }
    if (source["status"] !== undefined) { this.status = source.status; }
    if (source["_status"] !== undefined) { this._status = new fhirModels.Element(source._status); }
    if (source["subject"] !== undefined) { this.subject = new fhirModels.Reference(source.subject); }
    if (source["type"] !== undefined) { this.type = source.type; }
    if (source["_type"] !== undefined) { this._type = new fhirModels.Element(source._type); }
  }
  /**
   * Check if the current MeasureReport contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["measure"] === undefined) { missingElements.push("measure"); }
    if (this["period"] === undefined) { missingElements.push("period"); }
    if (this["status"] === undefined) { missingElements.push("status"); }
    if (this["type"] === undefined) { missingElements.push("type"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a MeasureReport from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IMeasureReport):MeasureReport {
    var dest:MeasureReport = new MeasureReport(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `MeasureReport is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
/**
 * Code Values for the MeasureReport.status field
 */
export enum MeasureReportStatusEnum {
  COMPLETE = "complete",
  PENDING = "pending",
  ERROR = "error",
}
/**
 * Code Values for the MeasureReport.type field
 */
export enum MeasureReportTypeEnum {
  INDIVIDUAL = "individual",
  SUBJECT_LIST = "subject-list",
  SUMMARY = "summary",
  DATA_COLLECTION = "data-collection",
}
