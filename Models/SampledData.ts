// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../models'
import * as fhirInterfaces from '../interfaces'
/**
 * A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 */
export class SampledData extends fhirModels.Element implements fhirInterfaces.ISampledData {
  /**
   * Data may be missing if it is omitted for summarization purposes. In general, data is required for any actual use of a SampledData.
   */
  data?: string|undefined;
  _data?: fhirModels.Element|undefined;
  /**
   * If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
   */
  dimensions: number|undefined;
  _dimensions?: fhirModels.Element|undefined;
  /**
   * A correction factor that is applied to the sampled data points before they are added to the origin.
   */
  factor?: number|undefined;
  _factor?: fhirModels.Element|undefined;
  /**
   * The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
   */
  lowerLimit?: number|undefined;
  _lowerLimit?: fhirModels.Element|undefined;
  /**
   * The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
   */
  origin: fhirModels.Quantity|undefined;
  /**
   * This is usually a whole number.
   */
  period: number|undefined;
  _period?: fhirModels.Element|undefined;
  /**
   * The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
   */
  upperLimit?: number|undefined;
  _upperLimit?: fhirModels.Element|undefined;
  /**
   * Default constructor for SampledData from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.ISampledData>) {
    super(source);
    if (source["data"] !== undefined) { this.data = source.data; }
    if (source["_data"] !== undefined) { this._data = new fhirModels.Element(source._data); }
    if (source["dimensions"] !== undefined) { this.dimensions = source.dimensions; }
    if (source["_dimensions"] !== undefined) { this._dimensions = new fhirModels.Element(source._dimensions); }
    if (source["factor"] !== undefined) { this.factor = source.factor; }
    if (source["_factor"] !== undefined) { this._factor = new fhirModels.Element(source._factor); }
    if (source["lowerLimit"] !== undefined) { this.lowerLimit = source.lowerLimit; }
    if (source["_lowerLimit"] !== undefined) { this._lowerLimit = new fhirModels.Element(source._lowerLimit); }
    if (source["origin"] !== undefined) { this.origin = new fhirModels.Quantity(source.origin); }
    if (source["period"] !== undefined) { this.period = source.period; }
    if (source["_period"] !== undefined) { this._period = new fhirModels.Element(source._period); }
    if (source["upperLimit"] !== undefined) { this.upperLimit = source.upperLimit; }
    if (source["_upperLimit"] !== undefined) { this._upperLimit = new fhirModels.Element(source._upperLimit); }
  }
  /**
   * Check if the current SampledData contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["dimensions"] === undefined) { missingElements.push("dimensions"); }
    if (this["origin"] === undefined) { missingElements.push("origin"); }
    if (this["period"] === undefined) { missingElements.push("period"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
  /**
   * Factory function to create a SampledData from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.ISampledData):SampledData {
    var dest:SampledData = new SampledData(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `SampledData is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
}
