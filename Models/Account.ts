// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../models'
/**
 * Typically. this may be some form of insurance, internal charges, or self-pay.
 * Local or jurisdictional business rules may determine which coverage covers which types of billable items charged to the account, and in which order.
 * Where the order is important, a local/jurisdictional extension may be defined to specify the order for the type of charge.
 */
export class AccountCoverage extends fhirModels.BackboneElement {
  /**
   * The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).
   * A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing.
   */
  coverage: fhirModels.Reference;
  /**
   * It is common in some jurisdictions for there to be multiple coverages allocated to an account, and a sequence is required to order the settling of the account (often with insurance claiming).
   */
  priority?: number;
  _priority?: fhirModels.Element;
  /**
   * Default constructor
   */
  constructor(source: AccountCoverage) {
    super(source);
    if (source["coverage"] === undefined) { throw 'Missing required element coverage';}
    this.coverage = source.coverage;
    if (source["priority"] !== undefined) { this.priority = source.priority; }
    if (source["_priority"] !== undefined) { this._priority = source._priority; }
  }
}
/**
 * The parties responsible for balancing the account if other payment options fall short.
 */
export class AccountGuarantor extends fhirModels.BackboneElement {
  /**
   * A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
   */
  onHold?: boolean;
  _onHold?: fhirModels.Element;
  /**
   * The entity who is responsible.
   */
  party: fhirModels.Reference;
  /**
   * The timeframe during which the guarantor accepts responsibility for the account.
   */
  period?: fhirModels.Period;
  /**
   * Default constructor
   */
  constructor(source: AccountGuarantor) {
    super(source);
    if (source["onHold"] !== undefined) { this.onHold = source.onHold; }
    if (source["_onHold"] !== undefined) { this._onHold = source._onHold; }
    if (source["party"] === undefined) { throw 'Missing required element party';}
    this.party = source.party;
    if (source["period"] !== undefined) { this.period = source.period; }
  }
}
/**
 * A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
 */
export class Account extends fhirModels.DomainResource {
  /**
   * Resource Type Name
   */
  readonly resourceType: string = "Account";
  /**
   * Typically. this may be some form of insurance, internal charges, or self-pay.
   * Local or jurisdictional business rules may determine which coverage covers which types of billable items charged to the account, and in which order.
   * Where the order is important, a local/jurisdictional extension may be defined to specify the order for the type of charge.
   */
  coverage?: fhirModels.AccountCoverage[];
  /**
   * Provides additional information about what the account tracks and how it is used.
   */
  description?: string;
  _description?: fhirModels.Element;
  /**
   * The parties responsible for balancing the account if other payment options fall short.
   */
  guarantor?: fhirModels.AccountGuarantor[];
  /**
   * Unique identifier used to reference the account.  Might or might not be intended for human use (e.g. credit card number).
   */
  identifier?: fhirModels.Identifier[];
  /**
   * Name used for the account when displaying it to humans in reports, etc.
   */
  name?: string;
  _name?: fhirModels.Element;
  /**
   * Indicates the service area, hospital, department, etc. with responsibility for managing the Account.
   */
  owner?: fhirModels.Reference;
  /**
   * Reference to a parent Account.
   */
  partOf?: fhirModels.Reference;
  /**
   * It is possible for transactions to be posted outside the service period, as long as the service was provided within the defined service period.
   */
  servicePeriod?: fhirModels.Period;
  /**
   * This element is labeled as a modifier because the status contains the codes inactive and entered-in-error that mark the Account as not currently valid.
   */
  status: AccountStatusEnum;
  _status?: fhirModels.Element;
  /**
   * Accounts can be applied to non-patients for tracking other non-patient related activities, such as group services (patients not tracked, and costs charged to another body), or might not be allocated.
   */
  subject?: fhirModels.Reference[];
  /**
   * Categorizes the account for reporting and searching purposes.
   */
  type?: fhirModels.CodeableConcept;
  /**
   * Default constructor
   */
  constructor(source: Account) {
    super(source);
    if ((source['resourceType'] !== "Account") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a Account'; }
    if (source["coverage"] !== undefined) { this.coverage = source.coverage; }
    if (source["description"] !== undefined) { this.description = source.description; }
    if (source["_description"] !== undefined) { this._description = source._description; }
    if (source["guarantor"] !== undefined) { this.guarantor = source.guarantor; }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier; }
    if (source["name"] !== undefined) { this.name = source.name; }
    if (source["_name"] !== undefined) { this._name = source._name; }
    if (source["owner"] !== undefined) { this.owner = source.owner; }
    if (source["partOf"] !== undefined) { this.partOf = source.partOf; }
    if (source["servicePeriod"] !== undefined) { this.servicePeriod = source.servicePeriod; }
    if (source["status"] === undefined) { throw 'Missing required element status';}
    this.status = source.status;
    if (source["_status"] !== undefined) { this._status = source._status; }
    if (source["subject"] !== undefined) { this.subject = source.subject; }
    if (source["type"] !== undefined) { this.type = source.type; }
  }
}
/**
 * Code Values for the Account.status field
 */
export enum AccountStatusEnum {
  ACTIVE = "active",
  INACTIVE = "inactive",
  ENTERED_IN_ERROR = "entered-in-error",
  ON_HOLD = "on-hold",
  UNKNOWN = "unknown",
}
