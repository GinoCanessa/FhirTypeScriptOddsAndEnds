"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuestionnaireResponseStatusEnum = exports.QuestionnaireResponse = exports.QuestionnaireResponseItem = exports.QuestionnaireResponseItemAnswer = void 0;
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
const fhirModels = __importStar(require("../optionalmodels"));
/**
 * The value is nested because we cannot have a repeating structure that has variable type.
 */
class QuestionnaireResponseItemAnswer extends fhirModels.BackboneElement {
    /**
     * Default constructor for QuestionnaireResponseItemAnswer from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["item"] !== undefined) {
            this.item = source.item.map((x) => new fhirModels.QuestionnaireResponseItem(x));
        }
        if (source["valueBoolean"] !== undefined) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"] !== undefined) {
            this._valueBoolean = new fhirModels.Element(source._valueBoolean);
        }
        if (source["valueDecimal"] !== undefined) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"] !== undefined) {
            this._valueDecimal = new fhirModels.Element(source._valueDecimal);
        }
        if (source["valueInteger"] !== undefined) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"] !== undefined) {
            this._valueInteger = new fhirModels.Element(source._valueInteger);
        }
        if (source["valueDate"] !== undefined) {
            this.valueDate = source.valueDate;
        }
        if (source["_valueDate"] !== undefined) {
            this._valueDate = new fhirModels.Element(source._valueDate);
        }
        if (source["valueDateTime"] !== undefined) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source["_valueDateTime"] !== undefined) {
            this._valueDateTime = new fhirModels.Element(source._valueDateTime);
        }
        if (source["valueTime"] !== undefined) {
            this.valueTime = source.valueTime;
        }
        if (source["_valueTime"] !== undefined) {
            this._valueTime = new fhirModels.Element(source._valueTime);
        }
        if (source["valueString"] !== undefined) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"] !== undefined) {
            this._valueString = new fhirModels.Element(source._valueString);
        }
        if (source["valueUri"] !== undefined) {
            this.valueUri = source.valueUri;
        }
        if (source["_valueUri"] !== undefined) {
            this._valueUri = new fhirModels.Element(source._valueUri);
        }
        if (source["valueAttachment"] !== undefined) {
            this.valueAttachment = new fhirModels.Attachment(source.valueAttachment);
        }
        if (source["valueCoding"] !== undefined) {
            this.valueCoding = new fhirModels.Coding(source.valueCoding);
        }
        if (source["valueQuantity"] !== undefined) {
            this.valueQuantity = new fhirModels.Quantity(source.valueQuantity);
        }
        if (source["valueReference"] !== undefined) {
            this.valueReference = new fhirModels.Reference(source.valueReference);
        }
    }
    /**
     * Factory function to create a QuestionnaireResponseItemAnswer from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new QuestionnaireResponseItemAnswer(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `QuestionnaireResponseItemAnswer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current QuestionnaireResponseItemAnswer contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.QuestionnaireResponseItemAnswer = QuestionnaireResponseItemAnswer;
/**
 * Groups cannot have answers and therefore must nest directly within item. When dealing with questions, nesting must occur within each answer because some questions may have multiple answers (and the nesting occurs for each answer).
 */
class QuestionnaireResponseItem extends fhirModels.BackboneElement {
    /**
     * Default constructor for QuestionnaireResponseItem from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["answer"] !== undefined) {
            this.answer = source.answer.map((x) => new fhirModels.QuestionnaireResponseItemAnswer(x));
        }
        if (source["definition"] !== undefined) {
            this.definition = source.definition;
        }
        if (source["_definition"] !== undefined) {
            this._definition = new fhirModels.Element(source._definition);
        }
        if (source["item"] !== undefined) {
            this.item = source.item.map((x) => new fhirModels.QuestionnaireResponseItem(x));
        }
        if (source["linkId"] !== undefined) {
            this.linkId = source.linkId;
        }
        if (source["_linkId"] !== undefined) {
            this._linkId = new fhirModels.Element(source._linkId);
        }
        if (source["text"] !== undefined) {
            this.text = source.text;
        }
        if (source["_text"] !== undefined) {
            this._text = new fhirModels.Element(source._text);
        }
    }
    /**
     * Factory function to create a QuestionnaireResponseItem from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new QuestionnaireResponseItem(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `QuestionnaireResponseItem is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current QuestionnaireResponseItem contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["linkId"] === undefined) {
            missingElements.push("linkId");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.QuestionnaireResponseItem = QuestionnaireResponseItem;
/**
 * A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
 */
class QuestionnaireResponse extends fhirModels.DomainResource {
    /**
     * Default constructor for QuestionnaireResponse from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        /**
         * Resource Type Name
         */
        this.resourceType = "QuestionnaireResponse";
        if ((source['resourceType'] !== "QuestionnaireResponse") || (source['resourceType'] !== undefined)) {
            throw 'Invalid resourceType for a QuestionnaireResponse';
        }
        if (source["author"] !== undefined) {
            this.author = new fhirModels.Reference(source.author);
        }
        if (source["authored"] !== undefined) {
            this.authored = source.authored;
        }
        if (source["_authored"] !== undefined) {
            this._authored = new fhirModels.Element(source._authored);
        }
        if (source["basedOn"] !== undefined) {
            this.basedOn = source.basedOn.map((x) => new fhirModels.Reference(x));
        }
        if (source["encounter"] !== undefined) {
            this.encounter = new fhirModels.Reference(source.encounter);
        }
        if (source["identifier"] !== undefined) {
            this.identifier = new fhirModels.Identifier(source.identifier);
        }
        if (source["item"] !== undefined) {
            this.item = source.item.map((x) => new fhirModels.QuestionnaireResponseItem(x));
        }
        if (source["partOf"] !== undefined) {
            this.partOf = source.partOf.map((x) => new fhirModels.Reference(x));
        }
        if (source["questionnaire"] !== undefined) {
            this.questionnaire = source.questionnaire;
        }
        if (source["_questionnaire"] !== undefined) {
            this._questionnaire = new fhirModels.Element(source._questionnaire);
        }
        if (source["source"] !== undefined) {
            this.source = new fhirModels.Reference(source.source);
        }
        if (source["status"] !== undefined) {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
        if (source["subject"] !== undefined) {
            this.subject = new fhirModels.Reference(source.subject);
        }
    }
    /**
     * Factory function to create a QuestionnaireResponse from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new QuestionnaireResponse(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `QuestionnaireResponse is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current QuestionnaireResponse contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.QuestionnaireResponse = QuestionnaireResponse;
/**
 * Code Values for the QuestionnaireResponse.status field
 */
var QuestionnaireResponseStatusEnum;
(function (QuestionnaireResponseStatusEnum) {
    QuestionnaireResponseStatusEnum["IN_PROGRESS"] = "in-progress";
    QuestionnaireResponseStatusEnum["COMPLETED"] = "completed";
    QuestionnaireResponseStatusEnum["AMENDED"] = "amended";
    QuestionnaireResponseStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    QuestionnaireResponseStatusEnum["STOPPED"] = "stopped";
})(QuestionnaireResponseStatusEnum = exports.QuestionnaireResponseStatusEnum || (exports.QuestionnaireResponseStatusEnum = {}));
//# sourceMappingURL=QuestionnaireResponse.js.map