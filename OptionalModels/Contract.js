"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractStatusEnum = exports.Contract = exports.ContractRule = exports.ContractLegal = exports.ContractFriendly = exports.ContractSigner = exports.ContractTerm = exports.ContractTermAction = exports.ContractTermActionSubject = exports.ContractTermAsset = exports.ContractTermAssetValuedItem = exports.ContractTermAssetContext = exports.ContractTermOffer = exports.ContractTermOfferAnswer = exports.ContractTermOfferParty = exports.ContractTermSecurityLabel = exports.ContractContentDefinitionPublicationStatusEnum = exports.ContractContentDefinition = void 0;
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
const fhirModels = __importStar(require("../optionalmodels"));
/**
 * Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
 */
class ContractContentDefinition extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractContentDefinition from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["copyright"] !== undefined) {
            this.copyright = source.copyright;
        }
        if (source["_copyright"] !== undefined) {
            this._copyright = new fhirModels.Element(source._copyright);
        }
        if (source["publicationDate"] !== undefined) {
            this.publicationDate = source.publicationDate;
        }
        if (source["_publicationDate"] !== undefined) {
            this._publicationDate = new fhirModels.Element(source._publicationDate);
        }
        if (source["publicationStatus"] !== undefined) {
            this.publicationStatus = source.publicationStatus;
        }
        if (source["_publicationStatus"] !== undefined) {
            this._publicationStatus = new fhirModels.Element(source._publicationStatus);
        }
        if (source["publisher"] !== undefined) {
            this.publisher = new fhirModels.Reference(source.publisher);
        }
        if (source["subType"] !== undefined) {
            this.subType = new fhirModels.CodeableConcept(source.subType);
        }
        if (source["type"] !== undefined) {
            this.type = new fhirModels.CodeableConcept(source.type);
        }
    }
    /**
     * Factory function to create a ContractContentDefinition from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractContentDefinition(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractContentDefinition is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractContentDefinition contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["publicationStatus"] === undefined) {
            missingElements.push("publicationStatus");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractContentDefinition = ContractContentDefinition;
/**
 * Code Values for the Contract.contentDefinition.publicationStatus field
 */
var ContractContentDefinitionPublicationStatusEnum;
(function (ContractContentDefinitionPublicationStatusEnum) {
    ContractContentDefinitionPublicationStatusEnum["AMENDED"] = "amended";
    ContractContentDefinitionPublicationStatusEnum["APPENDED"] = "appended";
    ContractContentDefinitionPublicationStatusEnum["CANCELLED"] = "cancelled";
    ContractContentDefinitionPublicationStatusEnum["DISPUTED"] = "disputed";
    ContractContentDefinitionPublicationStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    ContractContentDefinitionPublicationStatusEnum["EXECUTABLE"] = "executable";
    ContractContentDefinitionPublicationStatusEnum["EXECUTED"] = "executed";
    ContractContentDefinitionPublicationStatusEnum["NEGOTIABLE"] = "negotiable";
    ContractContentDefinitionPublicationStatusEnum["OFFERED"] = "offered";
    ContractContentDefinitionPublicationStatusEnum["POLICY"] = "policy";
    ContractContentDefinitionPublicationStatusEnum["REJECTED"] = "rejected";
    ContractContentDefinitionPublicationStatusEnum["RENEWED"] = "renewed";
    ContractContentDefinitionPublicationStatusEnum["REVOKED"] = "revoked";
    ContractContentDefinitionPublicationStatusEnum["RESOLVED"] = "resolved";
    ContractContentDefinitionPublicationStatusEnum["TERMINATED"] = "terminated";
})(ContractContentDefinitionPublicationStatusEnum = exports.ContractContentDefinitionPublicationStatusEnum || (exports.ContractContentDefinitionPublicationStatusEnum = {}));
/**
 * Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
 */
class ContractTermSecurityLabel extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermSecurityLabel from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["category"] !== undefined) {
            this.category = source.category.map((x) => new fhirModels.Coding(x));
        }
        if (source["classification"] !== undefined) {
            this.classification = new fhirModels.Coding(source.classification);
        }
        if (source["control"] !== undefined) {
            this.control = source.control.map((x) => new fhirModels.Coding(x));
        }
        if (source["number"] !== undefined) {
            this.number = source.number.map((x) => (x));
        }
        if (source["_number"] !== undefined) {
            this._number = source._number.map((x) => new fhirModels.Element(x));
        }
    }
    /**
     * Factory function to create a ContractTermSecurityLabel from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermSecurityLabel(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermSecurityLabel is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermSecurityLabel contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["classification"] === undefined) {
            missingElements.push("classification");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermSecurityLabel = ContractTermSecurityLabel;
/**
 * Offer Recipient.
 */
class ContractTermOfferParty extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermOfferParty from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["reference"] !== undefined) {
            this.reference = source.reference.map((x) => new fhirModels.Reference(x));
        }
        if (source["role"] !== undefined) {
            this.role = new fhirModels.CodeableConcept(source.role);
        }
    }
    /**
     * Factory function to create a ContractTermOfferParty from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermOfferParty(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermOfferParty is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermOfferParty contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if ((this["reference"] === undefined) || (this["reference"].length === 0)) {
            missingElements.push("reference");
        }
        if (this["role"] === undefined) {
            missingElements.push("role");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermOfferParty = ContractTermOfferParty;
/**
 * Response to offer text.
 */
class ContractTermOfferAnswer extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermOfferAnswer from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["valueBoolean"] !== undefined) {
            this.valueBoolean = source.valueBoolean;
        }
        if (source["_valueBoolean"] !== undefined) {
            this._valueBoolean = new fhirModels.Element(source._valueBoolean);
        }
        if (source["valueDecimal"] !== undefined) {
            this.valueDecimal = source.valueDecimal;
        }
        if (source["_valueDecimal"] !== undefined) {
            this._valueDecimal = new fhirModels.Element(source._valueDecimal);
        }
        if (source["valueInteger"] !== undefined) {
            this.valueInteger = source.valueInteger;
        }
        if (source["_valueInteger"] !== undefined) {
            this._valueInteger = new fhirModels.Element(source._valueInteger);
        }
        if (source["valueDate"] !== undefined) {
            this.valueDate = source.valueDate;
        }
        if (source["_valueDate"] !== undefined) {
            this._valueDate = new fhirModels.Element(source._valueDate);
        }
        if (source["valueDateTime"] !== undefined) {
            this.valueDateTime = source.valueDateTime;
        }
        if (source["_valueDateTime"] !== undefined) {
            this._valueDateTime = new fhirModels.Element(source._valueDateTime);
        }
        if (source["valueTime"] !== undefined) {
            this.valueTime = source.valueTime;
        }
        if (source["_valueTime"] !== undefined) {
            this._valueTime = new fhirModels.Element(source._valueTime);
        }
        if (source["valueString"] !== undefined) {
            this.valueString = source.valueString;
        }
        if (source["_valueString"] !== undefined) {
            this._valueString = new fhirModels.Element(source._valueString);
        }
        if (source["valueUri"] !== undefined) {
            this.valueUri = source.valueUri;
        }
        if (source["_valueUri"] !== undefined) {
            this._valueUri = new fhirModels.Element(source._valueUri);
        }
        if (source["valueAttachment"] !== undefined) {
            this.valueAttachment = new fhirModels.Attachment(source.valueAttachment);
        }
        if (source["valueCoding"] !== undefined) {
            this.valueCoding = new fhirModels.Coding(source.valueCoding);
        }
        if (source["valueQuantity"] !== undefined) {
            this.valueQuantity = new fhirModels.Quantity(source.valueQuantity);
        }
        if (source["valueReference"] !== undefined) {
            this.valueReference = new fhirModels.Reference(source.valueReference);
        }
    }
    /**
     * Factory function to create a ContractTermOfferAnswer from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermOfferAnswer(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermOfferAnswer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermOfferAnswer contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermOfferAnswer = ContractTermOfferAnswer;
/**
 * The matter of concern in the context of this provision of the agrement.
 */
class ContractTermOffer extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermOffer from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["answer"] !== undefined) {
            this.answer = source.answer.map((x) => new fhirModels.ContractTermOfferAnswer(x));
        }
        if (source["decision"] !== undefined) {
            this.decision = new fhirModels.CodeableConcept(source.decision);
        }
        if (source["decisionMode"] !== undefined) {
            this.decisionMode = source.decisionMode.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["identifier"] !== undefined) {
            this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x));
        }
        if (source["linkId"] !== undefined) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"] !== undefined) {
            this._linkId = source._linkId.map((x) => new fhirModels.Element(x));
        }
        if (source["party"] !== undefined) {
            this.party = source.party.map((x) => new fhirModels.ContractTermOfferParty(x));
        }
        if (source["securityLabelNumber"] !== undefined) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"] !== undefined) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhirModels.Element(x));
        }
        if (source["text"] !== undefined) {
            this.text = source.text;
        }
        if (source["_text"] !== undefined) {
            this._text = new fhirModels.Element(source._text);
        }
        if (source["topic"] !== undefined) {
            this.topic = new fhirModels.Reference(source.topic);
        }
        if (source["type"] !== undefined) {
            this.type = new fhirModels.CodeableConcept(source.type);
        }
    }
    /**
     * Factory function to create a ContractTermOffer from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermOffer(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermOffer is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermOffer contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermOffer = ContractTermOffer;
/**
 * Circumstance of the asset.
 */
class ContractTermAssetContext extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermAssetContext from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["code"] !== undefined) {
            this.code = source.code.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["reference"] !== undefined) {
            this.reference = new fhirModels.Reference(source.reference);
        }
        if (source["text"] !== undefined) {
            this.text = source.text;
        }
        if (source["_text"] !== undefined) {
            this._text = new fhirModels.Element(source._text);
        }
    }
    /**
     * Factory function to create a ContractTermAssetContext from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermAssetContext(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAssetContext is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermAssetContext contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermAssetContext = ContractTermAssetContext;
/**
 * Contract Valued Item List.
 */
class ContractTermAssetValuedItem extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermAssetValuedItem from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["effectiveTime"] !== undefined) {
            this.effectiveTime = source.effectiveTime;
        }
        if (source["_effectiveTime"] !== undefined) {
            this._effectiveTime = new fhirModels.Element(source._effectiveTime);
        }
        if (source["entityCodeableConcept"] !== undefined) {
            this.entityCodeableConcept = new fhirModels.CodeableConcept(source.entityCodeableConcept);
        }
        if (source["entityReference"] !== undefined) {
            this.entityReference = new fhirModels.Reference(source.entityReference);
        }
        if (source["factor"] !== undefined) {
            this.factor = source.factor;
        }
        if (source["_factor"] !== undefined) {
            this._factor = new fhirModels.Element(source._factor);
        }
        if (source["identifier"] !== undefined) {
            this.identifier = new fhirModels.Identifier(source.identifier);
        }
        if (source["linkId"] !== undefined) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"] !== undefined) {
            this._linkId = source._linkId.map((x) => new fhirModels.Element(x));
        }
        if (source["net"] !== undefined) {
            this.net = new fhirModels.Money(source.net);
        }
        if (source["payment"] !== undefined) {
            this.payment = source.payment;
        }
        if (source["_payment"] !== undefined) {
            this._payment = new fhirModels.Element(source._payment);
        }
        if (source["paymentDate"] !== undefined) {
            this.paymentDate = source.paymentDate;
        }
        if (source["_paymentDate"] !== undefined) {
            this._paymentDate = new fhirModels.Element(source._paymentDate);
        }
        if (source["points"] !== undefined) {
            this.points = source.points;
        }
        if (source["_points"] !== undefined) {
            this._points = new fhirModels.Element(source._points);
        }
        if (source["quantity"] !== undefined) {
            this.quantity = new fhirModels.Quantity(source.quantity);
        }
        if (source["recipient"] !== undefined) {
            this.recipient = new fhirModels.Reference(source.recipient);
        }
        if (source["responsible"] !== undefined) {
            this.responsible = new fhirModels.Reference(source.responsible);
        }
        if (source["securityLabelNumber"] !== undefined) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"] !== undefined) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhirModels.Element(x));
        }
        if (source["unitPrice"] !== undefined) {
            this.unitPrice = new fhirModels.Money(source.unitPrice);
        }
    }
    /**
     * Factory function to create a ContractTermAssetValuedItem from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermAssetValuedItem(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAssetValuedItem is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermAssetValuedItem contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermAssetValuedItem = ContractTermAssetValuedItem;
/**
 * Contract Term Asset List.
 */
class ContractTermAsset extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermAsset from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["answer"] !== undefined) {
            this.answer = source.answer.map((x) => new fhirModels.ContractTermOfferAnswer(x));
        }
        if (source["condition"] !== undefined) {
            this.condition = source.condition;
        }
        if (source["_condition"] !== undefined) {
            this._condition = new fhirModels.Element(source._condition);
        }
        if (source["context"] !== undefined) {
            this.context = source.context.map((x) => new fhirModels.ContractTermAssetContext(x));
        }
        if (source["linkId"] !== undefined) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"] !== undefined) {
            this._linkId = source._linkId.map((x) => new fhirModels.Element(x));
        }
        if (source["period"] !== undefined) {
            this.period = source.period.map((x) => new fhirModels.Period(x));
        }
        if (source["periodType"] !== undefined) {
            this.periodType = source.periodType.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["relationship"] !== undefined) {
            this.relationship = new fhirModels.Coding(source.relationship);
        }
        if (source["scope"] !== undefined) {
            this.scope = new fhirModels.CodeableConcept(source.scope);
        }
        if (source["securityLabelNumber"] !== undefined) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"] !== undefined) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhirModels.Element(x));
        }
        if (source["subtype"] !== undefined) {
            this.subtype = source.subtype.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["text"] !== undefined) {
            this.text = source.text;
        }
        if (source["_text"] !== undefined) {
            this._text = new fhirModels.Element(source._text);
        }
        if (source["type"] !== undefined) {
            this.type = source.type.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["typeReference"] !== undefined) {
            this.typeReference = source.typeReference.map((x) => new fhirModels.Reference(x));
        }
        if (source["usePeriod"] !== undefined) {
            this.usePeriod = source.usePeriod.map((x) => new fhirModels.Period(x));
        }
        if (source["valuedItem"] !== undefined) {
            this.valuedItem = source.valuedItem.map((x) => new fhirModels.ContractTermAssetValuedItem(x));
        }
    }
    /**
     * Factory function to create a ContractTermAsset from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermAsset(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAsset is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermAsset contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermAsset = ContractTermAsset;
/**
 * Entity of the action.
 */
class ContractTermActionSubject extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermActionSubject from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["reference"] !== undefined) {
            this.reference = source.reference.map((x) => new fhirModels.Reference(x));
        }
        if (source["role"] !== undefined) {
            this.role = new fhirModels.CodeableConcept(source.role);
        }
    }
    /**
     * Factory function to create a ContractTermActionSubject from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermActionSubject(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermActionSubject is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermActionSubject contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if ((this["reference"] === undefined) || (this["reference"].length === 0)) {
            missingElements.push("reference");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermActionSubject = ContractTermActionSubject;
/**
 * Several agents may be associated (i.e. has some responsibility for an activity) with an activity and vice-versa.
 * For example, in cases of actions initiated by one user for other users, or in events that involve more than one user, hardware device, software, or system process. However, only one user may be the initiator/requestor for the event.
 */
class ContractTermAction extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTermAction from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["context"] !== undefined) {
            this.context = new fhirModels.Reference(source.context);
        }
        if (source["contextLinkId"] !== undefined) {
            this.contextLinkId = source.contextLinkId.map((x) => (x));
        }
        if (source["_contextLinkId"] !== undefined) {
            this._contextLinkId = source._contextLinkId.map((x) => new fhirModels.Element(x));
        }
        if (source["doNotPerform"] !== undefined) {
            this.doNotPerform = source.doNotPerform;
        }
        if (source["_doNotPerform"] !== undefined) {
            this._doNotPerform = new fhirModels.Element(source._doNotPerform);
        }
        if (source["intent"] !== undefined) {
            this.intent = new fhirModels.CodeableConcept(source.intent);
        }
        if (source["linkId"] !== undefined) {
            this.linkId = source.linkId.map((x) => (x));
        }
        if (source["_linkId"] !== undefined) {
            this._linkId = source._linkId.map((x) => new fhirModels.Element(x));
        }
        if (source["note"] !== undefined) {
            this.note = source.note.map((x) => new fhirModels.Annotation(x));
        }
        if (source["occurrenceDateTime"] !== undefined) {
            this.occurrenceDateTime = source.occurrenceDateTime;
        }
        if (source["_occurrenceDateTime"] !== undefined) {
            this._occurrenceDateTime = new fhirModels.Element(source._occurrenceDateTime);
        }
        if (source["occurrencePeriod"] !== undefined) {
            this.occurrencePeriod = new fhirModels.Period(source.occurrencePeriod);
        }
        if (source["occurrenceTiming"] !== undefined) {
            this.occurrenceTiming = new fhirModels.Timing(source.occurrenceTiming);
        }
        if (source["performer"] !== undefined) {
            this.performer = new fhirModels.Reference(source.performer);
        }
        if (source["performerLinkId"] !== undefined) {
            this.performerLinkId = source.performerLinkId.map((x) => (x));
        }
        if (source["_performerLinkId"] !== undefined) {
            this._performerLinkId = source._performerLinkId.map((x) => new fhirModels.Element(x));
        }
        if (source["performerRole"] !== undefined) {
            this.performerRole = new fhirModels.CodeableConcept(source.performerRole);
        }
        if (source["performerType"] !== undefined) {
            this.performerType = source.performerType.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["reason"] !== undefined) {
            this.reason = source.reason.map((x) => (x));
        }
        if (source["_reason"] !== undefined) {
            this._reason = source._reason.map((x) => new fhirModels.Element(x));
        }
        if (source["reasonCode"] !== undefined) {
            this.reasonCode = source.reasonCode.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["reasonLinkId"] !== undefined) {
            this.reasonLinkId = source.reasonLinkId.map((x) => (x));
        }
        if (source["_reasonLinkId"] !== undefined) {
            this._reasonLinkId = source._reasonLinkId.map((x) => new fhirModels.Element(x));
        }
        if (source["reasonReference"] !== undefined) {
            this.reasonReference = source.reasonReference.map((x) => new fhirModels.Reference(x));
        }
        if (source["requester"] !== undefined) {
            this.requester = source.requester.map((x) => new fhirModels.Reference(x));
        }
        if (source["requesterLinkId"] !== undefined) {
            this.requesterLinkId = source.requesterLinkId.map((x) => (x));
        }
        if (source["_requesterLinkId"] !== undefined) {
            this._requesterLinkId = source._requesterLinkId.map((x) => new fhirModels.Element(x));
        }
        if (source["securityLabelNumber"] !== undefined) {
            this.securityLabelNumber = source.securityLabelNumber.map((x) => (x));
        }
        if (source["_securityLabelNumber"] !== undefined) {
            this._securityLabelNumber = source._securityLabelNumber.map((x) => new fhirModels.Element(x));
        }
        if (source["status"] !== undefined) {
            this.status = new fhirModels.CodeableConcept(source.status);
        }
        if (source["subject"] !== undefined) {
            this.subject = source.subject.map((x) => new fhirModels.ContractTermActionSubject(x));
        }
        if (source["type"] !== undefined) {
            this.type = new fhirModels.CodeableConcept(source.type);
        }
    }
    /**
     * Factory function to create a ContractTermAction from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTermAction(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTermAction is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTermAction contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["intent"] === undefined) {
            missingElements.push("intent");
        }
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTermAction = ContractTermAction;
/**
 * One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
 */
class ContractTerm extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractTerm from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["action"] !== undefined) {
            this.action = source.action.map((x) => new fhirModels.ContractTermAction(x));
        }
        if (source["applies"] !== undefined) {
            this.applies = new fhirModels.Period(source.applies);
        }
        if (source["asset"] !== undefined) {
            this.asset = source.asset.map((x) => new fhirModels.ContractTermAsset(x));
        }
        if (source["group"] !== undefined) {
            this.group = source.group.map((x) => new fhirModels.ContractTerm(x));
        }
        if (source["identifier"] !== undefined) {
            this.identifier = new fhirModels.Identifier(source.identifier);
        }
        if (source["issued"] !== undefined) {
            this.issued = source.issued;
        }
        if (source["_issued"] !== undefined) {
            this._issued = new fhirModels.Element(source._issued);
        }
        if (source["offer"] !== undefined) {
            this.offer = new fhirModels.ContractTermOffer(source.offer);
        }
        if (source["securityLabel"] !== undefined) {
            this.securityLabel = source.securityLabel.map((x) => new fhirModels.ContractTermSecurityLabel(x));
        }
        if (source["subType"] !== undefined) {
            this.subType = new fhirModels.CodeableConcept(source.subType);
        }
        if (source["text"] !== undefined) {
            this.text = source.text;
        }
        if (source["_text"] !== undefined) {
            this._text = new fhirModels.Element(source._text);
        }
        if (source["topicCodeableConcept"] !== undefined) {
            this.topicCodeableConcept = new fhirModels.CodeableConcept(source.topicCodeableConcept);
        }
        if (source["topicReference"] !== undefined) {
            this.topicReference = new fhirModels.Reference(source.topicReference);
        }
        if (source["type"] !== undefined) {
            this.type = new fhirModels.CodeableConcept(source.type);
        }
    }
    /**
     * Factory function to create a ContractTerm from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractTerm(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractTerm is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractTerm contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["offer"] === undefined) {
            missingElements.push("offer");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractTerm = ContractTerm;
/**
 * Signers who are principal parties to the contract are bound by the Contract.activity related to the Contract.topic, and the Contract.term(s), which either extend or restrict the overall action on the topic by, for example, stipulating specific policies or obligations constraining actions, action reason, or agents with respect to some or all of the topic.
 * For example, specifying how policies or obligations shall constrain actions and action reasons permitted or denied on all or a subset of the Contract.topic (e.g., all or a portion of property being transferred by the contract), agents (e.g., who can resell, assign interests, or alter the property being transferred by the contract), actions, and action reasons; or with respect to Contract.terms, stipulating, extending, or limiting the Contract.period of applicability or valuation of items under consideration.
 */
class ContractSigner extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractSigner from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["party"] !== undefined) {
            this.party = new fhirModels.Reference(source.party);
        }
        if (source["signature"] !== undefined) {
            this.signature = source.signature.map((x) => new fhirModels.Signature(x));
        }
        if (source["type"] !== undefined) {
            this.type = new fhirModels.Coding(source.type);
        }
    }
    /**
     * Factory function to create a ContractSigner from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractSigner(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractSigner is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractSigner contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["party"] === undefined) {
            missingElements.push("party");
        }
        if ((this["signature"] === undefined) || (this["signature"].length === 0)) {
            missingElements.push("signature");
        }
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractSigner = ContractSigner;
/**
 * The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
 */
class ContractFriendly extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractFriendly from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["contentAttachment"] !== undefined) {
            this.contentAttachment = new fhirModels.Attachment(source.contentAttachment);
        }
        if (source["contentReference"] !== undefined) {
            this.contentReference = new fhirModels.Reference(source.contentReference);
        }
    }
    /**
     * Factory function to create a ContractFriendly from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractFriendly(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractFriendly is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractFriendly contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractFriendly = ContractFriendly;
/**
 * List of Legal expressions or representations of this Contract.
 */
class ContractLegal extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractLegal from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["contentAttachment"] !== undefined) {
            this.contentAttachment = new fhirModels.Attachment(source.contentAttachment);
        }
        if (source["contentReference"] !== undefined) {
            this.contentReference = new fhirModels.Reference(source.contentReference);
        }
    }
    /**
     * Factory function to create a ContractLegal from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractLegal(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractLegal is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractLegal contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractLegal = ContractLegal;
/**
 * List of Computable Policy Rule Language Representations of this Contract.
 */
class ContractRule extends fhirModels.BackboneElement {
    /**
     * Default constructor for ContractRule from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["contentAttachment"] !== undefined) {
            this.contentAttachment = new fhirModels.Attachment(source.contentAttachment);
        }
        if (source["contentReference"] !== undefined) {
            this.contentReference = new fhirModels.Reference(source.contentReference);
        }
    }
    /**
     * Factory function to create a ContractRule from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new ContractRule(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `ContractRule is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current ContractRule contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.ContractRule = ContractRule;
/**
 * Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
 */
class Contract extends fhirModels.DomainResource {
    /**
     * Default constructor for Contract from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        /**
         * Resource Type Name
         */
        this.resourceType = "Contract";
        if ((source['resourceType'] !== "Contract") || (source['resourceType'] !== undefined)) {
            throw 'Invalid resourceType for a Contract';
        }
        if (source["alias"] !== undefined) {
            this.alias = source.alias.map((x) => (x));
        }
        if (source["_alias"] !== undefined) {
            this._alias = source._alias.map((x) => new fhirModels.Element(x));
        }
        if (source["applies"] !== undefined) {
            this.applies = new fhirModels.Period(source.applies);
        }
        if (source["author"] !== undefined) {
            this.author = new fhirModels.Reference(source.author);
        }
        if (source["authority"] !== undefined) {
            this.authority = source.authority.map((x) => new fhirModels.Reference(x));
        }
        if (source["contentDefinition"] !== undefined) {
            this.contentDefinition = new fhirModels.ContractContentDefinition(source.contentDefinition);
        }
        if (source["contentDerivative"] !== undefined) {
            this.contentDerivative = new fhirModels.CodeableConcept(source.contentDerivative);
        }
        if (source["domain"] !== undefined) {
            this.domain = source.domain.map((x) => new fhirModels.Reference(x));
        }
        if (source["expirationType"] !== undefined) {
            this.expirationType = new fhirModels.CodeableConcept(source.expirationType);
        }
        if (source["friendly"] !== undefined) {
            this.friendly = source.friendly.map((x) => new fhirModels.ContractFriendly(x));
        }
        if (source["identifier"] !== undefined) {
            this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x));
        }
        if (source["instantiatesCanonical"] !== undefined) {
            this.instantiatesCanonical = new fhirModels.Reference(source.instantiatesCanonical);
        }
        if (source["instantiatesUri"] !== undefined) {
            this.instantiatesUri = source.instantiatesUri;
        }
        if (source["_instantiatesUri"] !== undefined) {
            this._instantiatesUri = new fhirModels.Element(source._instantiatesUri);
        }
        if (source["issued"] !== undefined) {
            this.issued = source.issued;
        }
        if (source["_issued"] !== undefined) {
            this._issued = new fhirModels.Element(source._issued);
        }
        if (source["legal"] !== undefined) {
            this.legal = source.legal.map((x) => new fhirModels.ContractLegal(x));
        }
        if (source["legallyBindingAttachment"] !== undefined) {
            this.legallyBindingAttachment = new fhirModels.Attachment(source.legallyBindingAttachment);
        }
        if (source["legallyBindingReference"] !== undefined) {
            this.legallyBindingReference = new fhirModels.Reference(source.legallyBindingReference);
        }
        if (source["legalState"] !== undefined) {
            this.legalState = new fhirModels.CodeableConcept(source.legalState);
        }
        if (source["name"] !== undefined) {
            this.name = source.name;
        }
        if (source["_name"] !== undefined) {
            this._name = new fhirModels.Element(source._name);
        }
        if (source["relevantHistory"] !== undefined) {
            this.relevantHistory = source.relevantHistory.map((x) => new fhirModels.Reference(x));
        }
        if (source["rule"] !== undefined) {
            this.rule = source.rule.map((x) => new fhirModels.ContractRule(x));
        }
        if (source["scope"] !== undefined) {
            this.scope = new fhirModels.CodeableConcept(source.scope);
        }
        if (source["signer"] !== undefined) {
            this.signer = source.signer.map((x) => new fhirModels.ContractSigner(x));
        }
        if (source["site"] !== undefined) {
            this.site = source.site.map((x) => new fhirModels.Reference(x));
        }
        if (source["status"] !== undefined) {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
        if (source["subject"] !== undefined) {
            this.subject = source.subject.map((x) => new fhirModels.Reference(x));
        }
        if (source["subtitle"] !== undefined) {
            this.subtitle = source.subtitle;
        }
        if (source["_subtitle"] !== undefined) {
            this._subtitle = new fhirModels.Element(source._subtitle);
        }
        if (source["subType"] !== undefined) {
            this.subType = source.subType.map((x) => new fhirModels.CodeableConcept(x));
        }
        if (source["supportingInfo"] !== undefined) {
            this.supportingInfo = source.supportingInfo.map((x) => new fhirModels.Reference(x));
        }
        if (source["term"] !== undefined) {
            this.term = source.term.map((x) => new fhirModels.ContractTerm(x));
        }
        if (source["title"] !== undefined) {
            this.title = source.title;
        }
        if (source["_title"] !== undefined) {
            this._title = new fhirModels.Element(source._title);
        }
        if (source["topicCodeableConcept"] !== undefined) {
            this.topicCodeableConcept = new fhirModels.CodeableConcept(source.topicCodeableConcept);
        }
        if (source["topicReference"] !== undefined) {
            this.topicReference = new fhirModels.Reference(source.topicReference);
        }
        if (source["type"] !== undefined) {
            this.type = new fhirModels.CodeableConcept(source.type);
        }
        if (source["url"] !== undefined) {
            this.url = source.url;
        }
        if (source["_url"] !== undefined) {
            this._url = new fhirModels.Element(source._url);
        }
        if (source["version"] !== undefined) {
            this.version = source.version;
        }
        if (source["_version"] !== undefined) {
            this._version = new fhirModels.Element(source._version);
        }
    }
    /**
     * Factory function to create a Contract from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new Contract(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `Contract is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current Contract contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.Contract = Contract;
/**
 * Code Values for the Contract.status field
 */
var ContractStatusEnum;
(function (ContractStatusEnum) {
    ContractStatusEnum["AMENDED"] = "amended";
    ContractStatusEnum["APPENDED"] = "appended";
    ContractStatusEnum["CANCELLED"] = "cancelled";
    ContractStatusEnum["DISPUTED"] = "disputed";
    ContractStatusEnum["ENTERED_IN_ERROR"] = "entered-in-error";
    ContractStatusEnum["EXECUTABLE"] = "executable";
    ContractStatusEnum["EXECUTED"] = "executed";
    ContractStatusEnum["NEGOTIABLE"] = "negotiable";
    ContractStatusEnum["OFFERED"] = "offered";
    ContractStatusEnum["POLICY"] = "policy";
    ContractStatusEnum["REJECTED"] = "rejected";
    ContractStatusEnum["RENEWED"] = "renewed";
    ContractStatusEnum["REVOKED"] = "revoked";
    ContractStatusEnum["RESOLVED"] = "resolved";
    ContractStatusEnum["TERMINATED"] = "terminated";
})(ContractStatusEnum = exports.ContractStatusEnum || (exports.ContractStatusEnum = {}));
//# sourceMappingURL=Contract.js.map