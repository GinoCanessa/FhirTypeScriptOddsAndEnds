var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../optionalmodels';
/**
 * A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
 */
var MolecularSequenceReferenceSeq = /** @class */ (function (_super) {
    __extends(MolecularSequenceReferenceSeq, _super);
    /**
     * Default constructor for MolecularSequenceReferenceSeq from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceReferenceSeq(source) {
        var _this = _super.call(this, source) || this;
        if (source["chromosome"] !== undefined) {
            _this.chromosome = new fhirModels.CodeableConcept(source.chromosome);
        }
        if (source["genomeBuild"] !== undefined) {
            _this.genomeBuild = source.genomeBuild;
        }
        if (source["_genomeBuild"] !== undefined) {
            _this._genomeBuild = new fhirModels.Element(source._genomeBuild);
        }
        if (source["orientation"] !== undefined) {
            _this.orientation = source.orientation;
        }
        if (source["_orientation"] !== undefined) {
            _this._orientation = new fhirModels.Element(source._orientation);
        }
        if (source["referenceSeqId"] !== undefined) {
            _this.referenceSeqId = new fhirModels.CodeableConcept(source.referenceSeqId);
        }
        if (source["referenceSeqPointer"] !== undefined) {
            _this.referenceSeqPointer = new fhirModels.Reference(source.referenceSeqPointer);
        }
        if (source["referenceSeqString"] !== undefined) {
            _this.referenceSeqString = source.referenceSeqString;
        }
        if (source["_referenceSeqString"] !== undefined) {
            _this._referenceSeqString = new fhirModels.Element(source._referenceSeqString);
        }
        if (source["strand"] !== undefined) {
            _this.strand = source.strand;
        }
        if (source["_strand"] !== undefined) {
            _this._strand = new fhirModels.Element(source._strand);
        }
        if (source["windowEnd"] !== undefined) {
            _this.windowEnd = source.windowEnd;
        }
        if (source["_windowEnd"] !== undefined) {
            _this._windowEnd = new fhirModels.Element(source._windowEnd);
        }
        if (source["windowStart"] !== undefined) {
            _this.windowStart = source.windowStart;
        }
        if (source["_windowStart"] !== undefined) {
            _this._windowStart = new fhirModels.Element(source._windowStart);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceReferenceSeq from an object that MUST contain all required elements.
     */
    MolecularSequenceReferenceSeq.CreateStrict = function (source) {
        var dest = new MolecularSequenceReferenceSeq(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceReferenceSeq is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceReferenceSeq contains all required elements.
     */
    MolecularSequenceReferenceSeq.prototype.checkRequiredElements = function () {
        var missingElements = [];
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceReferenceSeq;
}(fhirModels.BackboneElement));
export { MolecularSequenceReferenceSeq };
/**
 * Code Values for the MolecularSequence.referenceSeq.orientation field
 */
export var MolecularSequenceReferenceSeqOrientationEnum;
(function (MolecularSequenceReferenceSeqOrientationEnum) {
    MolecularSequenceReferenceSeqOrientationEnum["SENSE"] = "sense";
    MolecularSequenceReferenceSeqOrientationEnum["ANTISENSE"] = "antisense";
})(MolecularSequenceReferenceSeqOrientationEnum || (MolecularSequenceReferenceSeqOrientationEnum = {}));
/**
 * Code Values for the MolecularSequence.referenceSeq.strand field
 */
export var MolecularSequenceReferenceSeqStrandEnum;
(function (MolecularSequenceReferenceSeqStrandEnum) {
    MolecularSequenceReferenceSeqStrandEnum["WATSON"] = "watson";
    MolecularSequenceReferenceSeqStrandEnum["CRICK"] = "crick";
})(MolecularSequenceReferenceSeqStrandEnum || (MolecularSequenceReferenceSeqStrandEnum = {}));
/**
 * The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
 */
var MolecularSequenceVariant = /** @class */ (function (_super) {
    __extends(MolecularSequenceVariant, _super);
    /**
     * Default constructor for MolecularSequenceVariant from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceVariant(source) {
        var _this = _super.call(this, source) || this;
        if (source["cigar"] !== undefined) {
            _this.cigar = source.cigar;
        }
        if (source["_cigar"] !== undefined) {
            _this._cigar = new fhirModels.Element(source._cigar);
        }
        if (source["end"] !== undefined) {
            _this.end = source.end;
        }
        if (source["_end"] !== undefined) {
            _this._end = new fhirModels.Element(source._end);
        }
        if (source["observedAllele"] !== undefined) {
            _this.observedAllele = source.observedAllele;
        }
        if (source["_observedAllele"] !== undefined) {
            _this._observedAllele = new fhirModels.Element(source._observedAllele);
        }
        if (source["referenceAllele"] !== undefined) {
            _this.referenceAllele = source.referenceAllele;
        }
        if (source["_referenceAllele"] !== undefined) {
            _this._referenceAllele = new fhirModels.Element(source._referenceAllele);
        }
        if (source["start"] !== undefined) {
            _this.start = source.start;
        }
        if (source["_start"] !== undefined) {
            _this._start = new fhirModels.Element(source._start);
        }
        if (source["variantPointer"] !== undefined) {
            _this.variantPointer = new fhirModels.Reference(source.variantPointer);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceVariant from an object that MUST contain all required elements.
     */
    MolecularSequenceVariant.CreateStrict = function (source) {
        var dest = new MolecularSequenceVariant(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceVariant is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceVariant contains all required elements.
     */
    MolecularSequenceVariant.prototype.checkRequiredElements = function () {
        var missingElements = [];
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceVariant;
}(fhirModels.BackboneElement));
export { MolecularSequenceVariant };
/**
 * Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
 */
var MolecularSequenceQualityRoc = /** @class */ (function (_super) {
    __extends(MolecularSequenceQualityRoc, _super);
    /**
     * Default constructor for MolecularSequenceQualityRoc from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceQualityRoc(source) {
        var _this = _super.call(this, source) || this;
        if (source["fMeasure"] !== undefined) {
            _this.fMeasure = source.fMeasure.map(function (x) { return (x); });
        }
        if (source["_fMeasure"] !== undefined) {
            _this._fMeasure = source._fMeasure.map(function (x) { return new fhirModels.Element(x); });
        }
        if (source["numFN"] !== undefined) {
            _this.numFN = source.numFN.map(function (x) { return (x); });
        }
        if (source["_numFN"] !== undefined) {
            _this._numFN = source._numFN.map(function (x) { return new fhirModels.Element(x); });
        }
        if (source["numFP"] !== undefined) {
            _this.numFP = source.numFP.map(function (x) { return (x); });
        }
        if (source["_numFP"] !== undefined) {
            _this._numFP = source._numFP.map(function (x) { return new fhirModels.Element(x); });
        }
        if (source["numTP"] !== undefined) {
            _this.numTP = source.numTP.map(function (x) { return (x); });
        }
        if (source["_numTP"] !== undefined) {
            _this._numTP = source._numTP.map(function (x) { return new fhirModels.Element(x); });
        }
        if (source["precision"] !== undefined) {
            _this.precision = source.precision.map(function (x) { return (x); });
        }
        if (source["_precision"] !== undefined) {
            _this._precision = source._precision.map(function (x) { return new fhirModels.Element(x); });
        }
        if (source["score"] !== undefined) {
            _this.score = source.score.map(function (x) { return (x); });
        }
        if (source["_score"] !== undefined) {
            _this._score = source._score.map(function (x) { return new fhirModels.Element(x); });
        }
        if (source["sensitivity"] !== undefined) {
            _this.sensitivity = source.sensitivity.map(function (x) { return (x); });
        }
        if (source["_sensitivity"] !== undefined) {
            _this._sensitivity = source._sensitivity.map(function (x) { return new fhirModels.Element(x); });
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceQualityRoc from an object that MUST contain all required elements.
     */
    MolecularSequenceQualityRoc.CreateStrict = function (source) {
        var dest = new MolecularSequenceQualityRoc(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceQualityRoc is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceQualityRoc contains all required elements.
     */
    MolecularSequenceQualityRoc.prototype.checkRequiredElements = function () {
        var missingElements = [];
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceQualityRoc;
}(fhirModels.BackboneElement));
export { MolecularSequenceQualityRoc };
/**
 * An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
 */
var MolecularSequenceQuality = /** @class */ (function (_super) {
    __extends(MolecularSequenceQuality, _super);
    /**
     * Default constructor for MolecularSequenceQuality from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceQuality(source) {
        var _this = _super.call(this, source) || this;
        if (source["end"] !== undefined) {
            _this.end = source.end;
        }
        if (source["_end"] !== undefined) {
            _this._end = new fhirModels.Element(source._end);
        }
        if (source["fScore"] !== undefined) {
            _this.fScore = source.fScore;
        }
        if (source["_fScore"] !== undefined) {
            _this._fScore = new fhirModels.Element(source._fScore);
        }
        if (source["gtFP"] !== undefined) {
            _this.gtFP = source.gtFP;
        }
        if (source["_gtFP"] !== undefined) {
            _this._gtFP = new fhirModels.Element(source._gtFP);
        }
        if (source["method"] !== undefined) {
            _this.method = new fhirModels.CodeableConcept(source.method);
        }
        if (source["precision"] !== undefined) {
            _this.precision = source.precision;
        }
        if (source["_precision"] !== undefined) {
            _this._precision = new fhirModels.Element(source._precision);
        }
        if (source["queryFP"] !== undefined) {
            _this.queryFP = source.queryFP;
        }
        if (source["_queryFP"] !== undefined) {
            _this._queryFP = new fhirModels.Element(source._queryFP);
        }
        if (source["queryTP"] !== undefined) {
            _this.queryTP = source.queryTP;
        }
        if (source["_queryTP"] !== undefined) {
            _this._queryTP = new fhirModels.Element(source._queryTP);
        }
        if (source["recall"] !== undefined) {
            _this.recall = source.recall;
        }
        if (source["_recall"] !== undefined) {
            _this._recall = new fhirModels.Element(source._recall);
        }
        if (source["roc"] !== undefined) {
            _this.roc = new fhirModels.MolecularSequenceQualityRoc(source.roc);
        }
        if (source["score"] !== undefined) {
            _this.score = new fhirModels.Quantity(source.score);
        }
        if (source["standardSequence"] !== undefined) {
            _this.standardSequence = new fhirModels.CodeableConcept(source.standardSequence);
        }
        if (source["start"] !== undefined) {
            _this.start = source.start;
        }
        if (source["_start"] !== undefined) {
            _this._start = new fhirModels.Element(source._start);
        }
        if (source["truthFN"] !== undefined) {
            _this.truthFN = source.truthFN;
        }
        if (source["_truthFN"] !== undefined) {
            _this._truthFN = new fhirModels.Element(source._truthFN);
        }
        if (source["truthTP"] !== undefined) {
            _this.truthTP = source.truthTP;
        }
        if (source["_truthTP"] !== undefined) {
            _this._truthTP = new fhirModels.Element(source._truthTP);
        }
        if (source["type"] !== undefined) {
            _this.type = source.type;
        }
        if (source["_type"] !== undefined) {
            _this._type = new fhirModels.Element(source._type);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceQuality from an object that MUST contain all required elements.
     */
    MolecularSequenceQuality.CreateStrict = function (source) {
        var dest = new MolecularSequenceQuality(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceQuality is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceQuality contains all required elements.
     */
    MolecularSequenceQuality.prototype.checkRequiredElements = function () {
        var missingElements = [];
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceQuality;
}(fhirModels.BackboneElement));
export { MolecularSequenceQuality };
/**
 * Code Values for the MolecularSequence.quality.type field
 */
export var MolecularSequenceQualityTypeEnum;
(function (MolecularSequenceQualityTypeEnum) {
    MolecularSequenceQualityTypeEnum["INDEL"] = "indel";
    MolecularSequenceQualityTypeEnum["SNP"] = "snp";
    MolecularSequenceQualityTypeEnum["UNKNOWN"] = "unknown";
})(MolecularSequenceQualityTypeEnum || (MolecularSequenceQualityTypeEnum = {}));
/**
 * Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
 */
var MolecularSequenceRepository = /** @class */ (function (_super) {
    __extends(MolecularSequenceRepository, _super);
    /**
     * Default constructor for MolecularSequenceRepository from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceRepository(source) {
        var _this = _super.call(this, source) || this;
        if (source["datasetId"] !== undefined) {
            _this.datasetId = source.datasetId;
        }
        if (source["_datasetId"] !== undefined) {
            _this._datasetId = new fhirModels.Element(source._datasetId);
        }
        if (source["name"] !== undefined) {
            _this.name = source.name;
        }
        if (source["_name"] !== undefined) {
            _this._name = new fhirModels.Element(source._name);
        }
        if (source["readsetId"] !== undefined) {
            _this.readsetId = source.readsetId;
        }
        if (source["_readsetId"] !== undefined) {
            _this._readsetId = new fhirModels.Element(source._readsetId);
        }
        if (source["type"] !== undefined) {
            _this.type = source.type;
        }
        if (source["_type"] !== undefined) {
            _this._type = new fhirModels.Element(source._type);
        }
        if (source["url"] !== undefined) {
            _this.url = source.url;
        }
        if (source["_url"] !== undefined) {
            _this._url = new fhirModels.Element(source._url);
        }
        if (source["variantsetId"] !== undefined) {
            _this.variantsetId = source.variantsetId;
        }
        if (source["_variantsetId"] !== undefined) {
            _this._variantsetId = new fhirModels.Element(source._variantsetId);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceRepository from an object that MUST contain all required elements.
     */
    MolecularSequenceRepository.CreateStrict = function (source) {
        var dest = new MolecularSequenceRepository(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceRepository is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceRepository contains all required elements.
     */
    MolecularSequenceRepository.prototype.checkRequiredElements = function () {
        var missingElements = [];
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceRepository;
}(fhirModels.BackboneElement));
export { MolecularSequenceRepository };
/**
 * Code Values for the MolecularSequence.repository.type field
 */
export var MolecularSequenceRepositoryTypeEnum;
(function (MolecularSequenceRepositoryTypeEnum) {
    MolecularSequenceRepositoryTypeEnum["DIRECTLINK"] = "directlink";
    MolecularSequenceRepositoryTypeEnum["OPENAPI"] = "openapi";
    MolecularSequenceRepositoryTypeEnum["LOGIN"] = "login";
    MolecularSequenceRepositoryTypeEnum["OAUTH"] = "oauth";
    MolecularSequenceRepositoryTypeEnum["OTHER"] = "other";
})(MolecularSequenceRepositoryTypeEnum || (MolecularSequenceRepositoryTypeEnum = {}));
/**
 * Structural variant outer.
 */
var MolecularSequenceStructureVariantOuter = /** @class */ (function (_super) {
    __extends(MolecularSequenceStructureVariantOuter, _super);
    /**
     * Default constructor for MolecularSequenceStructureVariantOuter from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceStructureVariantOuter(source) {
        var _this = _super.call(this, source) || this;
        if (source["end"] !== undefined) {
            _this.end = source.end;
        }
        if (source["_end"] !== undefined) {
            _this._end = new fhirModels.Element(source._end);
        }
        if (source["start"] !== undefined) {
            _this.start = source.start;
        }
        if (source["_start"] !== undefined) {
            _this._start = new fhirModels.Element(source._start);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceStructureVariantOuter from an object that MUST contain all required elements.
     */
    MolecularSequenceStructureVariantOuter.CreateStrict = function (source) {
        var dest = new MolecularSequenceStructureVariantOuter(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceStructureVariantOuter is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceStructureVariantOuter contains all required elements.
     */
    MolecularSequenceStructureVariantOuter.prototype.checkRequiredElements = function () {
        var missingElements = [];
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceStructureVariantOuter;
}(fhirModels.BackboneElement));
export { MolecularSequenceStructureVariantOuter };
/**
 * Structural variant inner.
 */
var MolecularSequenceStructureVariantInner = /** @class */ (function (_super) {
    __extends(MolecularSequenceStructureVariantInner, _super);
    /**
     * Default constructor for MolecularSequenceStructureVariantInner from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceStructureVariantInner(source) {
        var _this = _super.call(this, source) || this;
        if (source["end"] !== undefined) {
            _this.end = source.end;
        }
        if (source["_end"] !== undefined) {
            _this._end = new fhirModels.Element(source._end);
        }
        if (source["start"] !== undefined) {
            _this.start = source.start;
        }
        if (source["_start"] !== undefined) {
            _this._start = new fhirModels.Element(source._start);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceStructureVariantInner from an object that MUST contain all required elements.
     */
    MolecularSequenceStructureVariantInner.CreateStrict = function (source) {
        var dest = new MolecularSequenceStructureVariantInner(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceStructureVariantInner is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceStructureVariantInner contains all required elements.
     */
    MolecularSequenceStructureVariantInner.prototype.checkRequiredElements = function () {
        var missingElements = [];
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceStructureVariantInner;
}(fhirModels.BackboneElement));
export { MolecularSequenceStructureVariantInner };
/**
 * Information about chromosome structure variation.
 */
var MolecularSequenceStructureVariant = /** @class */ (function (_super) {
    __extends(MolecularSequenceStructureVariant, _super);
    /**
     * Default constructor for MolecularSequenceStructureVariant from an object that MAY NOT contain all required elements.
     */
    function MolecularSequenceStructureVariant(source) {
        var _this = _super.call(this, source) || this;
        if (source["exact"] !== undefined) {
            _this.exact = source.exact;
        }
        if (source["_exact"] !== undefined) {
            _this._exact = new fhirModels.Element(source._exact);
        }
        if (source["inner"] !== undefined) {
            _this.inner = new fhirModels.MolecularSequenceStructureVariantInner(source.inner);
        }
        if (source["length"] !== undefined) {
            _this.length = source.length;
        }
        if (source["_length"] !== undefined) {
            _this._length = new fhirModels.Element(source._length);
        }
        if (source["outer"] !== undefined) {
            _this.outer = new fhirModels.MolecularSequenceStructureVariantOuter(source.outer);
        }
        if (source["variantType"] !== undefined) {
            _this.variantType = new fhirModels.CodeableConcept(source.variantType);
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequenceStructureVariant from an object that MUST contain all required elements.
     */
    MolecularSequenceStructureVariant.CreateStrict = function (source) {
        var dest = new MolecularSequenceStructureVariant(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequenceStructureVariant is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequenceStructureVariant contains all required elements.
     */
    MolecularSequenceStructureVariant.prototype.checkRequiredElements = function () {
        var missingElements = [];
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequenceStructureVariant;
}(fhirModels.BackboneElement));
export { MolecularSequenceStructureVariant };
/**
 * Raw data describing a biological sequence.
 */
var MolecularSequence = /** @class */ (function (_super) {
    __extends(MolecularSequence, _super);
    /**
     * Default constructor for MolecularSequence from an object that MAY NOT contain all required elements.
     */
    function MolecularSequence(source) {
        var _this = _super.call(this, source) || this;
        /**
         * Resource Type Name
         */
        _this.resourceType = "MolecularSequence";
        if ((source['resourceType'] !== "MolecularSequence") || (source['resourceType'] !== undefined)) {
            throw 'Invalid resourceType for a MolecularSequence';
        }
        if (source["coordinateSystem"] !== undefined) {
            _this.coordinateSystem = source.coordinateSystem;
        }
        if (source["_coordinateSystem"] !== undefined) {
            _this._coordinateSystem = new fhirModels.Element(source._coordinateSystem);
        }
        if (source["device"] !== undefined) {
            _this.device = new fhirModels.Reference(source.device);
        }
        if (source["identifier"] !== undefined) {
            _this.identifier = source.identifier.map(function (x) { return new fhirModels.Identifier(x); });
        }
        if (source["observedSeq"] !== undefined) {
            _this.observedSeq = source.observedSeq;
        }
        if (source["_observedSeq"] !== undefined) {
            _this._observedSeq = new fhirModels.Element(source._observedSeq);
        }
        if (source["patient"] !== undefined) {
            _this.patient = new fhirModels.Reference(source.patient);
        }
        if (source["performer"] !== undefined) {
            _this.performer = new fhirModels.Reference(source.performer);
        }
        if (source["pointer"] !== undefined) {
            _this.pointer = source.pointer.map(function (x) { return new fhirModels.Reference(x); });
        }
        if (source["quality"] !== undefined) {
            _this.quality = source.quality.map(function (x) { return new fhirModels.MolecularSequenceQuality(x); });
        }
        if (source["quantity"] !== undefined) {
            _this.quantity = new fhirModels.Quantity(source.quantity);
        }
        if (source["readCoverage"] !== undefined) {
            _this.readCoverage = source.readCoverage;
        }
        if (source["_readCoverage"] !== undefined) {
            _this._readCoverage = new fhirModels.Element(source._readCoverage);
        }
        if (source["referenceSeq"] !== undefined) {
            _this.referenceSeq = new fhirModels.MolecularSequenceReferenceSeq(source.referenceSeq);
        }
        if (source["repository"] !== undefined) {
            _this.repository = source.repository.map(function (x) { return new fhirModels.MolecularSequenceRepository(x); });
        }
        if (source["specimen"] !== undefined) {
            _this.specimen = new fhirModels.Reference(source.specimen);
        }
        if (source["structureVariant"] !== undefined) {
            _this.structureVariant = source.structureVariant.map(function (x) { return new fhirModels.MolecularSequenceStructureVariant(x); });
        }
        if (source["type"] !== undefined) {
            _this.type = source.type;
        }
        if (source["_type"] !== undefined) {
            _this._type = new fhirModels.Element(source._type);
        }
        if (source["variant"] !== undefined) {
            _this.variant = source.variant.map(function (x) { return new fhirModels.MolecularSequenceVariant(x); });
        }
        return _this;
    }
    /**
     * Factory function to create a MolecularSequence from an object that MUST contain all required elements.
     */
    MolecularSequence.CreateStrict = function (source) {
        var dest = new MolecularSequence(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw "MolecularSequence is missing elements: ".concat(missingElements.join(", "));
        }
        return dest;
    };
    /**
     * Check if the current MolecularSequence contains all required elements.
     */
    MolecularSequence.prototype.checkRequiredElements = function () {
        var missingElements = [];
        if (this["coordinateSystem"] === undefined) {
            missingElements.push("coordinateSystem");
        }
        var parentMissing = _super.prototype.checkRequiredElements.call(this);
        missingElements.push.apply(missingElements, parentMissing);
        return missingElements;
    };
    return MolecularSequence;
}(fhirModels.DomainResource));
export { MolecularSequence };
/**
 * Code Values for the MolecularSequence.type field
 */
export var MolecularSequenceTypeEnum;
(function (MolecularSequenceTypeEnum) {
    MolecularSequenceTypeEnum["AA"] = "aa";
    MolecularSequenceTypeEnum["DNA"] = "dna";
    MolecularSequenceTypeEnum["RNA"] = "rna";
})(MolecularSequenceTypeEnum || (MolecularSequenceTypeEnum = {}));
