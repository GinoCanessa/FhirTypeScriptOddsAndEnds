"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BundleTypeEnum = exports.Bundle = exports.BundleEntry = exports.BundleEntryResponse = exports.BundleEntryRequestMethodEnum = exports.BundleEntryRequest = exports.BundleEntrySearchModeEnum = exports.BundleEntrySearch = exports.BundleLink = void 0;
// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
const fhirModels = __importStar(require("../optionalmodels"));
/**
 * Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).
 * Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](http.html#read) directly.
 * This specification defines some specific uses of Bundle.link for [searching](search.html#conformance) and [paging](http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
 */
class BundleLink extends fhirModels.BackboneElement {
    /**
     * Default constructor for BundleLink from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["relation"] !== undefined) {
            this.relation = source.relation;
        }
        if (source["_relation"] !== undefined) {
            this._relation = new fhirModels.Element(source._relation);
        }
        if (source["url"] !== undefined) {
            this.url = source.url;
        }
        if (source["_url"] !== undefined) {
            this._url = new fhirModels.Element(source._url);
        }
    }
    /**
     * Factory function to create a BundleLink from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new BundleLink(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `BundleLink is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current BundleLink contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["relation"] === undefined) {
            missingElements.push("relation");
        }
        if (this["url"] === undefined) {
            missingElements.push("url");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.BundleLink = BundleLink;
/**
 * Information about the search process that lead to the creation of this entry.
 */
class BundleEntrySearch extends fhirModels.BackboneElement {
    /**
     * Default constructor for BundleEntrySearch from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["mode"] !== undefined) {
            this.mode = source.mode;
        }
        if (source["_mode"] !== undefined) {
            this._mode = new fhirModels.Element(source._mode);
        }
        if (source["score"] !== undefined) {
            this.score = source.score;
        }
        if (source["_score"] !== undefined) {
            this._score = new fhirModels.Element(source._score);
        }
    }
    /**
     * Factory function to create a BundleEntrySearch from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new BundleEntrySearch(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `BundleEntrySearch is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current BundleEntrySearch contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.BundleEntrySearch = BundleEntrySearch;
/**
 * Code Values for the Bundle.entry.search.mode field
 */
var BundleEntrySearchModeEnum;
(function (BundleEntrySearchModeEnum) {
    BundleEntrySearchModeEnum["MATCH"] = "match";
    BundleEntrySearchModeEnum["INCLUDE"] = "include";
    BundleEntrySearchModeEnum["OUTCOME"] = "outcome";
})(BundleEntrySearchModeEnum = exports.BundleEntrySearchModeEnum || (exports.BundleEntrySearchModeEnum = {}));
/**
 * Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
 */
class BundleEntryRequest extends fhirModels.BackboneElement {
    /**
     * Default constructor for BundleEntryRequest from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["ifMatch"] !== undefined) {
            this.ifMatch = source.ifMatch;
        }
        if (source["_ifMatch"] !== undefined) {
            this._ifMatch = new fhirModels.Element(source._ifMatch);
        }
        if (source["ifModifiedSince"] !== undefined) {
            this.ifModifiedSince = source.ifModifiedSince;
        }
        if (source["_ifModifiedSince"] !== undefined) {
            this._ifModifiedSince = new fhirModels.Element(source._ifModifiedSince);
        }
        if (source["ifNoneExist"] !== undefined) {
            this.ifNoneExist = source.ifNoneExist;
        }
        if (source["_ifNoneExist"] !== undefined) {
            this._ifNoneExist = new fhirModels.Element(source._ifNoneExist);
        }
        if (source["ifNoneMatch"] !== undefined) {
            this.ifNoneMatch = source.ifNoneMatch;
        }
        if (source["_ifNoneMatch"] !== undefined) {
            this._ifNoneMatch = new fhirModels.Element(source._ifNoneMatch);
        }
        if (source["method"] !== undefined) {
            this.method = source.method;
        }
        if (source["_method"] !== undefined) {
            this._method = new fhirModels.Element(source._method);
        }
        if (source["url"] !== undefined) {
            this.url = source.url;
        }
        if (source["_url"] !== undefined) {
            this._url = new fhirModels.Element(source._url);
        }
    }
    /**
     * Factory function to create a BundleEntryRequest from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new BundleEntryRequest(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `BundleEntryRequest is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current BundleEntryRequest contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["method"] === undefined) {
            missingElements.push("method");
        }
        if (this["url"] === undefined) {
            missingElements.push("url");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.BundleEntryRequest = BundleEntryRequest;
/**
 * Code Values for the Bundle.entry.request.method field
 */
var BundleEntryRequestMethodEnum;
(function (BundleEntryRequestMethodEnum) {
    BundleEntryRequestMethodEnum["GET"] = "GET";
    BundleEntryRequestMethodEnum["HEAD"] = "HEAD";
    BundleEntryRequestMethodEnum["POST"] = "POST";
    BundleEntryRequestMethodEnum["PUT"] = "PUT";
    BundleEntryRequestMethodEnum["DELETE"] = "DELETE";
    BundleEntryRequestMethodEnum["PATCH"] = "PATCH";
})(BundleEntryRequestMethodEnum = exports.BundleEntryRequestMethodEnum || (exports.BundleEntryRequestMethodEnum = {}));
/**
 * Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
 */
class BundleEntryResponse extends fhirModels.BackboneElement {
    /**
     * Default constructor for BundleEntryResponse from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["etag"] !== undefined) {
            this.etag = source.etag;
        }
        if (source["_etag"] !== undefined) {
            this._etag = new fhirModels.Element(source._etag);
        }
        if (source["lastModified"] !== undefined) {
            this.lastModified = source.lastModified;
        }
        if (source["_lastModified"] !== undefined) {
            this._lastModified = new fhirModels.Element(source._lastModified);
        }
        if (source["location"] !== undefined) {
            this.location = source.location;
        }
        if (source["_location"] !== undefined) {
            this._location = new fhirModels.Element(source._location);
        }
        if (source["outcome"] !== undefined) {
            this.outcome = (fhirModels.FhirResourceFactory(source.outcome) ?? undefined);
        }
        if (source["status"] !== undefined) {
            this.status = source.status;
        }
        if (source["_status"] !== undefined) {
            this._status = new fhirModels.Element(source._status);
        }
    }
    /**
     * Factory function to create a BundleEntryResponse from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new BundleEntryResponse(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `BundleEntryResponse is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current BundleEntryResponse contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["status"] === undefined) {
            missingElements.push("status");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.BundleEntryResponse = BundleEntryResponse;
/**
 * An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
 */
class BundleEntry extends fhirModels.BackboneElement {
    /**
     * Default constructor for BundleEntry from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        if (source["fullUrl"] !== undefined) {
            this.fullUrl = source.fullUrl;
        }
        if (source["_fullUrl"] !== undefined) {
            this._fullUrl = new fhirModels.Element(source._fullUrl);
        }
        if (source["link"] !== undefined) {
            this.link = source.link.map((x) => new fhirModels.BundleLink(x));
        }
        if (source["request"] !== undefined) {
            this.request = new fhirModels.BundleEntryRequest(source.request);
        }
        if (source["resource"] !== undefined) {
            this.resource = (fhirModels.FhirResourceFactory(source.resource) ?? undefined);
        }
        if (source["response"] !== undefined) {
            this.response = new fhirModels.BundleEntryResponse(source.response);
        }
        if (source["search"] !== undefined) {
            this.search = new fhirModels.BundleEntrySearch(source.search);
        }
    }
    /**
     * Factory function to create a BundleEntry from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new BundleEntry(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `BundleEntry is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current BundleEntry contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.BundleEntry = BundleEntry;
/**
 * A container for a collection of resources.
 */
class Bundle extends fhirModels.Resource {
    /**
     * Default constructor for Bundle from an object that MAY NOT contain all required elements.
     */
    constructor(source) {
        super(source);
        /**
         * Resource Type Name
         */
        this.resourceType = "Bundle";
        if ((source['resourceType'] !== "Bundle") || (source['resourceType'] !== undefined)) {
            throw 'Invalid resourceType for a Bundle';
        }
        if (source["entry"] !== undefined) {
            this.entry = source.entry.map((x) => new BundleEntry(x));
        }
        if (source["identifier"] !== undefined) {
            this.identifier = new fhirModels.Identifier(source.identifier);
        }
        if (source["link"] !== undefined) {
            this.link = source.link.map((x) => new fhirModels.BundleLink(x));
        }
        if (source["signature"] !== undefined) {
            this.signature = new fhirModels.Signature(source.signature);
        }
        if (source["timestamp"] !== undefined) {
            this.timestamp = source.timestamp;
        }
        if (source["_timestamp"] !== undefined) {
            this._timestamp = new fhirModels.Element(source._timestamp);
        }
        if (source["total"] !== undefined) {
            this.total = source.total;
        }
        if (source["_total"] !== undefined) {
            this._total = new fhirModels.Element(source._total);
        }
        if (source["type"] !== undefined) {
            this.type = source.type;
        }
        if (source["_type"] !== undefined) {
            this._type = new fhirModels.Element(source._type);
        }
    }
    /**
     * Factory function to create a Bundle from an object that MUST contain all required elements.
     */
    static CreateStrict(source) {
        var dest = new Bundle(source);
        var missingElements = dest.checkRequiredElements();
        if (missingElements.length !== 0) {
            throw `Bundle is missing elements: ${missingElements.join(", ")}`;
        }
        return dest;
    }
    /**
     * Check if the current Bundle contains all required elements.
     */
    checkRequiredElements() {
        var missingElements = [];
        if (this["type"] === undefined) {
            missingElements.push("type");
        }
        var parentMissing = super.checkRequiredElements();
        missingElements.push(...parentMissing);
        return missingElements;
    }
}
exports.Bundle = Bundle;
/**
 * Code Values for the Bundle.type field
 */
var BundleTypeEnum;
(function (BundleTypeEnum) {
    BundleTypeEnum["DOCUMENT"] = "document";
    BundleTypeEnum["MESSAGE"] = "message";
    BundleTypeEnum["TRANSACTION"] = "transaction";
    BundleTypeEnum["TRANSACTION_RESPONSE"] = "transaction-response";
    BundleTypeEnum["BATCH"] = "batch";
    BundleTypeEnum["BATCH_RESPONSE"] = "batch-response";
    BundleTypeEnum["HISTORY"] = "history";
    BundleTypeEnum["SEARCHSET"] = "searchset";
    BundleTypeEnum["COLLECTION"] = "collection";
})(BundleTypeEnum = exports.BundleTypeEnum || (exports.BundleTypeEnum = {}));
//# sourceMappingURL=Bundle.js.map