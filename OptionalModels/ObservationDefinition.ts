// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
  // Primitive Naming Style: None
  // Complex Type / Resource Naming Style: PascalCase
  // Interaction Naming Style: None
  // Extension Support: NonPrimitive
// Minimum TypeScript Version: 3.7
import * as fhirModels from '../optionalmodels'
import * as fhirInterfaces from '../optionalinterfaces'
/**
 * Characteristics for quantitative results of this observation.
 */
export class ObservationDefinitionQuantitativeDetails extends fhirModels.BackboneElement implements fhirInterfaces.IObservationDefinitionQuantitativeDetails {
  /**
   * Factor for converting value expressed with SI unit to value expressed with customary unit.
   */
  conversionFactor?: number|undefined;
  _conversionFactor?: fhirModels.Element|undefined;
  /**
   * Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  customaryUnit?: fhirModels.CodeableConcept|undefined;
  /**
   * Number of digits after decimal separator when the results of such observations are of type Quantity.
   */
  decimalPrecision?: number|undefined;
  _decimalPrecision?: fhirModels.Element|undefined;
  /**
   * SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
   */
  unit?: fhirModels.CodeableConcept|undefined;
  /**
   * Default constructor for ObservationDefinitionQuantitativeDetails from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IObservationDefinitionQuantitativeDetails>) {
    super(source);
    if (source["conversionFactor"] !== undefined) { this.conversionFactor = source.conversionFactor; }
    if (source["_conversionFactor"] !== undefined) { this._conversionFactor = new fhirModels.Element(source._conversionFactor); }
    if (source["customaryUnit"] !== undefined) { this.customaryUnit = new fhirModels.CodeableConcept(source.customaryUnit); }
    if (source["decimalPrecision"] !== undefined) { this.decimalPrecision = source.decimalPrecision; }
    if (source["_decimalPrecision"] !== undefined) { this._decimalPrecision = new fhirModels.Element(source._decimalPrecision); }
    if (source["unit"] !== undefined) { this.unit = new fhirModels.CodeableConcept(source.unit); }
  }
  /**
   * Factory function to create a ObservationDefinitionQuantitativeDetails from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IObservationDefinitionQuantitativeDetails):ObservationDefinitionQuantitativeDetails {
    var dest:ObservationDefinitionQuantitativeDetails = new ObservationDefinitionQuantitativeDetails(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `ObservationDefinitionQuantitativeDetails is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
  /**
   * Check if the current ObservationDefinitionQuantitativeDetails contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
}
/**
 * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
 */
export class ObservationDefinitionQualifiedInterval extends fhirModels.BackboneElement implements fhirInterfaces.IObservationDefinitionQualifiedInterval {
  /**
   * Some analytes vary greatly over age.
   */
  age?: fhirModels.Range|undefined;
  /**
   * If this element is not present then the global population is assumed.
   */
  appliesTo?: fhirModels.CodeableConcept[]|undefined;
  /**
   * The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
   */
  category?: ObservationDefinitionQualifiedIntervalCategoryEnum|undefined;
  _category?: fhirModels.Element|undefined;
  /**
   * Text based condition for which the reference range is valid.
   */
  condition?: string|undefined;
  _condition?: fhirModels.Element|undefined;
  /**
   * Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
   */
  context?: fhirModels.CodeableConcept|undefined;
  /**
   * Sex of the population the range applies to.
   */
  gender?: ObservationDefinitionQualifiedIntervalGenderEnum|undefined;
  _gender?: fhirModels.Element|undefined;
  /**
   * The gestational age to which this reference range is applicable, in the context of pregnancy.
   */
  gestationalAge?: fhirModels.Range|undefined;
  /**
   * The low and high values determining the interval. There may be only one of the two.
   */
  range?: fhirModels.Range|undefined;
  /**
   * Default constructor for ObservationDefinitionQualifiedInterval from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IObservationDefinitionQualifiedInterval>) {
    super(source);
    if (source["age"] !== undefined) { this.age = new fhirModels.Range(source.age); }
    if (source["appliesTo"] !== undefined) { this.appliesTo = source.appliesTo.map((x) => new fhirModels.CodeableConcept(x)); }
    if (source["category"] !== undefined) { this.category = source.category; }
    if (source["_category"] !== undefined) { this._category = new fhirModels.Element(source._category); }
    if (source["condition"] !== undefined) { this.condition = source.condition; }
    if (source["_condition"] !== undefined) { this._condition = new fhirModels.Element(source._condition); }
    if (source["context"] !== undefined) { this.context = new fhirModels.CodeableConcept(source.context); }
    if (source["gender"] !== undefined) { this.gender = source.gender; }
    if (source["_gender"] !== undefined) { this._gender = new fhirModels.Element(source._gender); }
    if (source["gestationalAge"] !== undefined) { this.gestationalAge = new fhirModels.Range(source.gestationalAge); }
    if (source["range"] !== undefined) { this.range = new fhirModels.Range(source.range); }
  }
  /**
   * Factory function to create a ObservationDefinitionQualifiedInterval from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IObservationDefinitionQualifiedInterval):ObservationDefinitionQualifiedInterval {
    var dest:ObservationDefinitionQualifiedInterval = new ObservationDefinitionQualifiedInterval(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `ObservationDefinitionQualifiedInterval is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
  /**
   * Check if the current ObservationDefinitionQualifiedInterval contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
}
/**
 * Code Values for the ObservationDefinition.qualifiedInterval.category field
 */
export enum ObservationDefinitionQualifiedIntervalCategoryEnum {
  REFERENCE = "reference",
  CRITICAL = "critical",
  ABSOLUTE = "absolute",
}
/**
 * Code Values for the ObservationDefinition.qualifiedInterval.gender field
 */
export enum ObservationDefinitionQualifiedIntervalGenderEnum {
  MALE = "male",
  FEMALE = "female",
  OTHER = "other",
  UNKNOWN = "unknown",
}
/**
 * Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
 */
export class ObservationDefinition extends fhirModels.DomainResource implements fhirInterfaces.IObservationDefinition {
  /**
   * Resource Type Name
   */
  readonly resourceType = "ObservationDefinition";
  /**
   * The set of abnormal coded results for the observation conforming to this ObservationDefinition.
   */
  abnormalCodedValueSet?: fhirModels.Reference|undefined;
  /**
   * This element allows various categorization schemes based on the ownerâ€™s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
   */
  category?: fhirModels.CodeableConcept[]|undefined;
  /**
   * Describes what will be observed. Sometimes this is called the observation "name".
   */
  code?: fhirModels.CodeableConcept|undefined;
  /**
   * The set of critical coded results for the observation conforming to this ObservationDefinition.
   */
  criticalCodedValueSet?: fhirModels.Reference|undefined;
  /**
   * A unique identifier assigned to this ObservationDefinition artifact.
   */
  identifier?: fhirModels.Identifier[]|undefined;
  /**
   * Only used if not implicit in observation code.
   */
  method?: fhirModels.CodeableConcept|undefined;
  /**
   * An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
   */
  multipleResultsAllowed?: boolean|undefined;
  _multipleResultsAllowed?: fhirModels.Element|undefined;
  /**
   * The set of normal coded results for the observations conforming to this ObservationDefinition.
   */
  normalCodedValueSet?: fhirModels.Reference|undefined;
  /**
   * The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
   */
  permittedDataType?: ObservationDefinitionPermittedDataTypeEnum[]|undefined;
  _permittedDataType?: fhirModels.Element[]|undefined;
  /**
   * The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
   */
  preferredReportName?: string|undefined;
  _preferredReportName?: fhirModels.Element|undefined;
  /**
   * Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
   */
  qualifiedInterval?: fhirModels.ObservationDefinitionQualifiedInterval[]|undefined;
  /**
   * Characteristics for quantitative results of this observation.
   */
  quantitativeDetails?: fhirModels.ObservationDefinitionQuantitativeDetails|undefined;
  /**
   * The set of valid coded results for the observations  conforming to this ObservationDefinition.
   */
  validCodedValueSet?: fhirModels.Reference|undefined;
  /**
   * Default constructor for ObservationDefinition from an object that MAY NOT contain all required elements.
   */
  constructor(source:Partial<fhirInterfaces.IObservationDefinition>) {
    super(source);
    if ((source['resourceType'] !== "ObservationDefinition") || (source['resourceType'] !== undefined)) { throw 'Invalid resourceType for a ObservationDefinition'; }
    if (source["abnormalCodedValueSet"] !== undefined) { this.abnormalCodedValueSet = new fhirModels.Reference(source.abnormalCodedValueSet); }
    if (source["category"] !== undefined) { this.category = source.category.map((x) => new fhirModels.CodeableConcept(x)); }
    if (source["code"] !== undefined) { this.code = new fhirModels.CodeableConcept(source.code); }
    if (source["criticalCodedValueSet"] !== undefined) { this.criticalCodedValueSet = new fhirModels.Reference(source.criticalCodedValueSet); }
    if (source["identifier"] !== undefined) { this.identifier = source.identifier.map((x) => new fhirModels.Identifier(x)); }
    if (source["method"] !== undefined) { this.method = new fhirModels.CodeableConcept(source.method); }
    if (source["multipleResultsAllowed"] !== undefined) { this.multipleResultsAllowed = source.multipleResultsAllowed; }
    if (source["_multipleResultsAllowed"] !== undefined) { this._multipleResultsAllowed = new fhirModels.Element(source._multipleResultsAllowed); }
    if (source["normalCodedValueSet"] !== undefined) { this.normalCodedValueSet = new fhirModels.Reference(source.normalCodedValueSet); }
    if (source["permittedDataType"] !== undefined) { this.permittedDataType = source.permittedDataType.map((x) => (x)); }
    if (source["_permittedDataType"] !== undefined) { this._permittedDataType = source._permittedDataType.map((x) => new fhirModels.Element(x)); }
    if (source["preferredReportName"] !== undefined) { this.preferredReportName = source.preferredReportName; }
    if (source["_preferredReportName"] !== undefined) { this._preferredReportName = new fhirModels.Element(source._preferredReportName); }
    if (source["qualifiedInterval"] !== undefined) { this.qualifiedInterval = source.qualifiedInterval.map((x) => new fhirModels.ObservationDefinitionQualifiedInterval(x)); }
    if (source["quantitativeDetails"] !== undefined) { this.quantitativeDetails = new fhirModels.ObservationDefinitionQuantitativeDetails(source.quantitativeDetails); }
    if (source["validCodedValueSet"] !== undefined) { this.validCodedValueSet = new fhirModels.Reference(source.validCodedValueSet); }
  }
  /**
   * Factory function to create a ObservationDefinition from an object that MUST contain all required elements.
   */
  static CreateStrict(source:fhirInterfaces.IObservationDefinition):ObservationDefinition {
    var dest:ObservationDefinition = new ObservationDefinition(source);
    var missingElements:string[] = dest.checkRequiredElements();
    if (missingElements.length !== 0) {
    throw `ObservationDefinition is missing elements: ${missingElements.join(", ")}`
     }
    return dest;
  }
  /**
   * Check if the current ObservationDefinition contains all required elements.
   */
  checkRequiredElements():string[] {
    var missingElements:string[] = [];
    if (this["code"] === undefined) { missingElements.push("code"); }
    var parentMissing:string[] = super.checkRequiredElements();
    missingElements.push(...parentMissing);
    return missingElements;
  }
}
/**
 * Code Values for the ObservationDefinition.permittedDataType field
 */
export enum ObservationDefinitionPermittedDataTypeEnum {
  QUANTITY = "Quantity",
  CODEABLECONCEPT = "CodeableConcept",
  STRING = "string",
  BOOLEAN = "boolean",
  INTEGER = "integer",
  RANGE = "Range",
  RATIO = "Ratio",
  SAMPLEDDATA = "SampledData",
  TIME = "time",
  DATETIME = "dateTime",
  PERIOD = "Period",
}
